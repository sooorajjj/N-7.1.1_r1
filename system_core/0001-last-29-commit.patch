From c996246e5b02225662a843ef6ce9f262cdb1b2e3 Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Mon, 26 Oct 2015 00:25:02 +0100
Subject: [PATCH 01/30] init: bring back TARGET_INIT_VENDOR_LIB

was lost somehow

Change-Id: I29519fb822071fb900fe47d0b295f795ca7f5ed5
---
 init/Android.mk | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index 67541b8..84ee0b6 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -110,6 +110,11 @@ LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \
 
 LOCAL_SANITIZE := integer
 LOCAL_CLANG := true
+
+ifneq ($(strip $(TARGET_INIT_VENDOR_LIB)),)
+LOCAL_WHOLE_STATIC_LIBRARIES += $(TARGET_INIT_VENDOR_LIB)
+endif
+
 include $(BUILD_EXECUTABLE)
 
 
-- 
2.7.4


From 20aede3850cc1a47f9fdeeb019d5b468018a1228 Mon Sep 17 00:00:00 2001
From: David Ng <dave@codeaurora.org>
Date: Wed, 11 Dec 2013 19:40:09 -0800
Subject: [PATCH 02/30] init: Allow target-specific platform device base to be
 specified.

Add optional build-time flag, TARGET_PLATFORM_DEVICE_BASE,
to specify the base sysfs path (without the /sys prefix)
where the platform device resides.  This provides support for
targets where platform devices are all under a master level
platform device (e.g. soc-bus).

PS2: Change C_FLAGS to CPP_FLAGS
PS3: Change back to C_FLAGS

Change-Id: I1196fddaddbd03bd472db95ed4d67f818e3af0cb
---
 init/Android.mk | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index 84ee0b6..fc3fef8 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -111,6 +111,9 @@ LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \
 LOCAL_SANITIZE := integer
 LOCAL_CLANG := true
 
+ifneq ($(strip $(TARGET_PLATFORM_DEVICE_BASE)),)
+LOCAL_CFLAGS += -D_PLATFORM_BASE="\"$(TARGET_PLATFORM_DEVICE_BASE)\""
+endif
 ifneq ($(strip $(TARGET_INIT_VENDOR_LIB)),)
 LOCAL_WHOLE_STATIC_LIBRARIES += $(TARGET_INIT_VENDOR_LIB)
 endif
-- 
2.7.4


From 3c8ef20e6135263899dd10499da30bfac1eb3b55 Mon Sep 17 00:00:00 2001
From: Biswajit Paul <biswajitpaul@codeaurora.org>
Date: Mon, 3 Nov 2014 16:33:45 -0800
Subject: [PATCH 03/30] init: Do not call recursive_restorecon on PLATFORM_BASE

During coldboot calling restorecon_recursive on soc.0 causes boot
time delays and failing the framework to bootup.

PS3: Update define to actually use BoardConfig flag
PS4: Remove unnecessary define as _PLATFORM_BASE is already defined
PS5: Update commit message to indicate PLATFORM_BASE which is specified
in BoardConfig

Change-Id: Ie364a3ca30db3a1344ea95def04f09660947a13f
---
 init/devices.cpp | 7 +++++++
 1 file changed, 7 insertions(+)

diff --git a/init/devices.cpp b/init/devices.cpp
index cffc561..86524bc 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -167,7 +167,14 @@ void fixup_sys_perms(const char *upath)
     }
     if (access(buf, F_OK) == 0) {
         INFO("restorecon_recursive: %s\n", buf);
+#ifdef _PLATFORM_BASE
+        if(!strcmp(upath, _PLATFORM_BASE))
+            restorecon(buf);
+        else
+            restorecon_recursive(buf);
+#else
         restorecon_recursive(buf);
+#endif
     }
 }
 
-- 
2.7.4


From 0a1987b9395dfc9357c3f7179d8bbce3db016c47 Mon Sep 17 00:00:00 2001
From: Gabriele M <moto.falcon.git@gmail.com>
Date: Tue, 9 Feb 2016 01:59:12 +0100
Subject: [PATCH 04/30] init: Allow to increase the coldboot timeout

Since commit 651fae3cbc91 ("Reduce the coldboot timeout to 1s.") the
coldboot timeout is 1s rather than 5s. This might not be enough for
some devices, so add TARGET_INCREASES_COLDBOOT_TIMEOUT to allow the
use of the old timeout.

Change-Id: I9ed14a4cfdaa1684aae83e6b5272a82d604eedee
---
 init/Android.mk | 4 ++++
 init/init.cpp   | 4 ++++
 2 files changed, 8 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index fc3fef8..5b1693c 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -118,6 +118,10 @@ ifneq ($(strip $(TARGET_INIT_VENDOR_LIB)),)
 LOCAL_WHOLE_STATIC_LIBRARIES += $(TARGET_INIT_VENDOR_LIB)
 endif
 
+ifeq ($(TARGET_INCREASES_COLDBOOT_TIMEOUT),true)
+LOCAL_CFLAGS += -DINCREASE_COLDBOOT_TIMEOUT
+endif
+
 include $(BUILD_EXECUTABLE)
 
 
diff --git a/init/init.cpp b/init/init.cpp
index 84da2b9..9d0c3e0 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -166,7 +166,11 @@ static int wait_for_coldboot_done_action(const std::vector<std::string>& args) {
     // Any longer than 1s is an unreasonable length of time to delay booting.
     // If you're hitting this timeout, check that you didn't make your
     // sepolicy regular expressions too expensive (http://b/19899875).
+#ifdef INCREASE_COLDBOOT_TIMEOUT
+    if (wait_for_file(COLDBOOT_DONE, COMMAND_RETRY_TIMEOUT)) {
+#else
     if (wait_for_file(COLDBOOT_DONE, 1)) {
+#endif
         ERROR("Timed out waiting for %s\n", COLDBOOT_DONE);
     }
 
-- 
2.7.4


From 068d48b4d772d68eab7cfadb56e2d52fef2c38d7 Mon Sep 17 00:00:00 2001
From: Satya Durga Srinivasu Prabhala <satyap@codeaurora.org>
Date: Fri, 10 Jul 2015 17:31:50 -0700
Subject: [PATCH 05/30] system: core: Add Sensors group

Defining group for sensors.

CRs-Fixed: 431081

Change-Id: I58151f2fd727bded1b16adb3caeac85e27e44036
---
 include/private/android_filesystem_config.h | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/include/private/android_filesystem_config.h b/include/private/android_filesystem_config.h
index 5ccd80e..b848cba 100644
--- a/include/private/android_filesystem_config.h
+++ b/include/private/android_filesystem_config.h
@@ -122,6 +122,8 @@
 #define AID_OEM_RESERVED_2_START 5000
 #define AID_OEM_RESERVED_2_END   5999
 
+#define AID_SENSORS       3011 /* access to /dev/socket/sensor_ctl_socket & QCCI/QCSI */
+
 #define AID_EVERYBODY     9997  /* shared between all apps in the same profile */
 #define AID_MISC          9998  /* access to misc storage */
 #define AID_NOBODY        9999
@@ -223,6 +225,8 @@ static const struct android_id_info android_ids[] = {
     { "readproc",      AID_READPROC, },
     { "wakelock",      AID_WAKELOCK, },
 
+    { "sensors",       AID_SENSORS, },
+
     { "everybody",     AID_EVERYBODY, },
     { "misc",          AID_MISC, },
     { "nobody",        AID_NOBODY, },
-- 
2.7.4


From ddb9da75d71134ae258bb27fa89eb61776e7b5e5 Mon Sep 17 00:00:00 2001
From: Menno van Grinsven <scanno71@gmail.com>
Date: Mon, 16 May 2016 17:27:37 +0200
Subject: [PATCH 07/30] fs_mgr: Change f2fs path

Change-Id: I58980e8fc3c84125608ba5b18bc6c7416d7a2041
---
 fs_mgr/fs_mgr_format.c | 4 ++--
 1 file changed, 2 insertions(+), 2 deletions(-)

diff --git a/fs_mgr/fs_mgr_format.c b/fs_mgr/fs_mgr_format.c
index f8df081..d070dcd 100644
--- a/fs_mgr/fs_mgr_format.c
+++ b/fs_mgr/fs_mgr_format.c
@@ -67,7 +67,7 @@ static int format_f2fs(char *fs_blkdev)
     int pid;
     int rc = 0;
 
-    args[0] = (char *)"/sbin/mkfs.f2fs";
+    args[0] = (char *)"/system/bin/make_f2fs";
     args[1] = fs_blkdev;
     args[2] = (char *)0;
 
@@ -77,7 +77,7 @@ static int format_f2fs(char *fs_blkdev)
     }
     if (!pid) {
         /* This doesn't return */
-        execv("/sbin/mkfs.f2fs", args);
+        execv("/system/bin/make_f2fs", args);
         exit(1);
     }
     for(;;) {
-- 
2.7.4


From 35f81e3bf870cdf9b7ce2a2a7901030a50f41230 Mon Sep 17 00:00:00 2001
From: Dan Pasanen <dan.pasanen@gmail.com>
Date: Wed, 28 Jan 2015 16:41:29 -0800
Subject: [PATCH 08/30] fs_mgr: Skip filesystem check unless fs_type matches

* Prevent accidentally destroying a partition of the wrong type.
* Don't skip iterations of the internal mount_all loop, otherwise
  encryptability may not be properly handled.

Change-Id: I8f3ddc396a5fb85f4ae0a0a11dd61fb4d6462d6d
---
 fs_mgr/Android.mk |  8 ++++++--
 fs_mgr/fs_mgr.c   | 15 +++++++++++++--
 init/Android.mk   |  5 ++++-
 3 files changed, 23 insertions(+), 5 deletions(-)

diff --git a/fs_mgr/Android.mk b/fs_mgr/Android.mk
index 28fff3f..4cb409a 100644
--- a/fs_mgr/Android.mk
+++ b/fs_mgr/Android.mk
@@ -10,7 +10,8 @@ common_static_libraries := \
     libmincrypt \
     libcrypto_static \
     libext4_utils_static \
-    libsquashfs_utils
+    libsquashfs_utils \
+    libext2_blkid
 
 include $(CLEAR_VARS)
 LOCAL_CLANG := true
@@ -26,7 +27,10 @@ LOCAL_C_INCLUDES := \
     system/vold \
     system/extras/ext4_utils \
     external/openssl/include \
-    bootable/recovery
+    bootable/recovery \
+    system/extras/ext4_utils \
+    system/extras/squashfs_utils \
+    external/e2fsprogs/lib
 LOCAL_MODULE:= libfs_mgr
 LOCAL_STATIC_LIBRARIES := $(common_static_libraries)
 LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
diff --git a/fs_mgr/fs_mgr.c b/fs_mgr/fs_mgr.c
index 387f708..2add5df 100644
--- a/fs_mgr/fs_mgr.c
+++ b/fs_mgr/fs_mgr.c
@@ -39,6 +39,7 @@
 #include <cutils/partition_utils.h>
 #include <cutils/properties.h>
 #include <logwrap/logwrap.h>
+#include <blkid/blkid.h>
 
 #include "mincrypt/rsa.h"
 #include "mincrypt/sha.h"
@@ -309,6 +310,8 @@ static int mount_with_alternatives(struct fstab *fstab, int start_idx, int *end_
     int i;
     int mount_errno = 0;
     int mounted = 0;
+    int cmp_len;
+    char *detected_fs_type;
 
     if (!end_idx || !attempted_idx || start_idx >= fstab->num_entries) {
       errno = EINVAL;
@@ -334,8 +337,16 @@ static int mount_with_alternatives(struct fstab *fstab, int start_idx, int *end_
             }
 
             if (fstab->recs[i].fs_mgr_flags & MF_CHECK) {
-                check_fs(fstab->recs[i].blk_device, fstab->recs[i].fs_type,
-                         fstab->recs[i].mount_point);
+                /* Skip file system check unless we are sure we are the right type */
+                detected_fs_type = blkid_get_tag_value(NULL, "TYPE", fstab->recs[i].blk_device);
+                if (detected_fs_type) {
+                    cmp_len = (!strncmp(detected_fs_type, "ext", 3) &&
+                            strlen(detected_fs_type) == 4) ? 3 : strlen(detected_fs_type);
+                    if (!strncmp(fstab->recs[i].fs_type, detected_fs_type, cmp_len)) {
+                        check_fs(fstab->recs[i].blk_device, fstab->recs[i].fs_type,
+                                 fstab->recs[i].mount_point);
+                    }
+                }
             }
             if (!__mount(fstab->recs[i].blk_device, fstab->recs[i].mount_point, &fstab->recs[i])) {
                 *attempted_idx = i;
diff --git a/init/Android.mk b/init/Android.mk
index 5b1693c..a6bd5c8 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -101,7 +101,10 @@ LOCAL_STATIC_LIBRARIES := \
     libc++_static \
     libdl \
     libsparse_static \
-    libz
+    libz \
+    libext2_blkid \
+    libext2_uuid_static
+
 
 # Create symlinks
 LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \
-- 
2.7.4


From 20dc1f93083b5a7d42e13bcfd20a58f71901e504 Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Sat, 17 Sep 2016 01:36:55 +0200
Subject: [PATCH 09/30] core: bring back vendor init hook

Change-Id: I46a3186b9c4f8a3e092d24f2e8e9fc3ec10ab7d8
---
 init/Android.mk           |  1 +
 init/property_service.cpp |  5 +++++
 init/vendor_init.cpp      | 37 +++++++++++++++++++++++++++++++++++++
 init/vendor_init.h        | 33 +++++++++++++++++++++++++++++++++
 4 files changed, 76 insertions(+)
 create mode 100644 init/vendor_init.cpp
 create mode 100644 init/vendor_init.h

diff --git a/init/Android.mk b/init/Android.mk
index a6bd5c8..e982990 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -70,6 +70,7 @@ LOCAL_SRC_FILES:= \
     signal_handler.cpp \
     ueventd.cpp \
     ueventd_parser.cpp \
+    vendor_init.cpp \
     watchdogd.cpp \
 
 LOCAL_MODULE:= init
diff --git a/init/property_service.cpp b/init/property_service.cpp
index 5c1ae79..8a0d69d 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -54,6 +54,7 @@
 #include "init.h"
 #include "util.h"
 #include "log.h"
+#include "vendor_init.h"
 
 #define PERSISTENT_PROPERTY_DIR  "/data/property"
 #define FSTAB_PREFIX "/fstab."
@@ -477,6 +478,10 @@ void load_persist_props(void) {
     load_override_properties();
     /* Read persistent properties after all default values have been loaded. */
     load_persistent_properties();
+
+    /* vendor-specific properties
+     */
+    vendor_load_properties();
 }
 
 void load_recovery_id_prop() {
diff --git a/init/vendor_init.cpp b/init/vendor_init.cpp
new file mode 100644
index 0000000..d3fd5ff
--- /dev/null
+++ b/init/vendor_init.cpp
@@ -0,0 +1,37 @@
+/*
+Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "vendor_init.h"
+
+/* init vendor override stubs */
+
+__attribute__ ((weak))
+void vendor_load_properties()
+{
+}
diff --git a/init/vendor_init.h b/init/vendor_init.h
new file mode 100644
index 0000000..9afb449
--- /dev/null
+++ b/init/vendor_init.h
@@ -0,0 +1,33 @@
+/*
+Copyright (c) 2013, The Linux Foundation. All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions are
+met:
+    * Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+    * Redistributions in binary form must reproduce the above
+      copyright notice, this list of conditions and the following
+      disclaimer in the documentation and/or other materials provided
+      with the distribution.
+    * Neither the name of The Linux Foundation nor the names of its
+      contributors may be used to endorse or promote products derived
+      from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __INIT_VENDOR__H__
+#define __INIT_VENDOR__H__
+extern void vendor_load_properties(void);
+#endif /* __INIT_VENDOR__H__ */
-- 
2.7.4


From c7471ca514302b2fe30140fb79f41f05ca569159 Mon Sep 17 00:00:00 2001
From: David Ng <dave@codeaurora.org>
Date: Mon, 30 Sep 2013 12:15:26 -0700
Subject: [PATCH 10/30] ueventd: Add bootdevice symlink for boot storage device

Create /dev/block/bootdevice symlink for the boot storage
device based on ro.boot.bootdevice property.  The property
value can be passed in via bootloader.  This abstracts
references to the boot device (including partition nodes
in the boot device) from the actual device nodes (e.g. eMMC,
UFS).

Change-Id: I9c921fc9e31855759435fac27bd384645eee0236
---
 init/devices.cpp | 8 ++++++++
 init/ueventd.cpp | 4 ++++
 2 files changed, 12 insertions(+)

diff --git a/init/devices.cpp b/init/devices.cpp
index 86524bc..cc5e9e9 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -48,6 +48,7 @@
 #include "ueventd_parser.h"
 #include "util.h"
 #include "log.h"
+#include "property_service.h"
 
 #define SYSFS_PREFIX    "/sys"
 static const char *firmware_dirs[] = { "/etc/firmware",
@@ -56,6 +57,8 @@ static const char *firmware_dirs[] = { "/etc/firmware",
 
 extern struct selabel_handle *sehandle;
 
+extern std::string boot_device;
+
 static int device_fd = -1;
 
 struct uevent {
@@ -533,6 +536,11 @@ static char **get_block_device_symlinks(struct uevent *uevent)
     else
         links[link_num] = NULL;
 
+    if (pdev && !boot_device.empty() && strstr(device, boot_device.c_str())) {
+        /* Create bootdevice symlink for platform boot stroage device */
+        make_link_init(link_path, "/dev/block/bootdevice");
+    }
+
     return links;
 }
 
diff --git a/init/ueventd.cpp b/init/ueventd.cpp
index 249739b..131e97f 100644
--- a/init/ueventd.cpp
+++ b/init/ueventd.cpp
@@ -33,6 +33,8 @@
 #include "ueventd_parser.h"
 #include "property_service.h"
 
+std::string boot_device;
+
 int ueventd_main(int argc, char **argv)
 {
     /*
@@ -64,6 +66,8 @@ int ueventd_main(int argc, char **argv)
     ueventd_parse_config_file("/ueventd.rc");
     ueventd_parse_config_file(android::base::StringPrintf("/ueventd.%s.rc", hardware.c_str()).c_str());
 
+    boot_device = property_get("ro.boot.bootdevice");
+
     device_init();
 
     pollfd ufd;
-- 
2.7.4


From afa3952b1c1c6ac1e8eb1531d4c5721b8921302a Mon Sep 17 00:00:00 2001
From: M1cha <sigmaepsilon92@gmail.com>
Date: Fri, 26 Aug 2016 06:32:25 +0200
Subject: [PATCH 11/30] mkbootimg: add support for --dt

Change-Id: I19f149fac693420cf1f630b51293bbd3650a1b59
---
 mkbootimg/mkbootimg | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/mkbootimg/mkbootimg b/mkbootimg/mkbootimg
index 5a13da2..d0149e8 100755
--- a/mkbootimg/mkbootimg
+++ b/mkbootimg/mkbootimg
@@ -57,7 +57,7 @@ def write_header(args):
         args.base + args.second_offset,                 # physical load addr
         args.base + args.tags_offset,                   # physical addr for kernel tags
         args.pagesize,                                  # flash page size we assume
-        0,                                              # future expansion: MUST be 0
+        filesize(args.dt),                              # size in bytes
         (args.os_version << 11) | args.os_patch_level)) # os version and patch level
     args.output.write(pack('16s', args.board.encode())) # asciiz product name
     args.output.write(pack('512s', args.cmdline[:512].encode()))
@@ -66,6 +66,7 @@ def write_header(args):
     update_sha(sha, args.kernel)
     update_sha(sha, args.ramdisk)
     update_sha(sha, args.second)
+    update_sha(sha, args.dt)
     img_id = pack('32s', sha.digest())
 
     args.output.write(img_id)
@@ -150,6 +151,7 @@ def parse_cmdline():
                         choices=[2**i for i in range(11,15)], default=2048)
     parser.add_argument('--id', help='print the image ID on standard output',
                         action='store_true')
+    parser.add_argument('--dt', help='path to the device tree image', type=FileType('rb'))
     parser.add_argument('-o', '--output', help='output file name', type=FileType('wb'),
                         required=True)
     return parser.parse_args()
@@ -159,6 +161,7 @@ def write_data(args):
     write_padded_file(args.output, args.kernel, args.pagesize)
     write_padded_file(args.output, args.ramdisk, args.pagesize)
     write_padded_file(args.output, args.second, args.pagesize)
+    write_padded_file(args.output, args.dt, args.pagesize)
 
 
 def main():
-- 
2.7.4


From 9e7150f53622993221220d28b87d54ae13e2e631 Mon Sep 17 00:00:00 2001
From: Steve Kondik <steve@cyngn.com>
Date: Mon, 7 Sep 2015 13:32:21 -0700
Subject: [PATCH 12/30] init: Fire a trigger when a class is started/stopped

 * This allows us to react to these events without messing
   with the master config.

Change-Id: Ifc72efc7b4cc0718838c711395f5fdc3b043827a
---
 init/builtins.cpp | 25 +++++++++++++++++++++----
 1 file changed, 21 insertions(+), 4 deletions(-)

diff --git a/init/builtins.cpp b/init/builtins.cpp
index 44217f0..1061fef 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -63,6 +63,8 @@
 #include "signal_handler.h"
 #include "util.h"
 
+using android::base::StringPrintf;
+
 #define chmod DO_NOT_USE_CHMOD_USE_FCHMODAT_SYMLINK_NOFOLLOW
 #define UNMOUNT_CHECK_MS 5000
 #define UNMOUNT_CHECK_TIMES 10
@@ -225,24 +227,39 @@ static void unmount_and_fsck(const struct mntent *entry) {
 }
 
 static int do_class_start(const std::vector<std::string>& args) {
-        /* Starting a class does not start services
-         * which are explicitly disabled.  They must
-         * be started individually.
-         */
+    /* Starting a class does not start services
+     * which are explicitly disabled.  They must
+     * be started individually.
+     */
     ServiceManager::GetInstance().
         ForEachServiceInClass(args[1], [] (Service* s) { s->StartIfNotDisabled(); });
+
+    std::string prop_name = StringPrintf("class_start:%s", args[1].c_str());
+    if (prop_name.length() < PROP_NAME_MAX) {
+        ActionManager::GetInstance().QueueEventTrigger(prop_name);
+    }
     return 0;
 }
 
 static int do_class_stop(const std::vector<std::string>& args) {
     ServiceManager::GetInstance().
         ForEachServiceInClass(args[1], [] (Service* s) { s->Stop(); });
+
+    std::string prop_name = StringPrintf("class_stop:%s", args[1].c_str());
+    if (prop_name.length() < PROP_NAME_MAX) {
+        ActionManager::GetInstance().QueueEventTrigger(prop_name);
+    }
     return 0;
 }
 
 static int do_class_reset(const std::vector<std::string>& args) {
     ServiceManager::GetInstance().
         ForEachServiceInClass(args[1], [] (Service* s) { s->Reset(); });
+
+    std::string prop_name = StringPrintf("class_reset:%s", args[1].c_str());
+    if (prop_name.length() < PROP_NAME_MAX) {
+        ActionManager::GetInstance().QueueEventTrigger(prop_name);
+    }
     return 0;
 }
 
-- 
2.7.4


From 31be63d47163b44bf83dc8fcdfd91415d213ba87 Mon Sep 17 00:00:00 2001
From: Menno van Grinsven <scanno71@gmail.com>
Date: Fri, 13 Mar 2015 10:04:09 -0500
Subject: [PATCH 13/30] init: Add support for gzipped firmware files

In case no matching firmware is found, re-search the paths for
[path][firmware].gz and use that instead if found.

Change-Id: I74e42ab3c77eb7722c58042489d7bd4856f3be63
---
 init/Android.mk  |  3 ++-
 init/devices.cpp | 52 +++++++++++++++++++++++++++++++++++++---------------
 2 files changed, 39 insertions(+), 16 deletions(-)

diff --git a/init/Android.mk b/init/Android.mk
index e982990..b23a4df 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -76,7 +76,8 @@ LOCAL_SRC_FILES:= \
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     system/extras/ext4_utils \
-    system/core/mkbootimg
+    system/core/mkbootimg \
+    external/zlib
 
 LOCAL_FORCE_STATIC_EXECUTABLE := true
 LOCAL_MODULE_PATH := $(TARGET_ROOT_OUT)
diff --git a/init/devices.cpp b/init/devices.cpp
index cc5e9e9..32e4124 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -48,6 +48,7 @@
 #include "ueventd_parser.h"
 #include "util.h"
 #include "log.h"
+#include <zlib.h>
 #include "property_service.h"
 
 #define SYSFS_PREFIX    "/sys"
@@ -771,23 +772,20 @@ static void handle_device_event(struct uevent *uevent)
     }
 }
 
-static int load_firmware(int fw_fd, int loading_fd, int data_fd)
+static int load_firmware(int fw_fd, gzFile gz_fd, int loading_fd, int data_fd)
 {
-    struct stat st;
-    long len_to_copy;
     int ret = 0;
 
-    if(fstat(fw_fd, &st) < 0)
-        return -1;
-    len_to_copy = st.st_size;
-
     write(loading_fd, "1", 1);  /* start transfer */
 
-    while (len_to_copy > 0) {
+    while (1) {
         char buf[PAGE_SIZE];
         ssize_t nr;
 
-        nr = read(fw_fd, buf, sizeof(buf));
+        if (gz_fd)
+            nr = gzread(gz_fd, buf, sizeof(buf));
+        else
+            nr = read(fw_fd, buf, sizeof(buf));
         if(!nr)
             break;
         if(nr < 0) {
@@ -798,13 +796,14 @@ static int load_firmware(int fw_fd, int loading_fd, int data_fd)
             ret = -1;
             break;
         }
-        len_to_copy -= nr;
     }
 
     if(!ret)
         write(loading_fd, "0", 1);  /* successful end of transfer */
-    else
+    else {
+        ERROR("%s: aborted transfer\n", __func__);
         write(loading_fd, "-1", 2); /* abort transfer */
+    }
 
     return ret;
 }
@@ -814,12 +813,29 @@ static int is_booting(void)
     return access("/dev/.booting", F_OK) == 0;
 }
 
+gzFile fw_gzopen(const char *fname, const char *mode)
+{
+    char *gzfile = NULL;
+    int l;
+    gzFile gz_fd = Z_NULL;
+
+    l = asprintf(&gzfile, "%s.gz", fname);
+    if (l == -1)
+        goto out;
+
+    gz_fd = gzopen(gzfile, mode);
+    free(gzfile);
+out:
+    return gz_fd;
+}
+
 static void process_firmware_event(struct uevent *uevent)
 {
     char *root, *loading, *data;
     int l, loading_fd, data_fd, fw_fd;
     size_t i;
     int booting = is_booting();
+    gzFile gz_fd = NULL;
 
     INFO("firmware: loading '%s' for '%s'\n",
          uevent->firmware, uevent->path);
@@ -852,15 +868,18 @@ try_loading_again:
             goto data_free_out;
         fw_fd = open(file, O_RDONLY|O_CLOEXEC);
         free(file);
-        if (fw_fd >= 0) {
-            if(!load_firmware(fw_fd, loading_fd, data_fd))
+        if (fw_fd < 0){
+            gz_fd = fw_gzopen(file, "rb");
+        }
+        if (fw_fd >= 0 || gz_fd) {
+            if(!load_firmware(fw_fd, gz_fd, loading_fd, data_fd))
                 INFO("firmware: copy success { '%s', '%s' }\n", root, uevent->firmware);
             else
                 INFO("firmware: copy failure { '%s', '%s' }\n", root, uevent->firmware);
             break;
         }
     }
-    if (fw_fd < 0) {
+    if ((fw_fd < 0) && !gz_fd) {
         if (booting) {
             /* If we're not fully booted, we may be missing
              * filesystems needed for firmware, wait and retry.
@@ -874,7 +893,10 @@ try_loading_again:
         goto data_close_out;
     }
 
-    close(fw_fd);
+    if (gz_fd)
+        gzclose(gz_fd);
+    else
+        close(fw_fd);
 data_close_out:
     close(data_fd);
 loading_close_out:
-- 
2.7.4


From fa922c59b4ab25385c7c02116d5cbf2acdab754f Mon Sep 17 00:00:00 2001
From: Biswajit Paul <biswajitpaul@codeaurora.org>
Date: Thu, 2 Oct 2014 18:40:35 -0700
Subject: [PATCH 14/30] ueventd: Add bootdevice links support for selinux

Adding bootdevice support to define context on common symlink.

Change-Id: I25d7239614539d1ef2c9920e2c321824ee2c664b
---
 init/devices.cpp | 14 ++++++++++++--
 1 file changed, 12 insertions(+), 2 deletions(-)

diff --git a/init/devices.cpp b/init/devices.cpp
index 32e4124..640db9e 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -503,10 +503,10 @@ static char **get_block_device_symlinks(struct uevent *uevent)
         return NULL;
     }
 
-    char **links = (char**) malloc(sizeof(char *) * 4);
+    char **links = (char**) malloc(sizeof(char *) * 6);
     if (!links)
         return NULL;
-    memset(links, 0, sizeof(char *) * 4);
+    memset(links, 0, sizeof(char *) * 6);
 
     INFO("found %s device %s\n", type, device);
 
@@ -521,6 +521,11 @@ static char **get_block_device_symlinks(struct uevent *uevent)
             link_num++;
         else
             links[link_num] = NULL;
+        if (asprintf(&links[link_num], "/dev/block/bootdevice/by-name/%s", p) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+
         free(p);
     }
 
@@ -529,6 +534,11 @@ static char **get_block_device_symlinks(struct uevent *uevent)
             link_num++;
         else
             links[link_num] = NULL;
+
+        if (asprintf(&links[link_num], "/dev/block/bootdevice/by-num/p%d", uevent->partition_num) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
     }
 
     slash = strrchr(uevent->path, '/');
-- 
2.7.4


From 2729b054e0908dee874c65b700426e3e40cfaf26 Mon Sep 17 00:00:00 2001
From: David Ng <dave@codeaurora.org>
Date: Fri, 21 Nov 2014 18:01:08 -0800
Subject: [PATCH 15/30] ueventd: Fix bootdevice by-name/by-num link creation

Create bootdevice by-name/by-num links only if the block
device is the bootdevice.  This fixes the issue of
bootdevice path being created incorrectly if the first
reported device with by-name/by-num is not the bootdevice.

It also fixes devices in which the bootdevice property
doesn't exist, or the symlink is created by a later step in
the init sequence (such as init.rc itself)

Change-Id: Ifb68080e3149917f9ee88a4a421007f29e8d83d2
---
 init/devices.cpp | 60 ++++++++++++++++++++++++++++++++++++++++++++------------
 1 file changed, 47 insertions(+), 13 deletions(-)

diff --git a/init/devices.cpp b/init/devices.cpp
index 640db9e..688e5ea 100644
--- a/init/devices.cpp
+++ b/init/devices.cpp
@@ -491,6 +491,11 @@ static char **get_block_device_symlinks(struct uevent *uevent)
     char link_path[256];
     int link_num = 0;
     char *p;
+    int is_bootdevice = -1;
+    int mtd_fd = -1;
+    int nr;
+    char mtd_name_path[256];
+    char mtd_name[64];
 
     pdev = find_platform_device(uevent->path);
     if (pdev) {
@@ -512,6 +517,36 @@ static char **get_block_device_symlinks(struct uevent *uevent)
 
     snprintf(link_path, sizeof(link_path), "/dev/block/%s/%s", type, device);
 
+    if(!strcmp(type, "mtd")) {
+        snprintf(mtd_name_path, sizeof(mtd_name_path),
+            "/sys/devices/virtual/%s/%s/name", type, device);
+        mtd_fd = open(mtd_name_path, O_RDONLY);
+            if(mtd_fd < 0) {
+                ERROR("Unable to open %s for reading", mtd_name_path);
+                return NULL;
+            }
+        nr = read(mtd_fd, mtd_name, sizeof(mtd_name) - 1);
+        if (nr <= 0)
+            return NULL;
+        close(mtd_fd);
+        mtd_name[nr - 1] = '\0';
+
+        p = strdup(mtd_name);
+        sanitize(p);
+        if (asprintf(&links[link_num], "/dev/block/%s/by-name/%s", type, p) > 0)
+            link_num++;
+        else
+            links[link_num] = NULL;
+        free(p);
+    }
+
+    if (pdev && boot_device.c_str()[0] != '\0' && strstr(device, boot_device.c_str())) {
+        make_link_init(link_path, "/dev/block/bootdevice");
+        is_bootdevice = 1;
+    } else {
+        is_bootdevice = 0;
+    }
+
     if (uevent->partition_name) {
         p = strdup(uevent->partition_name);
         sanitize(p);
@@ -521,11 +556,13 @@ static char **get_block_device_symlinks(struct uevent *uevent)
             link_num++;
         else
             links[link_num] = NULL;
-        if (asprintf(&links[link_num], "/dev/block/bootdevice/by-name/%s", p) > 0)
-            link_num++;
-        else
-            links[link_num] = NULL;
 
+        if (is_bootdevice > 0) {
+            if (asprintf(&links[link_num], "/dev/block/bootdevice/by-name/%s", p) > 0)
+                link_num++;
+            else
+                links[link_num] = NULL;
+        }
         free(p);
     }
 
@@ -535,10 +572,12 @@ static char **get_block_device_symlinks(struct uevent *uevent)
         else
             links[link_num] = NULL;
 
-        if (asprintf(&links[link_num], "/dev/block/bootdevice/by-num/p%d", uevent->partition_num) > 0)
-            link_num++;
-        else
-            links[link_num] = NULL;
+        if (is_bootdevice > 0) {
+            if (asprintf(&links[link_num], "/dev/block/bootdevice/by-num/p%d", uevent->partition_num) > 0)
+                link_num++;
+            else
+                links[link_num] = NULL;
+        }
     }
 
     slash = strrchr(uevent->path, '/');
@@ -547,11 +586,6 @@ static char **get_block_device_symlinks(struct uevent *uevent)
     else
         links[link_num] = NULL;
 
-    if (pdev && !boot_device.empty() && strstr(device, boot_device.c_str())) {
-        /* Create bootdevice symlink for platform boot stroage device */
-        make_link_init(link_path, "/dev/block/bootdevice");
-    }
-
     return links;
 }
 
-- 
2.7.4


From 5f51ef7328c5f273572e33b48af788c0ebf31d0f Mon Sep 17 00:00:00 2001
From: DodoGTA GT <aidas957@gmail.com>
Date: Sun, 16 Oct 2016 08:08:31 +0300
Subject: [PATCH 16/30] init: Add support for kernels that don't have
 finit_module

Some kernels don't have finit_module, which makes booting Android 7.0
impossible if people can't backport it themselves, so set
KERNEL_HAS_FINIT_MODULE := false in BoardConfig.mk file to
allow booting 7.0 even when the kernel doesn't have finit_
module :)

Change-Id: Iec63c1846cdc5e5bb3b61610ea438cf8eff8635b
---
 init/Android.mk   |  4 ++++
 init/builtins.cpp | 16 ++++++++++++++++
 2 files changed, 20 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index b23a4df..592c14d 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -73,6 +73,10 @@ LOCAL_SRC_FILES:= \
     vendor_init.cpp \
     watchdogd.cpp \
 
+ifeq ($(KERNEL_HAS_FINIT_MODULE), false)
+LOCAL_CFLAGS += -DNO_FINIT_MODULE
+endif
+
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     system/extras/ext4_utils \
diff --git a/init/builtins.cpp b/init/builtins.cpp
index 1061fef..0ca537e 100644
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -29,7 +29,9 @@
 #include <sys/socket.h>
 #include <sys/mount.h>
 #include <sys/resource.h>
+#ifndef NO_FINIT_MODULE
 #include <sys/syscall.h>
+#endif
 #include <sys/time.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -69,20 +71,34 @@ using android::base::StringPrintf;
 #define UNMOUNT_CHECK_MS 5000
 #define UNMOUNT_CHECK_TIMES 10
 
+#ifdef NO_FINIT_MODULE
+// System call provided by bionic but not in any header file.
+extern "C" int init_module(void *, unsigned long, const char *);
+#endif
+
 static const int kTerminateServiceDelayMicroSeconds = 50000;
 
 static int insmod(const char *filename, const char *options) {
+#ifndef NO_FINIT_MODULE
     int fd = open(filename, O_RDONLY | O_NOFOLLOW | O_CLOEXEC);
     if (fd == -1) {
         ERROR("insmod: open(\"%s\") failed: %s", filename, strerror(errno));
+#else
+    std::string module;
+    if (!read_file(filename, &module)) {
+#endif
         return -1;
     }
+#ifndef NO_FINIT_MODULE
     int rc = syscall(__NR_finit_module, fd, options, 0);
     if (rc == -1) {
         ERROR("finit_module for \"%s\" failed: %s", filename, strerror(errno));
     }
     close(fd);
     return rc;
+#else
+    return init_module(&module[0], module.size(), options);
+#endif
 }
 
 static int __ifupdown(const char *interface, int up) {
-- 
2.7.4


From 1da336017f6e3a628de65a4bce5df2a46c3f166e Mon Sep 17 00:00:00 2001
From: sooorajjj <sooraj.sizon@micromaxinfo.com>
Date: Sun, 29 Jan 2017 04:08:11 +0530
Subject: [PATCH 17/30] Revert "fs_mgr: Skip filesystem check unless fs_type
 matches"

This reverts commit 35f81e3bf870cdf9b7ce2a2a7901030a50f41230.
---
 fs_mgr/Android.mk |  8 ++------
 fs_mgr/fs_mgr.c   | 15 ++-------------
 init/Android.mk   |  5 +----
 3 files changed, 5 insertions(+), 23 deletions(-)

diff --git a/fs_mgr/Android.mk b/fs_mgr/Android.mk
index 4cb409a..28fff3f 100644
--- a/fs_mgr/Android.mk
+++ b/fs_mgr/Android.mk
@@ -10,8 +10,7 @@ common_static_libraries := \
     libmincrypt \
     libcrypto_static \
     libext4_utils_static \
-    libsquashfs_utils \
-    libext2_blkid
+    libsquashfs_utils
 
 include $(CLEAR_VARS)
 LOCAL_CLANG := true
@@ -27,10 +26,7 @@ LOCAL_C_INCLUDES := \
     system/vold \
     system/extras/ext4_utils \
     external/openssl/include \
-    bootable/recovery \
-    system/extras/ext4_utils \
-    system/extras/squashfs_utils \
-    external/e2fsprogs/lib
+    bootable/recovery
 LOCAL_MODULE:= libfs_mgr
 LOCAL_STATIC_LIBRARIES := $(common_static_libraries)
 LOCAL_EXPORT_C_INCLUDE_DIRS := $(LOCAL_PATH)/include
diff --git a/fs_mgr/fs_mgr.c b/fs_mgr/fs_mgr.c
index 2add5df..387f708 100644
--- a/fs_mgr/fs_mgr.c
+++ b/fs_mgr/fs_mgr.c
@@ -39,7 +39,6 @@
 #include <cutils/partition_utils.h>
 #include <cutils/properties.h>
 #include <logwrap/logwrap.h>
-#include <blkid/blkid.h>
 
 #include "mincrypt/rsa.h"
 #include "mincrypt/sha.h"
@@ -310,8 +309,6 @@ static int mount_with_alternatives(struct fstab *fstab, int start_idx, int *end_
     int i;
     int mount_errno = 0;
     int mounted = 0;
-    int cmp_len;
-    char *detected_fs_type;
 
     if (!end_idx || !attempted_idx || start_idx >= fstab->num_entries) {
       errno = EINVAL;
@@ -337,16 +334,8 @@ static int mount_with_alternatives(struct fstab *fstab, int start_idx, int *end_
             }
 
             if (fstab->recs[i].fs_mgr_flags & MF_CHECK) {
-                /* Skip file system check unless we are sure we are the right type */
-                detected_fs_type = blkid_get_tag_value(NULL, "TYPE", fstab->recs[i].blk_device);
-                if (detected_fs_type) {
-                    cmp_len = (!strncmp(detected_fs_type, "ext", 3) &&
-                            strlen(detected_fs_type) == 4) ? 3 : strlen(detected_fs_type);
-                    if (!strncmp(fstab->recs[i].fs_type, detected_fs_type, cmp_len)) {
-                        check_fs(fstab->recs[i].blk_device, fstab->recs[i].fs_type,
-                                 fstab->recs[i].mount_point);
-                    }
-                }
+                check_fs(fstab->recs[i].blk_device, fstab->recs[i].fs_type,
+                         fstab->recs[i].mount_point);
             }
             if (!__mount(fstab->recs[i].blk_device, fstab->recs[i].mount_point, &fstab->recs[i])) {
                 *attempted_idx = i;
diff --git a/init/Android.mk b/init/Android.mk
index 592c14d..0c11ebd 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -107,10 +107,7 @@ LOCAL_STATIC_LIBRARIES := \
     libc++_static \
     libdl \
     libsparse_static \
-    libz \
-    libext2_blkid \
-    libext2_uuid_static
-
+    libz
 
 # Create symlinks
 LOCAL_POST_INSTALL_CMD := $(hide) mkdir -p $(TARGET_ROOT_OUT)/sbin; \
-- 
2.7.4


From 0825e6aa672cc7ddba787eb4ccd93711dd10c9b8 Mon Sep 17 00:00:00 2001
From: Fenglin Wu <fenglinw@codeaurora.org>
Date: Fri, 12 Sep 2014 11:07:28 +0800
Subject: [PATCH 18/30] healthd: charger: Draw battery capacity in charging
 animation

Draw a text to show the battery capacity value in charging animation.

PS3:
draw it right below the battery symbol

Change-Id: I0117fb0aee69181ce0d608ba4b1644fa42cd1a0d
---
 healthd/healthd_mode_charger.cpp | 30 ++++++++++++++++++++++++++++--
 1 file changed, 28 insertions(+), 2 deletions(-)

diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
index a6da704..9fed0b3 100644
--- a/healthd/healthd_mode_charger.cpp
+++ b/healthd/healthd_mode_charger.cpp
@@ -316,6 +316,30 @@ static void draw_battery(struct charger *charger)
     }
 }
 
+#define STR_LEN    64
+static void draw_capacity(struct charger *charger)
+{
+    char cap_str[STR_LEN];
+    int x, y;
+    int str_len_px;
+    int batt_height = 0;
+    // get height of battery image to draw text below
+    struct animation *batt_anim = charger->batt_anim;
+    struct frame *frame = &batt_anim->frames[batt_anim->cur_frame];
+    if (batt_anim->num_frames != 0) {
+        // nothing else should happen actually
+        batt_height = gr_get_height(frame->surface);
+    }
+
+    snprintf(cap_str, (STR_LEN - 1), "%d%%", charger->batt_anim->capacity);
+    str_len_px = gr_measure(cap_str);
+    x = (gr_fb_width() - str_len_px) / 2;
+    // draw it below the battery image
+    y = (gr_fb_height() + batt_height) / 2 + char_height * 2;
+    android_green();
+    gr_text(x, y, cap_str, 0);
+}
+
 static void redraw_screen(struct charger *charger)
 {
     struct animation *batt_anim = charger->batt_anim;
@@ -323,10 +347,12 @@ static void redraw_screen(struct charger *charger)
     clear_screen();
 
     /* try to display *something* */
-    if (batt_anim->capacity < 0 || batt_anim->num_frames == 0)
+    if (batt_anim->capacity < 0 || batt_anim->num_frames == 0) {
         draw_unknown(charger);
-    else
+    } else {
         draw_battery(charger);
+        draw_capacity(charger);
+    }
     gr_flip();
 }
 
-- 
2.7.4


From a09197d70b4e348b7e3f393079bbd5ece0b36049 Mon Sep 17 00:00:00 2001
From: Fenglin Wu <fenglinw@codeaurora.org>
Date: Wed, 10 Sep 2014 18:15:56 +0800
Subject: [PATCH 19/30] healthd: charger: Turn off charging animation by power
 key event

Currently, the charging animation can be turned on by power key event. Add
support to make charging animation can be turned off by power key event.

Change-Id: Icc8101ae3d4fd777efedeff10ca535a9e6e7a57d
---
 healthd/healthd_mode_charger.cpp | 15 ++++++++++++++-
 1 file changed, 14 insertions(+), 1 deletion(-)

diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
index 9fed0b3..1a60bce 100644
--- a/healthd/healthd_mode_charger.cpp
+++ b/healthd/healthd_mode_charger.cpp
@@ -534,6 +534,7 @@ static void set_next_key_check(struct charger *charger,
 
 static void process_key(struct charger *charger, int code, int64_t now)
 {
+    struct animation *batt_anim = charger->batt_anim;
     struct key_state *key = &charger->keys[code];
 
     if (code == KEY_POWER) {
@@ -570,7 +571,19 @@ static void process_key(struct charger *charger, int code, int64_t now)
         } else {
             /* if the power key got released, force screen state cycle */
             if (key->pending) {
-                kick_animation(charger->batt_anim);
+                if (!batt_anim->run) {
+                    request_suspend(false);
+                    kick_animation(batt_anim);
+                } else {
+                    reset_animation(batt_anim);
+                    charger->next_screen_transition = -1;
+                    #ifdef HEALTHD_FORCE_BACKLIGHT_CONTROL
+                            set_backlight(false);
+                    #endif
+                    gr_fb_blank(true);
+                    if (charger->charger_connected)
+                        request_suspend(true);
+                }
             }
         }
     }
-- 
2.7.4


From b3aab9bf84ec474b31f44c7a065e3c85bc89ebcf Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Mon, 30 Nov 2015 23:51:37 +0100
Subject: [PATCH 20/30] healthd: fix power key handling

AOSP changes where incompatible with our enhancements
and kills power key handling to turn screen on/off
Revert power key handling to previous version

Change-Id: Ibf3fe6009cbb3880a1660bd5ea97a03a878c919e
---
 healthd/healthd_mode_charger.cpp | 22 ++++++++++------------
 1 file changed, 10 insertions(+), 12 deletions(-)

diff --git a/healthd/healthd_mode_charger.cpp b/healthd/healthd_mode_charger.cpp
index 1a60bce..2c621c6 100644
--- a/healthd/healthd_mode_charger.cpp
+++ b/healthd/healthd_mode_charger.cpp
@@ -561,25 +561,23 @@ static void process_key(struct charger *charger, int code, int64_t now)
                  * make sure we wake up at the right-ish time to check
                  */
                 set_next_key_check(charger, key, POWER_ON_KEY_TIME);
-
-               /* Turn on the display and kick animation on power-key press
-                * rather than on key release
-                */
-                kick_animation(charger->batt_anim);
-                request_suspend(false);
             }
         } else {
-            /* if the power key got released, force screen state cycle */
             if (key->pending) {
-                if (!batt_anim->run) {
-                    request_suspend(false);
+                /* If key is pressed when the animation is not running, kick
+                 * the animation and quite suspend; If key is pressed when
+                 * the animation is running, turn off the animation and request
+                 * suspend.
+                 */
+                if (!charger->batt_anim->run) {
                     kick_animation(batt_anim);
+                    request_suspend(false);
                 } else {
                     reset_animation(batt_anim);
                     charger->next_screen_transition = -1;
-                    #ifdef HEALTHD_FORCE_BACKLIGHT_CONTROL
-                            set_backlight(false);
-                    #endif
+#ifdef HEALTHD_FORCE_BACKLIGHT_CONTROL
+                    set_backlight(false);
+#endif
                     gr_fb_blank(true);
                     if (charger->charger_connected)
                         request_suspend(true);
-- 
2.7.4


From ecb59b6d54e50813ee9a43ebf96aa8f6d2855269 Mon Sep 17 00:00:00 2001
From: Ramakrishnan Ganesh <ramakris@codeaurora.org>
Date: Fri, 15 Nov 2013 16:40:49 -0800
Subject: [PATCH 21/30] healthd: Reinitialize mChargerNames for every battery
 update

Booting up the device without usb, the kernel sets the usb power supply
type as UNKNOWN. The type of usb power supply changes at run-time as
various chargers are plugged in/out. However, healthd initilizes the
charger list only at bootup. Change it such that it checks for charger
type changes with every battery or usb uevent.

While at it, the kernel may have a power supply type which is not known
to healthd. This is perfectly fine. Update healthd to not print a
warning.

Change-Id: I2ec9f9a420ca61814d43c316b418ce94de3691bc
---
 healthd/BatteryMonitor.cpp | 109 ++++++++++++++++++++++++++-------------------
 1 file changed, 62 insertions(+), 47 deletions(-)

diff --git a/healthd/BatteryMonitor.cpp b/healthd/BatteryMonitor.cpp
index 54d45e6..6841e20 100644
--- a/healthd/BatteryMonitor.cpp
+++ b/healthd/BatteryMonitor.cpp
@@ -260,57 +260,72 @@ bool BatteryMonitor::update(void) {
     if (readFromFile(mHealthdConfig->batteryTechnologyPath, buf, SIZE) > 0)
         props.batteryTechnology = String8(buf);
 
-    unsigned int i;
-    double MaxPower = 0;
-
-    for (i = 0; i < mChargerNames.size(); i++) {
-        String8 path;
-        path.appendFormat("%s/%s/online", POWER_SUPPLY_SYSFS_PATH,
-                          mChargerNames[i].string());
+    // reinitialize the mChargerNames vector everytime there is an update
+    String8 path;
+    DIR* dir = opendir(POWER_SUPPLY_SYSFS_PATH);
+    if (dir == NULL) {
+        KLOG_ERROR(LOG_TAG, "Could not open %s\n", POWER_SUPPLY_SYSFS_PATH);
+    } else {
+        struct dirent* entry;
+        // reconstruct the charger strings
+        mChargerNames.clear();
+        while ((entry = readdir(dir))) {
+            const char* name = entry->d_name;
 
-        if (readFromFile(path, buf, SIZE) > 0) {
-            if (buf[0] != '0') {
-                path.clear();
-                path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH,
-                                  mChargerNames[i].string());
-                switch(readPowerSupplyType(path)) {
-                case ANDROID_POWER_SUPPLY_TYPE_AC:
-                    props.chargerAcOnline = true;
-                    break;
-                case ANDROID_POWER_SUPPLY_TYPE_USB:
-                    props.chargerUsbOnline = true;
-                    break;
-                case ANDROID_POWER_SUPPLY_TYPE_WIRELESS:
-                    props.chargerWirelessOnline = true;
-                    break;
-                default:
-                    KLOG_WARNING(LOG_TAG, "%s: Unknown power supply type\n",
-                                 mChargerNames[i].string());
-                }
-                path.clear();
-                path.appendFormat("%s/%s/current_max", POWER_SUPPLY_SYSFS_PATH,
-                                  mChargerNames[i].string());
-                int ChargingCurrent =
-                    (access(path.string(), R_OK) == 0) ? getIntField(path) : 0;
+            if (!strcmp(name, ".") || !strcmp(name, ".."))
+                continue;
 
+            // Look for "type" file in each subdirectory
+            path.clear();
+            path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH, name);
+            switch(readPowerSupplyType(path)) {
+            case ANDROID_POWER_SUPPLY_TYPE_AC:
+            case ANDROID_POWER_SUPPLY_TYPE_USB:
+            case ANDROID_POWER_SUPPLY_TYPE_WIRELESS:
                 path.clear();
-                path.appendFormat("%s/%s/voltage_max", POWER_SUPPLY_SYSFS_PATH,
-                                  mChargerNames[i].string());
-
-                int ChargingVoltage =
-                    (access(path.string(), R_OK) == 0) ? getIntField(path) :
-                    DEFAULT_VBUS_VOLTAGE;
-
-                double power = ((double)ChargingCurrent / MILLION) *
-                        ((double)ChargingVoltage / MILLION);
-                if (MaxPower < power) {
-                    props.maxChargingCurrent = ChargingCurrent;
-                    props.maxChargingVoltage = ChargingVoltage;
-                    MaxPower = power;
+                path.appendFormat("%s/%s/online", POWER_SUPPLY_SYSFS_PATH, name);
+                if (access(path.string(), R_OK) == 0) {
+                    mChargerNames.add(String8(name));
+                    if (readFromFile(path, buf, SIZE) > 0) {
+                        if (buf[0] != '0') {
+                            path.clear();
+                            path.appendFormat("%s/%s/type", POWER_SUPPLY_SYSFS_PATH,
+                                              name);
+                            switch(readPowerSupplyType(path)) {
+                            case ANDROID_POWER_SUPPLY_TYPE_AC:
+                                props.chargerAcOnline = true;
+                                break;
+                            case ANDROID_POWER_SUPPLY_TYPE_USB:
+                                props.chargerUsbOnline = true;
+                                break;
+                            case ANDROID_POWER_SUPPLY_TYPE_WIRELESS:
+                                props.chargerWirelessOnline = true;
+                                break;
+                            default:
+                                KLOG_WARNING(LOG_TAG, "%s: Unknown power supply type\n",
+                                             name);
+                            }
+                            path.clear();
+                            path.appendFormat("%s/%s/current_max", POWER_SUPPLY_SYSFS_PATH,
+                                              name);
+                            if (access(path.string(), R_OK) == 0) {
+                                int maxChargingCurrent = getIntField(path);
+                                if (props.maxChargingCurrent < maxChargingCurrent) {
+                                    props.maxChargingCurrent = maxChargingCurrent;
+                                }
+                            }
+                        }
+                    }
                 }
-            }
-        }
-    }
+                break;
+            case ANDROID_POWER_SUPPLY_TYPE_BATTERY:
+                break;
+            default:
+                break;
+            } //switch
+        } //while
+        closedir(dir);
+    }//else
 
     logthis = !healthd_board_battery_update(&props);
 
-- 
2.7.4


From 31f0900ca4331c398d7b8d84e5cba8c3f86e2a9f Mon Sep 17 00:00:00 2001
From: Shuzhen Wang <shuzhenw@codeaurora.org>
Date: Wed, 24 Jun 2015 22:38:25 -0700
Subject: [PATCH 22/30] Camera: Add feature extensions

This change includes below commits:

    Camera bringup changes system-core
    Change-Id: I1cf98641eca9096bd27645e07ea802646ea1fb96

    system/core: Fix for HAL compilation issues while integrating HAL 1.0
    Change-Id: Iead9c1ade279b64c5cbdf4d2de1a8b695939c52a

    Camera: Add enum to specify the frame type
    Added enum to specify the frame type of either fd/data buffer
    CRs-fixed: 654901
    Change-Id: I1c0b1a2c6a1425cdb6650cdfc20ca65835a1b81f

Change-Id: I654a40661e6e101da2a06986abeceb20639cccd9
---
 include/system/camera.h | 64 +++++++++++++++++++++++++++++++++++++++++++++++--
 1 file changed, 62 insertions(+), 2 deletions(-)

diff --git a/include/system/camera.h b/include/system/camera.h
index 5d0873a..121a93f 100644
--- a/include/system/camera.h
+++ b/include/system/camera.h
@@ -88,9 +88,24 @@ enum {
     // Notify on autofocus start and stop. This is useful in continuous
     // autofocus - FOCUS_MODE_CONTINUOUS_VIDEO and FOCUS_MODE_CONTINUOUS_PICTURE.
     CAMERA_MSG_FOCUS_MOVE = 0x0800,       // notifyCallback
+#ifdef QCOM_HARDWARE
+    CAMERA_MSG_VENDOR_START = 0x1000,
+    CAMERA_MSG_STATS_DATA = CAMERA_MSG_VENDOR_START,
+    CAMERA_MSG_META_DATA = 0x2000,
+    CAMERA_MSG_VENDOR_END = 0x8000,
+#endif
     CAMERA_MSG_ALL_MSGS = 0xFFFF
 };
 
+#ifdef QCOM_HARDWARE
+/** meta data type in CameraMetaDataCallback */
+enum {
+    CAMERA_META_DATA_ASD = 0x001,    //ASD data
+    CAMERA_META_DATA_FD = 0x002,     //FD/FP data
+    CAMERA_META_DATA_HDR = 0x003,    //Auto HDR data
+};
+#endif
+
 /** cmdType in sendCommand functions */
 enum {
     CAMERA_CMD_START_SMOOTH_ZOOM = 1,
@@ -189,7 +204,27 @@ enum {
      * IMPLEMENTATION_DEFINED, then HALv3 devices will use gralloc usage flags
      * of SW_READ_OFTEN.
      */
-    CAMERA_CMD_SET_VIDEO_FORMAT = 11
+    CAMERA_CMD_SET_VIDEO_FORMAT = 11,
+
+#ifdef QCOM_HARDWARE
+    CAMERA_CMD_VENDOR_START = 20,
+    /**
+     * Commands to enable/disable preview histogram
+     *
+     * Based on user's input to enable/disable histogram from the camera
+     * UI, send the appropriate command to the HAL to turn on/off the histogram
+     * stats and start sending the data to the application.
+     */
+    CAMERA_CMD_HISTOGRAM_ON = CAMERA_CMD_VENDOR_START,
+    CAMERA_CMD_HISTOGRAM_OFF = CAMERA_CMD_VENDOR_START + 1,
+    CAMERA_CMD_HISTOGRAM_SEND_DATA  = CAMERA_CMD_VENDOR_START + 2,
+    CAMERA_CMD_LONGSHOT_ON = CAMERA_CMD_VENDOR_START + 3,
+    CAMERA_CMD_LONGSHOT_OFF = CAMERA_CMD_VENDOR_START + 4,
+    CAMERA_CMD_STOP_LONGSHOT = CAMERA_CMD_VENDOR_START + 5,
+    CAMERA_CMD_VENDOR_END = 200,
+#endif
+    CAMERA_CMD_METADATA_ON = 100,
+    CAMERA_CMD_METADATA_OFF = 101
 };
 
 /** camera fatal errors */
@@ -275,9 +310,34 @@ typedef struct camera_face {
      * -2000, -2000 if this is not supported.
      */
     int32_t mouth[2];
-
+#ifdef QCOM_HARDWARE
+    int32_t smile_degree;
+    int32_t smile_score;
+    int32_t blink_detected;
+    int32_t face_recognised;
+    int32_t gaze_angle;
+    int32_t updown_dir;
+    int32_t leftright_dir;
+    int32_t roll_dir;
+    int32_t left_right_gaze;
+    int32_t top_bottom_gaze;
+    int32_t leye_blink;
+    int32_t reye_blink;
+#endif
 } camera_face_t;
 
+#ifdef QCOM_HARDWARE
+/**
+ * The information of a data type received in a camera frame.
+ */
+typedef enum {
+    /** Data buffer */
+    CAMERA_FRAME_DATA_BUF = 0x000,
+    /** File descriptor */
+    CAMERA_FRAME_DATA_FD = 0x100
+} camera_frame_data_type_t;
+#endif
+
 /**
  * The metadata of the frame data.
  */
-- 
2.7.4


From 6454e07f321575e76237f19b1c4a80abd73acfc6 Mon Sep 17 00:00:00 2001
From: "Christopher R. Palmer" <crpalmer@gmail.com>
Date: Wed, 22 Jul 2015 06:00:38 -0400
Subject: [PATCH 23/30] init: Allow devices to use user-space tools to set
 ro.serialno

CUrrently, init will always set a ro.serialno value which means
that the kernel is the only option for configuring the serial
number.

The zenfone2 stores the serial number in a file-system that
is mounted during the boot process and provides tools that pull
the factory configuration from there.

To support this, we need to allow init to opt-out of setting
the serial number for us.

Change-Id: I9c307d91bb8d3cb1c881213dd28e4f76e6eae14f
---
 init/Android.mk | 4 ++++
 init/init.cpp   | 2 ++
 2 files changed, 6 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index 0c11ebd..7c8c45e 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -77,6 +77,10 @@ ifeq ($(KERNEL_HAS_FINIT_MODULE), false)
 LOCAL_CFLAGS += -DNO_FINIT_MODULE
 endif
 
+ifneq ($(TARGET_IGNORE_RO_BOOT_SERIALNO),)
+LOCAL_CFLAGS += -DIGNORE_RO_BOOT_SERIALNO
+endif
+
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     system/extras/ext4_utils \
diff --git a/init/init.cpp b/init/init.cpp
index 9d0c3e0..5a23281 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -427,7 +427,9 @@ static void export_kernel_boot_props() {
         const char *dst_prop;
         const char *default_value;
     } prop_map[] = {
+#ifndef IGNORE_RO_BOOT_SERIALNO
         { "ro.boot.serialno",   "ro.serialno",   "", },
+#endif
         { "ro.boot.mode",       "ro.bootmode",   "unknown", },
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
-- 
2.7.4


From 78438c13469ca74b6bb9c2506a62a1e0e77a2ac8 Mon Sep 17 00:00:00 2001
From: "Christopher N. Hesse" <raymanfx@gmail.com>
Date: Sun, 29 Nov 2015 01:08:40 +0100
Subject: [PATCH 24/30] init: Allow targets to ignore the ro.revision property

Change-Id: I789879cde2797474b9303fd5bbf10d4760e6b822
---
 init/Android.mk | 4 ++++
 init/init.cpp   | 2 ++
 2 files changed, 6 insertions(+)

diff --git a/init/Android.mk b/init/Android.mk
index 7c8c45e..93ae643 100644
--- a/init/Android.mk
+++ b/init/Android.mk
@@ -81,6 +81,10 @@ ifneq ($(TARGET_IGNORE_RO_BOOT_SERIALNO),)
 LOCAL_CFLAGS += -DIGNORE_RO_BOOT_SERIALNO
 endif
 
+ifneq ($(TARGET_IGNORE_RO_BOOT_REVISION),)
+LOCAL_CFLAGS += -DIGNORE_RO_BOOT_REVISION
+endif
+
 LOCAL_MODULE:= init
 LOCAL_C_INCLUDES += \
     system/extras/ext4_utils \
diff --git a/init/init.cpp b/init/init.cpp
index 5a23281..fe64486 100644
--- a/init/init.cpp
+++ b/init/init.cpp
@@ -434,7 +434,9 @@ static void export_kernel_boot_props() {
         { "ro.boot.baseband",   "ro.baseband",   "unknown", },
         { "ro.boot.bootloader", "ro.bootloader", "unknown", },
         { "ro.boot.hardware",   "ro.hardware",   "unknown", },
+#ifndef IGNORE_RO_BOOT_REVISION
         { "ro.boot.revision",   "ro.revision",   "0", },
+#endif
     };
     for (size_t i = 0; i < ARRAY_SIZE(prop_map); i++) {
         std::string value = property_get(prop_map[i].src_prop);
-- 
2.7.4


From 60d91a4919a9ef7022276a0f63c0aa6f947c57b4 Mon Sep 17 00:00:00 2001
From: "Christopher R. Palmer" <crpalmer@gmail.com>
Date: Sat, 12 Mar 2016 06:08:16 -0500
Subject: [PATCH 25/30] init: Add property_get_bool

Change-Id: I2bef1862f6126f79c64faa7080a00096e4f955c5
---
 init/property_service.cpp | 27 +++++++++++++++++++++++++++
 init/property_service.h   |  1 +
 2 files changed, 28 insertions(+)

diff --git a/init/property_service.cpp b/init/property_service.cpp
index 8a0d69d..a60d2ed 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -120,6 +120,33 @@ std::string property_get(const char* name) {
     return value;
 }
 
+bool property_get_bool(const char *key, bool default_value) {
+    if (!key) {
+        return default_value;
+    }
+
+    bool result = default_value;
+    char buf[PROP_VALUE_MAX] = {'\0',};
+
+    int len = __property_get(key, buf);
+    if (len == 1) {
+        char ch = buf[0];
+        if (ch == '0' || ch == 'n') {
+            result = false;
+        } else if (ch == '1' || ch == 'y') {
+            result = true;
+        }
+    } else if (len > 1) {
+         if (!strcmp(buf, "no") || !strcmp(buf, "false") || !strcmp(buf, "off")) {
+            result = false;
+        } else if (!strcmp(buf, "yes") || !strcmp(buf, "true") || !strcmp(buf, "on")) {
+            result = true;
+        }
+    }
+
+    return result;
+}
+
 static void write_persistent_property(const char *name, const char *value)
 {
     char tempPath[PATH_MAX];
diff --git a/init/property_service.h b/init/property_service.h
index dbaed34..aa92fa5 100644
--- a/init/property_service.h
+++ b/init/property_service.h
@@ -34,6 +34,7 @@ extern void load_system_props(void);
 extern void start_property_service(void);
 std::string property_get(const char* name);
 extern int property_set(const char *name, const char *value);
+extern bool property_get_bool(const char *name, bool def_value);
 
 
 #endif  /* _INIT_PROPERTY_H */
-- 
2.7.4


From f29254a2d5e1ac0f406f10bab389b4e332ff2cfa Mon Sep 17 00:00:00 2001
From: Luca Stefani <luca.stefani.ge1@gmail.com>
Date: Fri, 26 Aug 2016 00:28:51 +0200
Subject: [PATCH 26/30] init: Move property_get_bool to c++

Change-Id: I6da69584e0dd72825956d457162030a2d81abe2f
---
 init/property_service.cpp | 30 ++++++++++++++----------------
 1 file changed, 14 insertions(+), 16 deletions(-)

diff --git a/init/property_service.cpp b/init/property_service.cpp
index a60d2ed..6010b8e 100644
--- a/init/property_service.cpp
+++ b/init/property_service.cpp
@@ -126,22 +126,20 @@ bool property_get_bool(const char *key, bool default_value) {
     }
 
     bool result = default_value;
-    char buf[PROP_VALUE_MAX] = {'\0',};
-
-    int len = __property_get(key, buf);
-    if (len == 1) {
-        char ch = buf[0];
-        if (ch == '0' || ch == 'n') {
-            result = false;
-        } else if (ch == '1' || ch == 'y') {
-            result = true;
-        }
-    } else if (len > 1) {
-         if (!strcmp(buf, "no") || !strcmp(buf, "false") || !strcmp(buf, "off")) {
-            result = false;
-        } else if (!strcmp(buf, "yes") || !strcmp(buf, "true") || !strcmp(buf, "on")) {
-            result = true;
-        }
+
+    std::string string_value = property_get(key);
+    if ((string_value == "0")
+            || (string_value == "n")
+            || (string_value == "no")
+            || (string_value == "false")
+            || (string_value == "off")) {
+        result = false;
+    } else if ((string_value == "1")
+            || (string_value == "y")
+            || (string_value == "yes")
+            || (string_value == "true")
+            || (string_value == "on")) {
+        result = true;
     }
 
     return result;
-- 
2.7.4


From 5e89e5e908dd898639fdcfce86700f50559e5e06 Mon Sep 17 00:00:00 2001
From: Ameya Thakur <ameyat@codeaurora.org>
Date: Mon, 27 Jun 2016 12:17:04 +0800
Subject: [PATCH 27/30] init: Add support to write/chown/chmod on symlinks

If the prefix of the path to where a symlink points to is provided
as part of the write/chmod/chown commands we now allow the respective
operation to continue.

Change-Id: I1e992cbd1f7be833918e967c24dfbd473b0fad62
---
 init/builtins.cpp | 141 ++++++++++++++++++++++++++++++++++++++++++++++++++----
 init/util.cpp     |  15 ++++++
 init/util.h       |   1 +
 3 files changed, 148 insertions(+), 9 deletions(-)
 mode change 100644 => 100755 init/builtins.cpp
 mode change 100644 => 100755 init/util.cpp
 mode change 100644 => 100755 init/util.h

diff --git a/init/builtins.cpp b/init/builtins.cpp
old mode 100644
new mode 100755
index 0ca537e..76c417c
--- a/init/builtins.cpp
+++ b/init/builtins.cpp
@@ -843,10 +843,92 @@ static int do_verity_update_state(const std::vector<std::string>& args) {
     return fs_mgr_update_verity_state(verity_update_property);
 }
 
+static const char * get_prefix(const std::vector<std::string>& args)
+{
+    uint32_t arglen = args.size();
+    const char *prefix = NULL;
+    for (uint32_t i = 0; i < arglen - 1; i++) {
+        if (args[i].compare("-p") == 0) {
+            prefix = args[++i].c_str();
+            break;
+        }
+    }
+    return prefix;
+
+}
+static int sanitize_path(const char *path, const char *prefix)
+{
+    struct stat st;
+    char buf[PATH_MAX] = {0};
+    if (!path || !prefix) {
+        goto error;
+    }
+    //Confirm the path exists
+    if (lstat(path, &st) < 0) {
+        ERROR("sanitize_path: Failed to locate path %s: %s\n",
+                path,
+                strerror(errno));
+        goto error;
+    }
+    //If this is a symlink check that the prefix matches
+    if (S_ISLNK(st.st_mode)){
+        if (readlink(path, buf, PATH_MAX - 1) < 0) {
+            ERROR("sanitize_path: Failed to resolve link for %s: %s\n",
+                    path,
+                    strerror(errno));
+            goto error;
+        }
+        if (strncmp(buf, prefix, strlen(prefix))) {
+            ERROR("sanitize_path: Match error: Path:%s Resolved:%s Prefix%s\n",
+                    path,
+                    buf,
+                    prefix);
+            goto error;
+        }
+    }
+    return 0;
+error:
+    return -1;
+}
+
 static int do_write(const std::vector<std::string>& args) {
-    const char* path = args[1].c_str();
-    const char* value = args[2].c_str();
+    const char* path = NULL;
+    const char* value = NULL;
+    const char* prefix = NULL;
+    uint32_t arglen = args.size();
+
+    prefix = get_prefix(args);
+    if (prefix && (arglen != 5)) {
+        ERROR("do_write: Incorrect number of args\n");
+        goto error;
+    }
+    for (uint32_t i = 1; i < arglen - 1; i++) {
+        if (args[i].compare("-p") != 0) {
+            path = args[i++].c_str();
+            value = args[i].c_str();
+            break;
+        } else {
+            //Value at current index is -p. The next index would
+            //be the prefix.Skip beyond that.
+            i+=2;
+        }
+    }
+    if (!path || !value) {
+        ERROR("do_write: Invalid path/value\n");
+        goto error;
+    }
+    if (prefix) {
+        if (sanitize_path(path, prefix) != 0) {
+            ERROR("do_write: Faield to sanitize path: %s prefix: %s\n",
+                            path,
+                            prefix);
+            goto error;
+        }
+        return write_file_follow(path, value);
+    }
     return write_file(path, value);
+error:
+    return -EINVAL;
 }
 
 static int do_copy(const std::vector<std::string>& args) {
@@ -908,18 +990,48 @@ out:
 }
 
 static int do_chown(const std::vector<std::string>& args) {
+    const char *prefix = get_prefix(args);
+    uint32_t num_prefix_args = (!prefix) ? 0:2;
     /* GID is optional. */
-    if (args.size() == 3) {
+    if (args.size() == 3 + num_prefix_args) {
+        if (prefix) {
+            if ((sanitize_path(args[2].c_str(), prefix) != 0)) {
+                ERROR("do_chown: failed for %s..prefix(%s) match error\n",
+                        args[2].c_str(),
+                        prefix);
+                goto error;
+            }
+            //Following of symlink allowed
+            if (chown(args[2].c_str(), decode_uid(args[1].c_str()), -1) == -1)
+                return -errno;
+            return 0;
+        }
+        //Followng of symlinks not allowed
         if (lchown(args[2].c_str(), decode_uid(args[1].c_str()), -1) == -1)
             return -errno;
-    } else if (args.size() == 4) {
+    } else if (args.size() == 4 + num_prefix_args) {
+        if (prefix) {
+            if ((sanitize_path(args[3].c_str(), prefix) != 0)) {
+                ERROR("do_chown: sanitize_path failed for path: %s prefix:%s\n",
+                        args[3].c_str(),
+                        prefix);
+                goto error;
+            }
+            //Following of symlink allowed
+            if (chown(args[3].c_str(), decode_uid(args[1].c_str()),
+                        decode_uid(args[2].c_str())) == -1)
+                return -errno;
+            return 0;
+        }
         if (lchown(args[3].c_str(), decode_uid(args[1].c_str()),
-                   decode_uid(args[2].c_str())) == -1)
+                    decode_uid(args[2].c_str())) == -1)
             return -errno;
     } else {
         return -1;
     }
     return 0;
+error:
+    return -1;
 }
 
 static mode_t get_mode(const char *s) {
@@ -936,8 +1048,19 @@ static mode_t get_mode(const char *s) {
 }
 
 static int do_chmod(const std::vector<std::string>& args) {
+    const char *prefix = get_prefix(args);
+    int flags = AT_SYMLINK_NOFOLLOW;
+    if (prefix) {
+        if (sanitize_path(args[2].c_str(), prefix) != 0) {
+            ERROR("do_chmod: failed for %s..prefix(%s) match err\n",
+                    args[2].c_str(),
+                    prefix);
+            return -1;
+        }
+        flags = 0;
+    }
     mode_t mode = get_mode(args[1].c_str());
-    if (fchmodat(AT_FDCWD, args[2].c_str(), mode, AT_SYMLINK_NOFOLLOW) < 0) {
+    if (fchmodat(AT_FDCWD, args[2].c_str(), mode, flags) < 0) {
         return -errno;
     }
     return 0;
@@ -1028,8 +1151,8 @@ BuiltinFunctionMap::Map& BuiltinFunctionMap::map() const {
     constexpr std::size_t kMax = std::numeric_limits<std::size_t>::max();
     static const Map builtin_functions = {
         {"bootchart_init",          {0,     0,    do_bootchart_init}},
-        {"chmod",                   {2,     2,    do_chmod}},
-        {"chown",                   {2,     3,    do_chown}},
+        {"chmod",                   {2,     4,    do_chmod}},
+        {"chown",                   {2,     5,    do_chown}},
         {"class_reset",             {1,     1,    do_class_reset}},
         {"class_start",             {1,     1,    do_class_start}},
         {"class_stop",              {1,     1,    do_class_stop}},
@@ -1067,7 +1190,7 @@ BuiltinFunctionMap::Map& BuiltinFunctionMap::map() const {
         {"verity_load_state",       {0,     0,    do_verity_load_state}},
         {"verity_update_state",     {0,     0,    do_verity_update_state}},
         {"wait",                    {1,     2,    do_wait}},
-        {"write",                   {2,     2,    do_write}},
+        {"write",                   {2,     4,    do_write}},
     };
     return builtin_functions;
 }
diff --git a/init/util.cpp b/init/util.cpp
old mode 100644
new mode 100755
index 89d3276..babdcbd
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -212,6 +212,21 @@ int write_file(const char* path, const char* content) {
     return result;
 }
 
+int write_file_follow(const char* path, const char* content) {
+    int fd = TEMP_FAILURE_RETRY(open(path, O_WRONLY|O_CREAT|O_CLOEXEC, 0600));
+    if (fd == -1) {
+        NOTICE("write_file: Unable to open '%s': %s\n", path, strerror(errno));
+        return -1;
+    }
+    int result = android::base::WriteStringToFd(content, fd) ? 0 : -1;
+    if (result == -1) {
+        NOTICE("write_file: Unable to write to '%s': %s\n", path, strerror(errno));
+    }
+    close(fd);
+    return result;
+}
+
+
 #define MAX_MTD_PARTITIONS 16
 
 static struct {
diff --git a/init/util.h b/init/util.h
old mode 100644
new mode 100755
index af4b098..db9025d
--- a/init/util.h
+++ b/init/util.h
@@ -33,6 +33,7 @@ int create_socket(const char *name, int type, mode_t perm,
 
 bool read_file(const char* path, std::string* content);
 int write_file(const char* path, const char* content);
+int write_file_follow(const char* path, const char* content);
 
 time_t gettime();
 uint64_t gettime_ns();
-- 
2.7.4


From 383903d9283541f4d66193c5e8e4210a9b9a13ca Mon Sep 17 00:00:00 2001
From: "Christopher R. Palmer" <crpalmer@gmail.com>
Date: Wed, 3 Dec 2014 16:48:04 -0500
Subject: [PATCH 28/30] init: Make restorecon_recursive work for /data/

In the following commit:

    commit f2b7ee765516c84a9995e3acdc8fbcd7dc1b33cc
    Author: Stephen Smalley <sds@tycho.nsa.gov>
    Date:   Thu Feb 6 13:52:52 2014 -0500

    Apply restorecon_recursive to all of /data.

they removed all the adhoc restorecon_recursive of subdirectories
of /data/ and replaced it with:

    # Set SELinux security contexts on upgrade or policy update.
    restorecon_recursive /data

Unfortunately, that is a no-op because restorecon doesn't recurse
through /data/ unless you add a FORCE flag.

Since the expectation seems to be that the recursive restorecon
in init will actually work, update the built-in to add the force
flag and a flag to allow /data/data to also be recursed through.

[RC: Removed the DATADATA flag. It throws a ton of errors, and it's
supposed to be handled by seapp_contexts, not file_contexts. The actual
root paths, however, now get their individual restorecon calls so that
installd can deal with them]

Change-Id: I435c505188e924b27ef2e6a2e0ee0a6951e43f0e
---
 init/util.cpp   | 6 +++++-
 rootdir/init.rc | 3 +++
 2 files changed, 8 insertions(+), 1 deletion(-)

diff --git a/init/util.cpp b/init/util.cpp
index babdcbd..d89fc86 100755
--- a/init/util.cpp
+++ b/init/util.cpp
@@ -481,9 +481,13 @@ int restorecon(const char* pathname)
     return selinux_android_restorecon(pathname, 0);
 }
 
+#define RESTORECON_RECURSIVE_FLAGS \
+        (SELINUX_ANDROID_RESTORECON_FORCE | \
+        SELINUX_ANDROID_RESTORECON_RECURSE)
+
 int restorecon_recursive(const char* pathname)
 {
-    return selinux_android_restorecon(pathname, SELINUX_ANDROID_RESTORECON_RECURSE);
+    return selinux_android_restorecon(pathname, RESTORECON_RECURSIVE_FLAGS);
 }
 
 int restorecon_recursive_skipce(const char* pathname)
diff --git a/rootdir/init.rc b/rootdir/init.rc
index a9b6af0..8452f74 100644
--- a/rootdir/init.rc
+++ b/rootdir/init.rc
@@ -485,6 +485,9 @@ on post-fs-data
 
     # Set SELinux security contexts on upgrade or policy update.
     restorecon_recursive /data
+    restorecon /data/data
+    restorecon /data/user
+    restorecon /data/user/0
 
     # Check any timezone data in /data is newer than the copy in /system, delete if not.
     exec - system system -- /system/bin/tzdatacheck /system/usr/share/zoneinfo /data/misc/zoneinfo
-- 
2.7.4


From b3ff25e5f24813abae63a2984890e7cc08dbe9ea Mon Sep 17 00:00:00 2001
From: David Ng <dave@codeaurora.org>
Date: Wed, 9 Mar 2016 12:07:13 -0800
Subject: [PATCH 29/30] Add AID_QCOM_DIAG/qcom_diag (initial value)

Add new AID AID_QCOM_DIAG for access control to /dev/diag.  The
number ID value is changed to be within the OEM range.

Note that this value deviated from past AID_QCOM_DIAG value, so
will be a problem for OTA.

Todo:
- The previous AID_QCOM_DIAG value is used by a new AOSP AID so
  there is a conflict.  Need to investigate the possibility of
  moving the new AOSP AID out for OTA-type scenario
- Create/use mechanism to inject new AID's to the system without
  changing the default AOSP definition file.  The current mechanism
  exists only for fs_config but not actual system ID's.

Change-Id: Ie286596a2e305a2bf188b658512e87cbea9b935c
---
 include/private/android_filesystem_config.h | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/include/private/android_filesystem_config.h b/include/private/android_filesystem_config.h
index f1bf239..35f9967 100644
--- a/include/private/android_filesystem_config.h
+++ b/include/private/android_filesystem_config.h
@@ -103,6 +103,9 @@
 /* The range 2900-2999 is reserved for OEM, and must never be
  * used here */
 #define AID_OEM_RESERVED_START 2900
+
+#define AID_QCOM_DIAG          2950  /* access to QTI diagnostic resources */
+
 #define AID_OEM_RESERVED_END   2999
 
 /* The 3000 series are intended for use as supplemental group id's only.
@@ -216,6 +219,8 @@ static const struct android_id_info android_ids[] = {
     { "cache",         AID_CACHE, },
     { "diag",          AID_DIAG, },
 
+    { "qcom_diag",     AID_QCOM_DIAG, },
+
     { "net_bt_admin",  AID_NET_BT_ADMIN, },
     { "net_bt",        AID_NET_BT, },
     { "inet",          AID_INET, },
-- 
2.7.4


From c7a63d0c8e34a7776705f41a206641e22ea6d5a4 Mon Sep 17 00:00:00 2001
From: Nikhilesh Reddy <reddyn@codeaurora.org>
Date: Thu, 11 Dec 2014 13:17:06 -0800
Subject: [PATCH 30/30] Allocate a new AIDs for RFS module

Allocate new AIDs to allow the RFS module
to run as after dropping privelages from
ROOT and to enforce strict permissions on
shared and private RFS files.

Change-Id: Ic4febd565df9f232f6c7571355ec10d8fd2e21bd
---
 include/private/android_filesystem_config.h | 11 +++++++++++
 1 file changed, 11 insertions(+)

diff --git a/include/private/android_filesystem_config.h b/include/private/android_filesystem_config.h
index 35f9967..aa99de1 100644
--- a/include/private/android_filesystem_config.h
+++ b/include/private/android_filesystem_config.h
@@ -105,6 +105,8 @@
 #define AID_OEM_RESERVED_START 2900
 
 #define AID_QCOM_DIAG          2950  /* access to QTI diagnostic resources */
+#define AID_RFS                2951  /* Remote Filesystem for peripheral processors */
+#define AID_RFS_SHARED         2952  /* Shared files for Remote Filesystem for peripheral processors  */
 
 #define AID_OEM_RESERVED_END   2999
 
@@ -121,6 +123,9 @@
 #define AID_READPROC      3009  /* Allow /proc read access */
 #define AID_WAKELOCK      3010  /* Allow system wakelock read/write access */
 
+#define AID_RFS_OLD          3012  /* DEPRECATED OLD ID FOR RFS, DO NOT USE */
+#define AID_RFS_SHARED_OLD   3013  /* DEPRECATED OLD ID FOR RFS-SHARED  */
+
 /* The range 5000-5999 is also reserved for OEM, and must never be used here. */
 #define AID_OEM_RESERVED_2_START 5000
 #define AID_OEM_RESERVED_2_END   5999
@@ -221,6 +226,9 @@ static const struct android_id_info android_ids[] = {
 
     { "qcom_diag",     AID_QCOM_DIAG, },
 
+    { "rfs",           AID_RFS, },
+    { "rfs_shared",    AID_RFS_SHARED, },
+
     { "net_bt_admin",  AID_NET_BT_ADMIN, },
     { "net_bt",        AID_NET_BT, },
     { "inet",          AID_INET, },
@@ -236,6 +244,9 @@ static const struct android_id_info android_ids[] = {
     { "sensors",       AID_SENSORS, },
 #endif
 
+    { "rfs_old",           AID_RFS_OLD, },
+    { "rfs_shared_old",    AID_RFS_SHARED_OLD, },
+
     { "everybody",     AID_EVERYBODY, },
     { "misc",          AID_MISC, },
     { "nobody",        AID_NOBODY, },
-- 
2.7.4

