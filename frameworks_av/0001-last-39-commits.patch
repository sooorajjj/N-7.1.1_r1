From d70422bb48efd5b3414748773b1da665dc1318ef Mon Sep 17 00:00:00 2001
From: Praveen Chavan <pchavan@codeaurora.org>
Date: Tue, 14 Jul 2015 12:36:58 -0700
Subject: [PATCH 01/39] CamcorderProfiles: Add new camcorder profiles

Below changes are squashed:

video: Add QHD & 2K profile for recorder
Change-Id: Ib74ca47fc330d02069a3ec010c6ce8431c50f0fe

CamcorderProfiles: add VGA and 4K-DCI profiles

Also add high-speed profile for CIF.

Change-Id: Iacd8537f62112171ee611a7534f9d432f45d5d3f
---
 include/media/MediaProfiles.h    | 14 ++++++++++++++
 media/libmedia/MediaProfiles.cpp | 19 +++++++++++++++++--
 2 files changed, 31 insertions(+), 2 deletions(-)

diff --git a/include/media/MediaProfiles.h b/include/media/MediaProfiles.h
index e02918f..b18553e 100644
--- a/include/media/MediaProfiles.h
+++ b/include/media/MediaProfiles.h
@@ -56,6 +56,20 @@ enum camcorder_quality {
     CAMCORDER_QUALITY_HIGH_SPEED_1080P = 2004,
     CAMCORDER_QUALITY_HIGH_SPEED_2160P = 2005,
     CAMCORDER_QUALITY_HIGH_SPEED_LIST_END = 2005,
+
+    CAMCORDER_QUALITY_VENDOR_START = 10000,
+    CAMCORDER_QUALITY_VGA = 10000,
+    CAMCORDER_QUALITY_4KDCI = 10001,
+    CAMCORDER_QUALITY_TIME_LAPSE_VGA = 10002,
+    CAMCORDER_QUALITY_TIME_LAPSE_4KDCI = 10003,
+    CAMCORDER_QUALITY_HIGH_SPEED_CIF = 10004,
+    CAMCORDER_QUALITY_HIGH_SPEED_VGA = 10005,
+    CAMCORDER_QUALITY_HIGH_SPEED_4KDCI = 10006,
+    CAMCORDER_QUALITY_QHD = 10007,
+    CAMCORDER_QUALITY_2k = 10008,
+    CAMCORDER_QUALITY_TIME_LAPSE_QHD = 10009,
+    CAMCORDER_QUALITY_TIME_LAPSE_2k = 10010,
+    CAMCORDER_QUALITY_VENDOR_END = 10010,
 };
 
 enum video_decoder {
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index ff0e52e..b20a952 100644
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -89,6 +89,19 @@ const MediaProfiles::NameToTagMap MediaProfiles::sCamcorderQualityNameMap[] = {
     {"highspeed720p", CAMCORDER_QUALITY_HIGH_SPEED_720P},
     {"highspeed1080p", CAMCORDER_QUALITY_HIGH_SPEED_1080P},
     {"highspeed2160p", CAMCORDER_QUALITY_HIGH_SPEED_2160P},
+
+    // Vendor-specific profiles
+    {"vga", CAMCORDER_QUALITY_VGA},
+    {"4kdci", CAMCORDER_QUALITY_4KDCI},
+    {"timelapsevga", CAMCORDER_QUALITY_TIME_LAPSE_VGA},
+    {"timelapse4kdci", CAMCORDER_QUALITY_TIME_LAPSE_4KDCI},
+    {"highspeedcif", CAMCORDER_QUALITY_HIGH_SPEED_CIF},
+    {"highspeedvga", CAMCORDER_QUALITY_HIGH_SPEED_VGA},
+    {"highspeed4kdci", CAMCORDER_QUALITY_HIGH_SPEED_4KDCI},
+    {"qhd", CAMCORDER_QUALITY_QHD},
+    {"2k", CAMCORDER_QUALITY_2k},
+    {"timelapseqhd", CAMCORDER_QUALITY_TIME_LAPSE_QHD},
+    {"timelapse2k", CAMCORDER_QUALITY_TIME_LAPSE_2k},
 };
 
 #if LOG_NDEBUG
@@ -424,8 +437,10 @@ MediaProfiles::startElementHandler(void *userData, const char *name, const char
 }
 
 static bool isCamcorderProfile(camcorder_quality quality) {
-    return quality >= CAMCORDER_QUALITY_LIST_START &&
-           quality <= CAMCORDER_QUALITY_LIST_END;
+    return (quality >= CAMCORDER_QUALITY_LIST_START &&
+           quality <= CAMCORDER_QUALITY_LIST_END) ||
+           (quality >= CAMCORDER_QUALITY_VENDOR_START &&
+           quality <= CAMCORDER_QUALITY_VENDOR_END);
 }
 
 static bool isTimelapseProfile(camcorder_quality quality) {
-- 
2.7.4


From ad69627f8f059e388dc866e9306da1ceb3c16243 Mon Sep 17 00:00:00 2001
From: Praveen Chavan <pchavan@codeaurora.org>
Date: Sun, 29 Jan 2017 16:43:07 +0530
Subject: [PATCH 02/39]  Stagefright: Make classes customizable and add AV
 extensions

Change access modifiers and qualify methods with virtual, to
allow extensions. Add facility for loading customizations
(Extended classes) dynamically

Below chages are squashed with this change

 nuplayer: Do not drop corrupt EOS frame
 Change-Id: Ib231dd8eb89aa14f824760562fcc371246d7ba9d

 libstagefright: Allow for MPEG4Writer extension
 Change-Id: If0918be77ab7f8d82c78203f371df789e3cc29b8

 nuplayer: Drop frames with DATACORRUPT flag
 Change-Id: I97bd238d52d660e1ab61eac222cdff28334cc5cc

 libstagefright: choose target specific media_codecs_performance.xml
 Change-Id: If3b37877a38cce59e074f7399c8a844c7cfe55a9

 video: Port miscellaneous video framework changes
 89c6c3f libstagefright: Allocate cached camera buffers for sw encoders
 Change-Id: I90398b2fead1f4e163935bf1db342e24275f7933

 libstagefright: Allow for CameraSourceTimeLapse to be extended
 Change-Id: I309a247ba6e3c5626cfba096677a6dbfeae543f3

 stagefright: Remove additional deep-copy of encoder buffers
 Change-Id: Ib59ac29ebc6ce4afd6fc272688a8260438ab1517

 libstagefright: Set Intra period
 Change-Id: Id2b3e71b746eaaed76118126d44ad83458d68520

 video: Port miscellaneous video framework changes
 Except 89c6c3f libstagefright: Allocate cached camera buffers for sw encoders
 Change-Id: I90398b2fead1f4e163935bf1db342e24275f7933

 avextensions: Add support for Codec Extension features
 Change-Id: Ia342d4abe4bb1e21b9ff2b8213fb96421485a333

 frameworks/av: Changes related to DASH
 Change-Id: I0376841530218703fabd9d4f45d2c9a32a1f52b2

 stagefright: Add support for custom size i/p buffer
 Change-Id: Iad31f5c85601983b01e18e130b1c3eecb3988e30

 audio: use updated method for getting sample bits
 Change-Id: Ic0620fd009a8544db138f088cfd2e7e4a4ff390c

 libmedia: fix for underrun and gapless issue.
 Change-Id: I1ad25d3789aced6b804aa695485341bfa4e97eae

 audio: add support for HW AAC encoder
 Change-Id: I08279fb077f4675736ed76d26c2681a2d1776aab

 libstagefright: Add mime type for VC1 codec
 Change-Id: Id9110ad20eba4d1a053d058d496637e91feb3a35

 stagefright: Update extended extractor APIs
 Change-Id: If8cfc9cff9dd48fbe764f438463c3e24763d4f44

 libstagefright: Update extractor for specific formats
 Change-Id: I63dcc4b2d3901dbc3287eb43a1f4ce2767897258

 audio: add support for wma-pro wma-lossless decoding
 Change-Id: I73ae2c2ccabafebc49d4b2e074da23cb4e51a3ce

 audio: add support for vorbis offloading
 Change-Id: Ic51a9d3e0fad1114908f59bfbc6ce62c6fd9fdea

 AVCustomizations: include audio header files explicitly
 Change-Id: Ib30f94c2b4540a3dbfd2388f43f5d229be047ec7

 audio: add support for APE decoding
 Change-Id: I55e8f4b3b87f4bdf1c99774d702506eb7c2f05b5

 audio: add support for AMRWB+
 Change-Id: I6eedebe93c482150234b4ca1d0472b189c450dc6

 audio: add WMA formats in MediaDefs
 Change-Id: Ifefe04647071eee04ab1e746436fec056ece689f

 audio: add support for offload FLAC
 Change-Id: I617b41b867277272212d6cf1a6f82f646c5b1032

Conflicts:
	include/media/stagefright/ACodec.h
	media/libmediaplayerservice/StagefrightRecorder.h
	media/libstagefright/DataSource.cpp
	media/libstagefright/MediaCodec.cpp
	media/libstagefright/Utils.cpp

Conflicts:
	media/libmediaplayerservice/MediaPlayerService.cpp
	media/libmediaplayerservice/MediaRecorderClient.cpp
	media/libmediaplayerservice/MetadataRetrieverClient.cpp
	media/libmediaplayerservice/StagefrightRecorder.cpp
	media/libstagefright/ACodec.cpp
	media/libstagefright/codecs/aacdec/SoftAAC2.cpp

Change-Id: Icc8965754fb1c73175a13a9ad24c19665ad60988
---
 .../libmediaplayerservice/StagefrightRecorder.cpp  | 24 ++++++++++++++--------
 media/libmediaplayerservice/StagefrightRecorder.h  |  4 ++++
 media/libstagefright/ACodec.cpp                    |  4 ++++
 media/libstagefright/MediaCodecSource.cpp          |  2 ++
 4 files changed, 26 insertions(+), 8 deletions(-)

diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index bd1fd7c..d9bcf56 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -822,8 +822,10 @@ status_t StagefrightRecorder::prepareInternal() {
             break;
 
         default:
-            ALOGE("Unsupported output file format: %d", mOutputFormat);
-            status = UNKNOWN_ERROR;
+            if (handleCustomRecording() != OK) {
+                ALOGE("Unsupported output file format: %d", mOutputFormat);
+                status = UNKNOWN_ERROR;
+            }
             break;
     }
 
@@ -890,8 +892,10 @@ status_t StagefrightRecorder::start() {
 
         default:
         {
-            ALOGE("Unsupported output file format: %d", mOutputFormat);
-            status = UNKNOWN_ERROR;
+            if (handleCustomOutputFormats() != OK) {
+                ALOGE("Unsupported output file format: %d", mOutputFormat);
+                status = UNKNOWN_ERROR;
+            }
             break;
         }
     }
@@ -978,8 +982,10 @@ sp<MediaCodecSource> StagefrightRecorder::createAudioSource() {
             break;
 
         default:
-            ALOGE("Unknown audio encoder: %d", mAudioEncoder);
-            return NULL;
+            if (handleCustomAudioSource(format) != OK) {
+                ALOGE("Unknown audio encoder: %d", mAudioEncoder);
+                return NULL;
+            }
     }
 
     int32_t maxInputSize;
@@ -1661,8 +1667,10 @@ status_t StagefrightRecorder::setupAudioEncoder(const sp<MediaWriter>& writer) {
             break;
 
         default:
-            ALOGE("Unsupported audio encoder: %d", mAudioEncoder);
-            return UNKNOWN_ERROR;
+            if (handleCustomAudioEncoder() != OK) {
+                ALOGE("Unsupported audio encoder: %d", mAudioEncoder);
+                return UNKNOWN_ERROR;
+            }
     }
 
     sp<MediaCodecSource> audioEncoder = createAudioSource();
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index d7f43bc..4ed8e66 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -192,6 +192,10 @@ private:
     void clipNumberOfAudioChannels();
     void setDefaultProfileIfNecessary();
     void setDefaultVideoEncoderIfNecessary();
+    virtual status_t handleCustomOutputFormats() {return UNKNOWN_ERROR;}
+    virtual status_t handleCustomRecording() {return UNKNOWN_ERROR;}
+    virtual status_t handleCustomAudioSource(sp<AMessage> /*format*/) {return UNKNOWN_ERROR;}
+    virtual status_t handleCustomAudioEncoder() {return UNKNOWN_ERROR;}
 
 
     StagefrightRecorder(const StagefrightRecorder &);
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 37fd5a5..ed7179e 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -6608,6 +6608,10 @@ bool ACodec::UninitializedState::onAllocateComponent(const sp<AMessage> &msg) {
         if (list != NULL && list->findCodecByName(componentName.c_str()) >= 0) {
             matchingCodecs.add(componentName);
         }
+        if (matchingCodecs.size() == 0 && componentName.find("qcom", 0) > 0) {
+            matchingCodecs.add(componentName);
+        }
+
     } else {
         CHECK(msg->findString("mime", &mime));
 
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index ea5ef06..635013c 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -475,6 +475,8 @@ status_t MediaCodecSource::initEncoder() {
             ((mFlags & FLAG_PREFER_SOFTWARE_CODEC) ? MediaCodecList::kPreferSoftwareCodecs : 0),
             &matchingCodecs);
 
+    if (matchingCodecs.size() == 0)
+        AVUtils::get()->useQCHWEncoder(mOutputFormat, &matchingCodecs);
     status_t err = NO_INIT;
     for (size_t ix = 0; ix < matchingCodecs.size(); ++ix) {
         mEncoder = MediaCodec::CreateByComponentName(
-- 
2.7.4


From aaabda5ca830500fe944e0e7813e9fb14f80db31 Mon Sep 17 00:00:00 2001
From: Mingming Yin <mingming@codeaurora.org>
Date: Fri, 14 Aug 2015 10:43:05 -0700
Subject: [PATCH 03/39] audio: add support for extended audio encoding

- add support for EVRC, QCELP, h/w AAC and LPCM encoding.

Conflicts:
	include/media/mediarecorder.h
	media/libmediaplayerservice/StagefrightRecorder.h

Change-Id: I2f93a88ed5c9bd502399ef145a5802d1a15fcc45
---
 media/libstagefright/MediaCodecSource.cpp | 15 +++++++++------
 1 file changed, 9 insertions(+), 6 deletions(-)

diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index 635013c..ceb82eb 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -470,13 +470,16 @@ status_t MediaCodecSource::initEncoder() {
     CHECK(mOutputFormat->findString("mime", &outputMIME));
 
     Vector<AString> matchingCodecs;
-    MediaCodecList::findMatchingCodecs(
-            outputMIME.c_str(), true /* encoder */,
-            ((mFlags & FLAG_PREFER_SOFTWARE_CODEC) ? MediaCodecList::kPreferSoftwareCodecs : 0),
-            &matchingCodecs);
 
-    if (matchingCodecs.size() == 0)
-        AVUtils::get()->useQCHWEncoder(mOutputFormat, &matchingCodecs);
+    if (AVUtils::get()->useQCHWEncoder(mOutputFormat, &matchingCodecs)) {
+        ;
+    } else {
+        MediaCodecList::findMatchingCodecs(
+                outputMIME.c_str(), true /* encoder */,
+                ((mFlags & FLAG_PREFER_SOFTWARE_CODEC) ? MediaCodecList::kPreferSoftwareCodecs : 0),
+                &matchingCodecs);
+    }
+
     status_t err = NO_INIT;
     for (size_t ix = 0; ix < matchingCodecs.size(); ++ix) {
         mEncoder = MediaCodec::CreateByComponentName(
-- 
2.7.4


From 1e7fca2e262139be8db0dc175a8e15f8649050d8 Mon Sep 17 00:00:00 2001
From: Praveen Chavan <pchavan@codeaurora.org>
Date: Thu, 2 Jul 2015 16:09:10 -0700
Subject: [PATCH 04/39] Stagefright: Make classes customizable and add AV
 extensions

Change access modifiers and qualify methods with virtual, to
allow extensions. Add facility for loading customizations
(Extended classes) dynamically

Below chages are squashed with this change

 nuplayer: Do not drop corrupt EOS frame
 Change-Id: Ib231dd8eb89aa14f824760562fcc371246d7ba9d

 libstagefright: Allow for MPEG4Writer extension
 Change-Id: If0918be77ab7f8d82c78203f371df789e3cc29b8

 nuplayer: Drop frames with DATACORRUPT flag
 Change-Id: I97bd238d52d660e1ab61eac222cdff28334cc5cc

 libstagefright: choose target specific media_codecs_performance.xml
 Change-Id: If3b37877a38cce59e074f7399c8a844c7cfe55a9

 video: Port miscellaneous video framework changes
 89c6c3f libstagefright: Allocate cached camera buffers for sw encoders
 Change-Id: I90398b2fead1f4e163935bf1db342e24275f7933

 libstagefright: Allow for CameraSourceTimeLapse to be extended
 Change-Id: I309a247ba6e3c5626cfba096677a6dbfeae543f3

 stagefright: Remove additional deep-copy of encoder buffers
 Change-Id: Ib59ac29ebc6ce4afd6fc272688a8260438ab1517

 libstagefright: Set Intra period
 Change-Id: Id2b3e71b746eaaed76118126d44ad83458d68520

 video: Port miscellaneous video framework changes
 Except 89c6c3f libstagefright: Allocate cached camera buffers for sw encoders
 Change-Id: I90398b2fead1f4e163935bf1db342e24275f7933

 avextensions: Add support for Codec Extension features
 Change-Id: Ia342d4abe4bb1e21b9ff2b8213fb96421485a333

 frameworks/av: Changes related to DASH
 Change-Id: I0376841530218703fabd9d4f45d2c9a32a1f52b2

 stagefright: Add support for custom size i/p buffer
 Change-Id: Iad31f5c85601983b01e18e130b1c3eecb3988e30

 audio: use updated method for getting sample bits
 Change-Id: Ic0620fd009a8544db138f088cfd2e7e4a4ff390c

 libmedia: fix for underrun and gapless issue.
 Change-Id: I1ad25d3789aced6b804aa695485341bfa4e97eae

 audio: add support for HW AAC encoder
 Change-Id: I08279fb077f4675736ed76d26c2681a2d1776aab

 libstagefright: Add mime type for VC1 codec
 Change-Id: Id9110ad20eba4d1a053d058d496637e91feb3a35

 stagefright: Update extended extractor APIs
 Change-Id: If8cfc9cff9dd48fbe764f438463c3e24763d4f44

 libstagefright: Update extractor for specific formats
 Change-Id: I63dcc4b2d3901dbc3287eb43a1f4ce2767897258

 audio: add support for wma-pro wma-lossless decoding
 Change-Id: I73ae2c2ccabafebc49d4b2e074da23cb4e51a3ce

 audio: add support for vorbis offloading
 Change-Id: Ic51a9d3e0fad1114908f59bfbc6ce62c6fd9fdea

 AVCustomizations: include audio header files explicitly
 Change-Id: Ib30f94c2b4540a3dbfd2388f43f5d229be047ec7

 audio: add support for APE decoding
 Change-Id: I55e8f4b3b87f4bdf1c99774d702506eb7c2f05b5

 audio: add support for AMRWB+
 Change-Id: I6eedebe93c482150234b4ca1d0472b189c450dc6

 audio: add WMA formats in MediaDefs
 Change-Id: Ifefe04647071eee04ab1e746436fec056ece689f

 audio: add support for offload FLAC
 Change-Id: I617b41b867277272212d6cf1a6f82f646c5b1032

Conflicts:
	include/media/stagefright/ACodec.h
	media/libmediaplayerservice/StagefrightRecorder.h
	media/libstagefright/DataSource.cpp
	media/libstagefright/MediaCodec.cpp
	media/libstagefright/Utils.cpp

Conflicts:
	media/libmediaplayerservice/MediaPlayerService.cpp
	media/libmediaplayerservice/MediaRecorderClient.cpp
	media/libmediaplayerservice/MetadataRetrieverClient.cpp
	media/libmediaplayerservice/StagefrightRecorder.cpp
	media/libstagefright/ACodec.cpp
	media/libstagefright/codecs/aacdec/SoftAAC2.cpp

Change-Id: Icc8965754fb1c73175a13a9ad24c19665ad60988
---
 include/media/AudioTrack.h                         |   2 +
 include/media/MediaPlayerInterface.h               |   1 +
 include/media/mediaplayer.h                        |   9 +-
 include/media/mediarecorder.h                      |   7 +-
 include/media/stagefright/ACodec.h                 |  30 ++--
 include/media/stagefright/AudioSource.h            |   1 -
 include/media/stagefright/CameraSourceTimeLapse.h  |   5 +-
 include/media/stagefright/ExtendedMediaDefs.h      |  69 +++++++++
 include/media/stagefright/MPEG4Writer.h            |   9 +-
 include/media/stagefright/MediaCodec.h             |   4 +-
 include/media/stagefright/MediaDefs.h              |   2 +
 media/libavextensions/Android.mk                   |  86 +++++++++++
 media/libavextensions/common/AVExtensionsCommon.h  |  69 +++++++++
 media/libavextensions/common/ExtensionsLoader.hpp  |  91 ++++++++++++
 media/libavextensions/media/AVMediaExtensions.h    |  56 ++++++++
 media/libavextensions/media/AVMediaUtils.cpp       |  61 ++++++++
 .../mediaplayerservice/AVMediaServiceExtensions.h  |  63 ++++++++
 .../mediaplayerservice/AVMediaServiceFactory.cpp   |  61 ++++++++
 .../mediaplayerservice/AVMediaServiceUtils.cpp     |  53 +++++++
 .../mediaplayerservice/AVNuExtensions.h            |  68 +++++++++
 .../mediaplayerservice/AVNuFactory.cpp             |  71 +++++++++
 .../mediaplayerservice/AVNuUtils.cpp               |  65 +++++++++
 media/libavextensions/stagefright/AVExtensions.h   | 158 +++++++++++++++++++++
 media/libavextensions/stagefright/AVFactory.cpp    | 115 +++++++++++++++
 media/libavextensions/stagefright/AVUtils.cpp      | 150 +++++++++++++++++++
 .../stagefright/ExtendedMediaDefs.cpp              |  68 +++++++++
 media/libmedia/Android.mk                          |   3 +-
 media/libmedia/AudioTrack.cpp                      |   2 +
 media/libmediaplayerservice/Android.mk             |   6 +-
 media/libmediaplayerservice/MediaPlayerFactory.cpp |   8 ++
 media/libmediaplayerservice/MediaPlayerService.cpp |  10 +-
 .../libmediaplayerservice/MediaRecorderClient.cpp  |   6 +-
 .../MetadataRetrieverClient.cpp                    |  15 +-
 .../libmediaplayerservice/StagefrightRecorder.cpp  |  46 +++---
 media/libmediaplayerservice/StagefrightRecorder.h  |   7 +-
 media/libmediaplayerservice/nuplayer/Android.mk    |   3 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |   3 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |   9 +-
 .../nuplayer/NuPlayerDecoder.cpp                   |  11 ++
 .../nuplayer/NuPlayerDecoder.h                     |   1 -
 .../nuplayer/NuPlayerDecoderPassThrough.cpp        |  11 +-
 .../nuplayer/NuPlayerDecoderPassThrough.h          |   7 +-
 .../nuplayer/NuPlayerDriver.cpp                    |   5 +-
 .../nuplayer/NuPlayerRenderer.cpp                  |  23 ++-
 .../nuplayer/NuPlayerRenderer.h                    |   1 -
 media/libstagefright/ACodec.cpp                    |  34 ++++-
 media/libstagefright/Android.mk                    |   5 +-
 media/libstagefright/CameraSource.cpp              |   4 +
 media/libstagefright/DataSource.cpp                |   2 +
 media/libstagefright/MPEG4Writer.cpp               |  38 +++--
 media/libstagefright/MediaCodec.cpp                |  13 +-
 media/libstagefright/MediaCodecList.cpp            |  14 +-
 media/libstagefright/MediaCodecSource.cpp          |   7 +
 media/libstagefright/MediaExtractor.cpp            |   6 +-
 media/libstagefright/MediaMuxer.cpp                |   3 +-
 media/libstagefright/StagefrightMediaScanner.cpp   |   4 +-
 .../StagefrightMetadataRetriever.cpp               |   3 +
 media/libstagefright/Utils.cpp                     |  18 ++-
 media/libstagefright/codecs/aacdec/SoftAAC2.cpp    |  65 ++++++++-
 media/libstagefright/codecs/aacdec/SoftAAC2.h      |   3 +
 media/libstagefright/codecs/mp3dec/SoftMP3.cpp     |  31 +++-
 media/libstagefright/codecs/mp3dec/SoftMP3.h       |   3 +
 .../common/managerdefinitions/Android.mk           |  17 +++
 .../managerdefinitions/src/TypeConverter.cpp       |  29 ++++
 64 files changed, 1732 insertions(+), 118 deletions(-)
 create mode 100644 include/media/stagefright/ExtendedMediaDefs.h
 create mode 100644 media/libavextensions/Android.mk
 create mode 100644 media/libavextensions/common/AVExtensionsCommon.h
 create mode 100644 media/libavextensions/common/ExtensionsLoader.hpp
 create mode 100644 media/libavextensions/media/AVMediaExtensions.h
 create mode 100644 media/libavextensions/media/AVMediaUtils.cpp
 create mode 100644 media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h
 create mode 100644 media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp
 create mode 100644 media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp
 create mode 100644 media/libavextensions/mediaplayerservice/AVNuExtensions.h
 create mode 100644 media/libavextensions/mediaplayerservice/AVNuFactory.cpp
 create mode 100644 media/libavextensions/mediaplayerservice/AVNuUtils.cpp
 create mode 100644 media/libavextensions/stagefright/AVExtensions.h
 create mode 100644 media/libavextensions/stagefright/AVFactory.cpp
 create mode 100644 media/libavextensions/stagefright/AVUtils.cpp
 create mode 100644 media/libavextensions/stagefright/ExtendedMediaDefs.cpp

diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index 88c4e61..9eb89e3 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -32,6 +32,7 @@ namespace android {
 struct audio_track_cblk_t;
 class AudioTrackClientProxy;
 class StaticAudioTrackClientProxy;
+struct ExtendedMediaUtils;
 
 // ----------------------------------------------------------------------------
 
@@ -1105,6 +1106,7 @@ private:
     pid_t                   mClientPid;
 
     sp<AudioSystem::AudioDeviceCallback> mDeviceCallback;
+    friend struct ExtendedMediaUtils;
 };
 
 }; // namespace android
diff --git a/include/media/MediaPlayerInterface.h b/include/media/MediaPlayerInterface.h
index 4977efd..2ef68cd 100644
--- a/include/media/MediaPlayerInterface.h
+++ b/include/media/MediaPlayerInterface.h
@@ -52,6 +52,7 @@ enum player_type {
     // The shared library with the test player is passed passed as an
     // argument to the 'test:' url in the setDataSource call.
     TEST_PLAYER = 5,
+    DASH_PLAYER = 6,
 };
 
 
diff --git a/include/media/mediaplayer.h b/include/media/mediaplayer.h
index cec9d99..54ca5d5 100644
--- a/include/media/mediaplayer.h
+++ b/include/media/mediaplayer.h
@@ -209,7 +209,7 @@ public:
             void            died();
             void            disconnect();
 
-            status_t        setDataSource(
+    virtual status_t        setDataSource(
                     const sp<IMediaHTTPService> &httpService,
                     const char *url,
                     const KeyedVector<String8, String8> *headers);
@@ -223,7 +223,7 @@ public:
             status_t        prepareAsync();
             status_t        start();
             status_t        stop();
-            status_t        pause();
+    virtual status_t        pause();
             bool            isPlaying();
             status_t        setPlaybackSettings(const AudioPlaybackRate& rate);
             status_t        getPlaybackSettings(AudioPlaybackRate* rate /* nonnull */);
@@ -233,7 +233,7 @@ public:
                                     float* videoFps /* nonnull */);
             status_t        getVideoWidth(int *w);
             status_t        getVideoHeight(int *h);
-            status_t        seekTo(int msec);
+    virtual status_t        seekTo(int msec);
             status_t        getCurrentPosition(int *msec);
             status_t        getDuration(int *msec);
             status_t        reset();
@@ -242,7 +242,7 @@ public:
             status_t        setLooping(int loop);
             bool            isLooping();
             status_t        setVolume(float leftVolume, float rightVolume);
-            void            notify(int msg, int ext1, int ext2, const Parcel *obj = NULL);
+    virtual void            notify(int msg, int ext1, int ext2, const Parcel *obj = NULL);
             status_t        invoke(const Parcel& request, Parcel *reply);
             status_t        setMetadataFilter(const Parcel& filter);
             status_t        getMetadata(bool update_only, bool apply_filter, Parcel *metadata);
@@ -288,6 +288,7 @@ private:
     float                       mSendLevel;
     struct sockaddr_in          mRetransmitEndpoint;
     bool                        mRetransmitEndpointValid;
+    friend class QCMediaPlayer;
 };
 
 }; // namespace android
diff --git a/include/media/mediarecorder.h b/include/media/mediarecorder.h
index c3f39a2..c7b7840 100644
--- a/include/media/mediarecorder.h
+++ b/include/media/mediarecorder.h
@@ -76,7 +76,8 @@ enum output_format {
 
     /* VP8/VORBIS data in a WEBM container */
     OUTPUT_FORMAT_WEBM = 9,
-
+    OUTPUT_FORMAT_QCP = 20,
+    OUTPUT_FORMAT_WAVE = 21,
     OUTPUT_FORMAT_LIST_END // must be last - used to validate format type
 };
 
@@ -88,7 +89,9 @@ enum audio_encoder {
     AUDIO_ENCODER_HE_AAC = 4,
     AUDIO_ENCODER_AAC_ELD = 5,
     AUDIO_ENCODER_VORBIS = 6,
-
+    AUDIO_ENCODER_EVRC = 10,
+    AUDIO_ENCODER_QCELP = 11,
+    AUDIO_ENCODER_LPCM = 12,
     AUDIO_ENCODER_LIST_END // must be the last - used to validate the audio encoder type
 };
 
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 25f7173..7da82c1 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -114,8 +114,11 @@ struct ACodec : public AHierarchicalStateMachine, public CodecBase {
 
 protected:
     virtual ~ACodec();
+    virtual status_t setupCustomCodec(
+            status_t err, const char *mime, const sp<AMessage> &msg);
+    virtual status_t GetVideoCodingTypeFromMime(
+            const char *mime, OMX_VIDEO_CODINGTYPE *codingType);
 
-private:
     struct BaseState;
     struct UninitializedState;
     struct LoadedState;
@@ -340,12 +343,11 @@ private:
             uint32_t portIndex, IOMX::buffer_id bufferID,
             ssize_t *index = NULL);
 
-    status_t setComponentRole(bool isEncoder, const char *mime);
+    virtual status_t setComponentRole(bool isEncoder, const char *mime);
     static const char *getComponentRole(bool isEncoder, const char *mime);
     static status_t setComponentRole(
             const sp<IOMX> &omx, IOMX::node_id node, const char *role);
-
-    status_t configureCodec(const char *mime, const sp<AMessage> &msg);
+    virtual status_t configureCodec(const char *mime, const sp<AMessage> &msg);
 
     status_t configureTunneledVideoPlayback(int32_t audioHwSync,
             const sp<ANativeWindow> &nativeWindow);
@@ -358,11 +360,11 @@ private:
 
     status_t setSupportedOutputFormat(bool getLegacyFlexibleFormat);
 
-    status_t setupVideoDecoder(
+    virtual status_t setupVideoDecoder(
             const char *mime, const sp<AMessage> &msg, bool usingNativeBuffers, bool haveSwRenderer,
             sp<AMessage> &outputformat);
 
-    status_t setupVideoEncoder(
+    virtual status_t setupVideoEncoder(
             const char *mime, const sp<AMessage> &msg,
             sp<AMessage> &outputformat, sp<AMessage> &inputformat);
 
@@ -503,7 +505,7 @@ private:
     status_t configureBitrate(
             int32_t bitrate, OMX_VIDEO_CONTROLRATETYPE bitrateMode);
 
-    status_t setupErrorCorrectionParameters();
+    virtual status_t setupErrorCorrectionParameters();
 
     status_t initNativeWindow();
 
@@ -545,7 +547,7 @@ private:
     void addKeyFormatChangesToRenderBufferNotification(sp<AMessage> &notify);
     void sendFormatChange();
 
-    status_t getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify);
+    virtual status_t getPortFormat(OMX_U32 portIndex, sp<AMessage> &notify);
 
     void signalError(
             OMX_ERRORTYPE error = OMX_ErrorUndefined,
@@ -557,11 +559,21 @@ private:
         DescribeColorFormat2Params &describeParams);
 
     status_t requestIDRFrame();
-    status_t setParameters(const sp<AMessage> &params);
+    virtual status_t setParameters(const sp<AMessage> &params);
 
     // Send EOS on input stream.
     void onSignalEndOfInputStream();
 
+    virtual void setBFrames(OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type) {}
+    virtual void setBFrames(OMX_VIDEO_PARAM_AVCTYPE *h264type,
+        const int32_t iFramesInterval, const int32_t frameRate) {}
+
+    virtual status_t getVQZIPInfo(const sp<AMessage> &msg) {
+        return OK;
+    }
+
+    sp<IOMXObserver> createObserver();
+
     DISALLOW_EVIL_CONSTRUCTORS(ACodec);
 };
 
diff --git a/include/media/stagefright/AudioSource.h b/include/media/stagefright/AudioSource.h
index 8fc410d..3fc6a9c 100644
--- a/include/media/stagefright/AudioSource.h
+++ b/include/media/stagefright/AudioSource.h
@@ -60,7 +60,6 @@ struct AudioSource : public MediaSource, public MediaBufferObserver {
 protected:
     virtual ~AudioSource();
 
-private:
     enum {
         kMaxBufferSize = 2048,
 
diff --git a/include/media/stagefright/CameraSourceTimeLapse.h b/include/media/stagefright/CameraSourceTimeLapse.h
index 871c1d9..4a4ad54 100644
--- a/include/media/stagefright/CameraSourceTimeLapse.h
+++ b/include/media/stagefright/CameraSourceTimeLapse.h
@@ -20,6 +20,7 @@
 
 #include <pthread.h>
 
+#include <media/stagefright/CameraSource.h>
 #include <utils/RefBase.h>
 #include <utils/threads.h>
 #include <utils/String16.h>
@@ -60,7 +61,7 @@ public:
     // returning quickly.
     void startQuickReadReturns();
 
-private:
+protected:
     // size of the encoded video.
     int32_t mVideoWidth;
     int32_t mVideoHeight;
@@ -171,7 +172,7 @@ private:
     // the frame needs to be encoded, it returns false and also modifies
     // the time stamp to be one frame time ahead of the last encoded
     // frame's time stamp.
-    bool skipFrameAndModifyTimeStamp(int64_t *timestampUs);
+    virtual bool skipFrameAndModifyTimeStamp(int64_t *timestampUs);
 
     // Wrapper to enter threadTimeLapseEntry()
     static void *ThreadTimeLapseWrapper(void *me);
diff --git a/include/media/stagefright/ExtendedMediaDefs.h b/include/media/stagefright/ExtendedMediaDefs.h
new file mode 100644
index 0000000..18b5e9a
--- /dev/null
+++ b/include/media/stagefright/ExtendedMediaDefs.h
@@ -0,0 +1,69 @@
+/*Copyright (c) 2015, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _EXTENDED_MEDIA_DEFS_H_
+#define _EXTENDED_MEDIA_DEFS_H_
+
+namespace android {
+
+extern const char *MEDIA_MIMETYPE_AUDIO_EVRC;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV;
+extern const char *MEDIA_MIMETYPE_VIDEO_WMV_VC1;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA_PRO;
+extern const char *MEDIA_MIMETYPE_AUDIO_WMA_LOSSLESS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_ASF;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX;
+extern const char *MEDIA_MIMETYPE_CONTAINER_AAC;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCP;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX311;
+extern const char *MEDIA_MIMETYPE_VIDEO_DIVX4;
+extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG2;
+extern const char *MEDIA_MIMETYPE_CONTAINER_3G2;
+extern const char *MEDIA_MIMETYPE_AUDIO_DTS;
+extern const char *MEDIA_MIMETYPE_AUDIO_DTS_LBR;
+extern const char *MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS;
+extern const char *MEDIA_MIMETYPE_AUDIO_AIFF;
+extern const char *MEDIA_MIMETYPE_AUDIO_ALAC;
+extern const char *MEDIA_MIMETYPE_AUDIO_APE;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCAMR_NB;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCAMR_WB;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCWAV;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG2TS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG2PS;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG4;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCMATROSKA;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCOGG;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QCFLV;
+extern const char *MEDIA_MIMETYPE_VIDEO_VPX;
+extern const char *MEDIA_MIMETYPE_CONTAINER_QTIFLAC;
+extern const char *MEDIA_MIMETYPE_VIDEO_MPEG4_DP;
+
+}  // namespace android
+
+#endif // _EXTENDED_MEDIA_DEFS_H_
diff --git a/include/media/stagefright/MPEG4Writer.h b/include/media/stagefright/MPEG4Writer.h
index 8f0eaa7..ad12e80 100644
--- a/include/media/stagefright/MPEG4Writer.h
+++ b/include/media/stagefright/MPEG4Writer.h
@@ -78,13 +78,17 @@ private:
     int  mFd;
     status_t mInitCheck;
     bool mIsRealTimeRecording;
+protected:
     bool mUse4ByteNalLength;
+private:
     bool mUse32BitOffset;
     bool mIsFileSizeLimitExplicitlyRequested;
     bool mPaused;
     bool mStarted;  // Writer thread + track threads started successfully
     bool mWriterThreadStarted;  // Only writer thread started successfully
+protected:
     off64_t mOffset;
+private:
     off_t mMdatOffset;
     uint8_t *mMoovBoxBuffer;
     off64_t mMoovBoxBufferOffset;
@@ -187,9 +191,12 @@ private:
 
     // Acquire lock before calling these methods
     off64_t addSample_l(MediaBuffer *buffer);
-    off64_t addLengthPrefixedSample_l(MediaBuffer *buffer);
     off64_t addMultipleLengthPrefixedSamples_l(MediaBuffer *buffer);
+protected:
+    static void StripStartcode(MediaBuffer *buffer);
+    virtual off64_t addLengthPrefixedSample_l(MediaBuffer *buffer);
 
+private:
     bool exceedsFileSizeLimit();
     bool use32BitFileOffset() const;
     bool exceedsFileDurationLimit();
diff --git a/include/media/stagefright/MediaCodec.h b/include/media/stagefright/MediaCodec.h
index fe579b7..05f6581 100644
--- a/include/media/stagefright/MediaCodec.h
+++ b/include/media/stagefright/MediaCodec.h
@@ -41,7 +41,7 @@ class IResourceManagerClient;
 class IResourceManagerService;
 struct PersistentSurface;
 struct SoftwareRenderer;
-struct Surface;
+class Surface;
 
 struct MediaCodec : public AHandler {
     enum ConfigureFlags {
@@ -52,6 +52,8 @@ struct MediaCodec : public AHandler {
         BUFFER_FLAG_SYNCFRAME   = 1,
         BUFFER_FLAG_CODECCONFIG = 2,
         BUFFER_FLAG_EOS         = 4,
+        BUFFER_FLAG_EXTRADATA   = 0x1000,
+        BUFFER_FLAG_DATACORRUPT = 0x2000,
     };
 
     enum {
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 5f2a32d..9eae7ca 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -79,4 +79,6 @@ enum AudioEncoding {
 
 }  // namespace android
 
+#include <media/stagefright/ExtendedMediaDefs.h>
+
 #endif  // MEDIA_DEFS_H_
diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
new file mode 100644
index 0000000..8a72be4
--- /dev/null
+++ b/media/libavextensions/Android.mk
@@ -0,0 +1,86 @@
+LOCAL_PATH:= $(call my-dir)
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=                          \
+        stagefright/ExtendedMediaDefs.cpp  \
+        stagefright/AVUtils.cpp            \
+        stagefright/AVFactory.cpp          \
+
+LOCAL_C_INCLUDES:= \
+        $(TOP)/frameworks/av/include/media/ \
+        $(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/native/include/media/hardware \
+        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/external/flac/include \
+        $(TOP)/hardware/qcom/media/mm-core/inc
+
+LOCAL_CFLAGS += -Wno-multichar -Werror
+
+ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
+       LOCAL_CFLAGS += -DENABLE_AV_ENHANCEMENTS
+endif
+
+LOCAL_MODULE:= libavextensions
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_STATIC_LIBRARY)
+
+########################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=                          \
+        media/AVMediaUtils.cpp             \
+
+LOCAL_C_INCLUDES:= \
+        $(TOP)/frameworks/av/include/media/ \
+        $(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/native/include/media/hardware \
+        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/external/flac/include \
+        $(TOP)/hardware/qcom/media/mm-core/inc
+
+LOCAL_CFLAGS += -Wno-multichar -Werror
+
+ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
+       LOCAL_CFLAGS += -DENABLE_AV_ENHANCEMENTS
+endif
+
+LOCAL_MODULE:= libavmediaextentions
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_STATIC_LIBRARY)
+
+########################################################
+
+include $(CLEAR_VARS)
+
+LOCAL_SRC_FILES:=                                      \
+        mediaplayerservice/AVMediaServiceFactory.cpp   \
+        mediaplayerservice/AVMediaServiceUtils.cpp     \
+        mediaplayerservice/AVNuFactory.cpp             \
+        mediaplayerservice/AVNuUtils.cpp               \
+
+LOCAL_C_INCLUDES:= \
+        $(TOP)/frameworks/av/include/media/ \
+        $(TOP)/frameworks/av/media/libmediaplayerservice \
+        $(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/native/include/media/hardware \
+        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/external/flac/include \
+        $(TOP)/hardware/qcom/media/mm-core/inc
+
+LOCAL_CFLAGS += -Wno-multichar -Werror
+
+ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
+       LOCAL_CFLAGS += -DENABLE_AV_ENHANCEMENTS
+endif
+
+LOCAL_MODULE:= libavmediaserviceextensions
+
+LOCAL_MODULE_TAGS := optional
+
+include $(BUILD_STATIC_LIBRARY)
+
diff --git a/media/libavextensions/common/AVExtensionsCommon.h b/media/libavextensions/common/AVExtensionsCommon.h
new file mode 100644
index 0000000..068dd61
--- /dev/null
+++ b/media/libavextensions/common/AVExtensionsCommon.h
@@ -0,0 +1,69 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _AV_EXTENSIONS_COMMON_H_
+#define _AV_EXTENSIONS_COMMON_H_
+
+namespace android {
+
+static const char * CUSTOMIZATION_LIB_NAME = "libavenhancements.so";
+
+typedef void *(*createFunction_t)(void);
+
+template <typename T>
+struct ExtensionsLoader {
+
+    static T *createInstance(const char *createFunctionName);
+
+private:
+    static void loadLib();
+    static createFunction_t loadCreateFunction(const char *createFunctionName);
+    static void *mLibHandle;
+};
+
+/*
+ * Boiler-plate to declare the class as a singleton (with a static getter)
+ * which can be loaded (dlopen'd) via ExtensionsLoader
+ */
+#define DECLARE_LOADABLE_SINGLETON(className)   \
+protected:                                      \
+    className();                                \
+    virtual ~className();                       \
+    static className *sInst;                    \
+private:                                        \
+    className(const className&);                \
+    className &operator=(className &);          \
+public:                                         \
+    static className *get() {                   \
+        return sInst;                           \
+    }                                           \
+    friend struct ExtensionsLoader<className>;
+
+} //namespace android
+
+#endif // _AV_EXTENSIONS_COMMON_H_
diff --git a/media/libavextensions/common/ExtensionsLoader.hpp b/media/libavextensions/common/ExtensionsLoader.hpp
new file mode 100644
index 0000000..8a2430f
--- /dev/null
+++ b/media/libavextensions/common/ExtensionsLoader.hpp
@@ -0,0 +1,91 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <dlfcn.h>
+#include <common/AVExtensionsCommon.h>
+
+namespace android {
+
+/*
+ * Create strongly-typed objects of type T
+ * If the customization library exists and does contain a "named" constructor,
+ *  invoke and create an instance
+ * Else create the object of type T itself
+ *
+ * Contains a static instance to dlopen'd library, But may end up
+ * opening the library mutiple times. Following snip from dlopen man page is
+ * reassuring "...Only a single copy of an object file is brought into the
+ * address space, even if dlopen() is invoked multiple times in reference to
+ * the file, and even if different pathnames are used to reference the file.."
+ */
+
+template <typename T>
+T *ExtensionsLoader<T>::createInstance(const char *createFunctionName) {
+        ALOGV("createInstance(%lubit) : %s", (unsigned long)sizeof(intptr_t)*8, createFunctionName);
+        // create extended object if extensions-lib is available and
+        // AV_ENHANCEMENTS is enabled
+#if ENABLE_AV_ENHANCEMENTS
+        createFunction_t createFunc = loadCreateFunction(createFunctionName);
+        if (createFunc) {
+            return reinterpret_cast<T *>((*createFunc)());
+        }
+#endif
+        // Else, create the default object
+        return new T;
+}
+
+template <typename T>
+void ExtensionsLoader<T>::loadLib() {
+        if (!mLibHandle) {
+            mLibHandle = ::dlopen(CUSTOMIZATION_LIB_NAME, RTLD_LAZY);
+            if (!mLibHandle) {
+                ALOGV("%s", dlerror());
+                return;
+            }
+            ALOGV("Opened %s", CUSTOMIZATION_LIB_NAME);
+        }
+}
+
+template <typename T>
+createFunction_t ExtensionsLoader<T>::loadCreateFunction(const char *createFunctionName) {
+        loadLib();
+        if (!mLibHandle) {
+            return NULL;
+        }
+        createFunction_t func = (createFunction_t)dlsym(mLibHandle, createFunctionName);
+        if (!func) {
+            ALOGW("symbol %s not found:  %s",createFunctionName, dlerror());
+        }
+        return func;
+}
+
+//static
+template <typename T>
+void *ExtensionsLoader<T>::mLibHandle = NULL;
+
+} //namespace android
diff --git a/media/libavextensions/media/AVMediaExtensions.h b/media/libavextensions/media/AVMediaExtensions.h
new file mode 100644
index 0000000..f8204e3
--- /dev/null
+++ b/media/libavextensions/media/AVMediaExtensions.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef _AV_MEDIA_EXTENSIONS_H_
+#define _AV_MEDIA_EXTENSIONS_H_
+
+#include <common/AVExtensionsCommon.h>
+#include <hardware/audio.h>
+#include <media/AudioTrack.h>
+
+namespace android {
+
+class MediaRecorder;
+/*
+ * Common delegate to the classes in libstagefright
+ */
+struct AVMediaUtils {
+
+
+    virtual size_t AudioTrackGetOffloadFrameCount(size_t frameCount) {
+        return frameCount;
+    }
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVMediaUtils);
+};
+
+} //namespace android
+
+#endif //_AV_MEDIA_EXTENSIONS_H_
+
diff --git a/media/libavextensions/media/AVMediaUtils.cpp b/media/libavextensions/media/AVMediaUtils.cpp
new file mode 100644
index 0000000..752f6d0
--- /dev/null
+++ b/media/libavextensions/media/AVMediaUtils.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "AVMediaUtils"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaCodecList.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/ACodec.h>
+
+#include <media/AudioTrack.h>
+
+#include "common/ExtensionsLoader.hpp"
+#include "media/AVMediaExtensions.h"
+
+namespace android {
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVMediaUtils::AVMediaUtils() {
+}
+
+AVMediaUtils::~AVMediaUtils() {
+}
+
+//static
+AVMediaUtils *AVMediaUtils::sInst =
+        ExtensionsLoader<AVMediaUtils>::createInstance("createExtendedMediaUtils");
+
+} //namespace android
+
diff --git a/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h b/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h
new file mode 100644
index 0000000..892cb53
--- /dev/null
+++ b/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h
@@ -0,0 +1,63 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _AV_MEDIA_SERVICE_EXTENSIONS_H_
+#define _AV_MEDIA_SERVICE_EXTENSIONS_H_
+
+#include <common/AVExtensionsCommon.h>
+#include <MediaPlayerFactory.h>
+
+#include <utils/String16.h>
+
+namespace android {
+
+struct StagefrightRecorder;
+
+/*
+ * Factory to create objects of base-classes in libmediaplayerservice
+ */
+struct AVMediaServiceFactory {
+    virtual StagefrightRecorder *createStagefrightRecorder(const String16 &);
+
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVMediaServiceFactory);
+};
+
+/*
+ * Common delegate to the classes in libmediaplayerservice
+ */
+struct AVMediaServiceUtils {
+    virtual void getDashPlayerFactory(MediaPlayerFactory::IFactory *&, player_type ) {}
+
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVMediaServiceUtils);
+};
+
+}
+
+#endif // _AV_EXTENSIONS__H_
diff --git a/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp b/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp
new file mode 100644
index 0000000..abbeb99
--- /dev/null
+++ b/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "AVMediaServiceFactory"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+
+#include "MediaRecorderClient.h"
+#include "MediaPlayerService.h"
+#include "StagefrightRecorder.h"
+
+#include "common/ExtensionsLoader.hpp"
+#include "mediaplayerservice/AVMediaServiceExtensions.h"
+
+namespace android {
+StagefrightRecorder *AVMediaServiceFactory::createStagefrightRecorder(
+        const String16 &opPackageName) {
+    return new StagefrightRecorder(opPackageName);
+}
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVMediaServiceFactory::AVMediaServiceFactory() {
+}
+
+AVMediaServiceFactory::~AVMediaServiceFactory() {
+}
+
+//static
+AVMediaServiceFactory *AVMediaServiceFactory::sInst =
+        ExtensionsLoader<AVMediaServiceFactory>::createInstance("createExtendedMediaServiceFactory");
+
+} //namespace android
+
diff --git a/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp b/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp
new file mode 100644
index 0000000..3e8876b
--- /dev/null
+++ b/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp
@@ -0,0 +1,53 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "AVMediaServiceUtils"
+//#define LOG_NDEBUG 0
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+
+#include "common/ExtensionsLoader.hpp"
+#include "mediaplayerservice/AVMediaServiceExtensions.h"
+
+namespace android {
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVMediaServiceUtils::AVMediaServiceUtils() {
+}
+
+AVMediaServiceUtils::~AVMediaServiceUtils() {
+}
+
+//static
+AVMediaServiceUtils *AVMediaServiceUtils::sInst =
+        ExtensionsLoader<AVMediaServiceUtils>::createInstance("createExtendedMediaServiceUtils");
+
+} //namespace android
+
diff --git a/media/libavextensions/mediaplayerservice/AVNuExtensions.h b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
new file mode 100644
index 0000000..5312082
--- /dev/null
+++ b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
@@ -0,0 +1,68 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _AV_NU_EXTENSIONS_H_
+#define _AV_NU_EXTENSIONS_H_
+
+#include <common/AVExtensionsCommon.h>
+
+namespace android {
+
+struct NuPlayer;
+
+/*
+ * Factory to create extended NuPlayer objects
+ */
+struct AVNuFactory {
+    virtual sp<NuPlayer> createNuPlayer(pid_t pid);
+
+    virtual sp<NuPlayer::DecoderBase> createPassThruDecoder(
+            const sp<AMessage> &notify,
+            const sp<NuPlayer::Source> &source,
+            const sp<NuPlayer::Renderer> &renderer);
+
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVNuFactory);
+};
+
+/*
+ * Common delegate to the classes in NuPlayer
+ */
+struct AVNuUtils {
+    virtual bool isVorbisFormat(const sp<MetaData> &);
+
+    virtual void printFileName(int fd);
+    virtual bool dropCorruptFrame();
+
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVNuUtils);
+};
+
+}
+
+#endif // _AV_EXTENSIONS__H_
diff --git a/media/libavextensions/mediaplayerservice/AVNuFactory.cpp b/media/libavextensions/mediaplayerservice/AVNuFactory.cpp
new file mode 100644
index 0000000..b0ef986
--- /dev/null
+++ b/media/libavextensions/mediaplayerservice/AVNuFactory.cpp
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+//#define LOG_NDEBUG 0
+#define LOG_TAG "AVNuFactory"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+
+#include <nuplayer/NuPlayer.h>
+#include <nuplayer/NuPlayerDecoderBase.h>
+#include <nuplayer/NuPlayerDecoderPassThrough.h>
+#include <nuplayer/NuPlayerSource.h>
+#include <nuplayer/NuPlayerRenderer.h>
+
+#include "common/ExtensionsLoader.hpp"
+#include "mediaplayerservice/AVNuExtensions.h"
+
+namespace android {
+
+sp<NuPlayer> AVNuFactory::createNuPlayer(pid_t pid) {
+    return new NuPlayer(pid);
+}
+
+sp<NuPlayer::DecoderBase> AVNuFactory::createPassThruDecoder(
+            const sp<AMessage> &notify,
+            const sp<NuPlayer::Source> &source,
+            const sp<NuPlayer::Renderer> &renderer) {
+    return new NuPlayer::DecoderPassThrough(notify, source, renderer);
+}
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVNuFactory::AVNuFactory() {
+}
+
+AVNuFactory::~AVNuFactory() {
+}
+
+//static
+AVNuFactory *AVNuFactory::sInst =
+        ExtensionsLoader<AVNuFactory>::createInstance("createExtendedNuFactory");
+
+} //namespace android
+
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
new file mode 100644
index 0000000..744199d
--- /dev/null
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -0,0 +1,65 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "AVNuUtils"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+
+#include <nuplayer/NuPlayer.h>
+#include <nuplayer/NuPlayerDecoderBase.h>
+#include <nuplayer/NuPlayerDecoderPassThrough.h>
+#include <nuplayer/NuPlayerSource.h>
+#include <nuplayer/NuPlayerRenderer.h>
+
+#include "common/ExtensionsLoader.hpp"
+#include "mediaplayerservice/AVNuExtensions.h"
+
+namespace android {
+
+bool AVNuUtils::isVorbisFormat(const sp<MetaData> &) {
+    return false;
+}
+
+void AVNuUtils::printFileName(int) {}
+
+bool AVNuUtils::dropCorruptFrame() { return false; }
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVNuUtils::AVNuUtils() {}
+
+AVNuUtils::~AVNuUtils() {}
+
+//static
+AVNuUtils *AVNuUtils::sInst =
+        ExtensionsLoader<AVNuUtils>::createInstance("createExtendedNuUtils");
+
+} //namespace android
+
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
new file mode 100644
index 0000000..1b76da1
--- /dev/null
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef _AV_EXTENSIONS_H_
+#define _AV_EXTENSIONS_H_
+
+#include <media/stagefright/DataSource.h>
+#include <common/AVExtensionsCommon.h>
+#include <system/audio.h>
+#include <media/IOMX.h>
+#include <camera/android/hardware/ICamera.h>
+#include <media/mediarecorder.h>
+
+
+namespace android {
+
+struct ACodec;
+struct MediaCodec;
+struct ALooper;
+class MediaExtractor;
+class AudioParameter;
+class MetaData;
+class CameraParameters;
+class MediaBuffer;
+class CameraSource;
+class CameraSourceTimeLapse;
+class ICameraRecordingProxy;
+struct Size;
+class MPEG4Writer;
+struct AudioSource;
+
+/*
+ * Factory to create objects of base-classes in libstagefright
+ */
+struct AVFactory {
+    virtual sp<ACodec> createACodec();
+    virtual MediaExtractor* createExtendedExtractor(
+            const sp<DataSource> &source, const char *mime, const sp<AMessage> &meta);
+    virtual MediaExtractor* updateExtractor(
+            MediaExtractor* ext, const sp<DataSource> &source,
+            const char *mime, const sp<AMessage> &meta);
+
+    virtual CameraSource *CreateCameraSourceFromCamera(
+            const sp<hardware::ICamera> &camera,
+            const sp<ICameraRecordingProxy> &proxy,
+            int32_t cameraId,
+            const String16& clientName,
+            uid_t clientUid,
+            pid_t clientPid,
+            Size videoSize,
+            int32_t frameRate,
+            const sp<IGraphicBufferProducer>& surface,
+            bool storeMetaDataInVideoBuffers = true);
+
+    virtual CameraSourceTimeLapse *CreateCameraSourceTimeLapseFromCamera(
+            const sp<hardware::ICamera> &camera,
+            const sp<ICameraRecordingProxy> &proxy,
+            int32_t cameraId,
+            const String16& clientName,
+            uid_t clientUid,
+            pid_t clientPid,
+            Size videoSize,
+            int32_t videoFrameRate,
+            const sp<IGraphicBufferProducer>& surface,
+            int64_t timeBetweenFrameCaptureUs,
+            bool storeMetaDataInVideoBuffers = true);
+
+    virtual MPEG4Writer *CreateMPEG4Writer(int fd);
+
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVFactory);
+};
+
+/*
+ * Common delegate to the classes in libstagefright
+ */
+struct AVUtils {
+
+    virtual status_t convertMetaDataToMessage(
+            const sp<MetaData> &meta, sp<AMessage> *format);
+    virtual DataSource::SnifferFunc getExtendedSniffer();
+    virtual status_t mapMimeToAudioFormat( audio_format_t& format, const char* mime);
+    virtual status_t sendMetaDataToHal(const sp<MetaData>& meta, AudioParameter *param);
+    virtual sp<MediaCodec> createCustomComponentByName(const sp<ALooper> &looper,
+                const char* mime, bool encoder, const sp<AMessage> &format);
+    virtual bool isEnhancedExtension(const char *extension);
+
+    virtual int getAudioSampleBits(const sp<MetaData> &);
+    virtual int getAudioSampleBits(const sp<AMessage> &);
+    virtual audio_format_t updateAudioFormat(audio_format_t audioFormat,
+            const sp<MetaData> &);
+
+    virtual audio_format_t updateAudioFormat(audio_format_t audioFormat,
+            const sp<AMessage> &);
+    virtual bool canOffloadAPE(const sp<MetaData> &meta);
+    virtual bool useQCHWEncoder(const sp<AMessage> &,Vector<AString> *) { return false; }
+
+    virtual int32_t getAudioMaxInputBufferSize(audio_format_t audioFormat,
+            const sp<AMessage> &);
+
+    virtual bool mapAACProfileToAudioFormat(const sp<MetaData> &,
+            audio_format_t &,
+            uint64_t /*eAacProfile*/);
+
+    virtual bool mapAACProfileToAudioFormat(const sp<AMessage> &,
+            audio_format_t &,
+            uint64_t /*eAacProfile*/);
+
+    virtual void extractCustomCameraKeys(
+            const CameraParameters& /*params*/, sp<MetaData> &/*meta*/) {}
+    virtual void printFileName(int /*fd*/) {}
+    virtual void addDecodingTimesFromBatch(MediaBuffer * /*buf*/,
+            List<int64_t> &/*decodeTimeQueue*/) {}
+
+    virtual bool canDeferRelease(const sp<MetaData> &/*meta*/) { return false; }
+    virtual void setDeferRelease(sp<MetaData> &/*meta*/) {}
+
+    virtual bool isAudioMuxFormatSupported(const char *mime);
+    virtual void cacheCaptureBuffers(sp<hardware::ICamera> camera, video_encoder encoder);
+    virtual const char *getCustomCodecsLocation();
+    virtual const char *getCustomCodecsPerformanceLocation();
+
+    virtual void setIntraPeriod(
+                int nPFrames, int nBFrames, const sp<IOMX> OMXhandle,
+                IOMX::node_id nodeID);
+
+    // ----- NO TRESSPASSING BEYOND THIS LINE ------
+    DECLARE_LOADABLE_SINGLETON(AVUtils);
+};
+
+}
+
+#endif // _AV_EXTENSIONS__H_
diff --git a/media/libavextensions/stagefright/AVFactory.cpp b/media/libavextensions/stagefright/AVFactory.cpp
new file mode 100644
index 0000000..93fe413
--- /dev/null
+++ b/media/libavextensions/stagefright/AVFactory.cpp
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "AVFactory"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaCodecList.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/ACodec.h>
+#include <media/stagefright/DataSource.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaExtractor.h>
+#include <media/stagefright/CameraSourceTimeLapse.h>
+#include <media/stagefright/MPEG4Writer.h>
+
+#include "common/ExtensionsLoader.hpp"
+#include "stagefright/AVExtensions.h"
+
+namespace android {
+
+sp<ACodec> AVFactory::createACodec() {
+    return new ACodec;
+}
+
+MediaExtractor* AVFactory::createExtendedExtractor(
+         const sp<DataSource> &, const char *, const sp<AMessage> &) {
+    return NULL;
+}
+
+MediaExtractor* AVFactory::updateExtractor(
+         MediaExtractor* ext, const sp<DataSource> &,
+         const char *, const sp<AMessage> &) {
+    return ext;
+}
+
+CameraSource* AVFactory::CreateCameraSourceFromCamera(
+            const sp<hardware::ICamera> &camera,
+            const sp<ICameraRecordingProxy> &proxy,
+            int32_t cameraId,
+            const String16& clientName,
+            uid_t clientUid,
+            pid_t clientPid,
+            Size videoSize,
+            int32_t frameRate,
+            const sp<IGraphicBufferProducer>& surface,
+            bool storeMetaDataInVideoBuffers) {
+    return CameraSource::CreateFromCamera(camera, proxy, cameraId,
+            clientName, clientUid, clientPid, videoSize, frameRate, surface,
+            storeMetaDataInVideoBuffers);
+}
+
+CameraSourceTimeLapse* AVFactory::CreateCameraSourceTimeLapseFromCamera(
+        const sp<hardware::ICamera> &camera,
+        const sp<ICameraRecordingProxy> &proxy,
+        int32_t cameraId,
+        const String16& clientName,
+        uid_t clientUid,
+        pid_t clientPid,
+        Size videoSize,
+        int32_t videoFrameRate,
+        const sp<IGraphicBufferProducer>& surface,
+        int64_t timeBetweenFrameCaptureUs,
+        bool storeMetaDataInVideoBuffers) {
+    return CameraSourceTimeLapse::CreateFromCamera(camera, proxy, cameraId,
+            clientName, clientUid, clientPid, videoSize, videoFrameRate, surface,
+            timeBetweenFrameCaptureUs, storeMetaDataInVideoBuffers);
+}
+
+MPEG4Writer* AVFactory::CreateMPEG4Writer(int fd) {
+    return new MPEG4Writer(fd);
+}
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVFactory::AVFactory() {
+}
+
+AVFactory::~AVFactory() {
+}
+
+//static
+AVFactory *AVFactory::sInst =
+        ExtensionsLoader<AVFactory>::createInstance("createExtendedFactory");
+
+} //namespace android
+
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
new file mode 100644
index 0000000..edbec1f
--- /dev/null
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -0,0 +1,150 @@
+/*
+ * Copyright (c) 2013 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define LOG_TAG "AVUtils"
+#include <utils/Log.h>
+
+#include <media/stagefright/foundation/ADebug.h>
+#include <media/stagefright/foundation/AMessage.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/MediaDefs.h>
+#include <media/stagefright/MediaCodecList.h>
+#include <media/stagefright/MetaData.h>
+#include <media/stagefright/ACodec.h>
+#include <media/stagefright/MediaCodec.h>
+
+#include "common/ExtensionsLoader.hpp"
+#include "stagefright/AVExtensions.h"
+
+namespace android {
+
+status_t AVUtils::convertMetaDataToMessage(
+        const sp<MetaData> &, sp<AMessage> *) {
+    return OK;
+}
+
+status_t AVUtils::mapMimeToAudioFormat(
+        audio_format_t&, const char* ) {
+    return OK;
+}
+
+status_t AVUtils::sendMetaDataToHal(
+        const sp<MetaData>&, AudioParameter *){
+    return OK;
+}
+
+
+int AVUtils::getAudioSampleBits(const sp<MetaData> &) {
+    return 16;
+}
+
+int AVUtils::getAudioSampleBits(const sp<AMessage> &) {
+    return 16;
+}
+
+audio_format_t AVUtils::updateAudioFormat(audio_format_t audioFormat,
+        const sp<MetaData> &){
+    return audioFormat;
+}
+
+audio_format_t AVUtils::updateAudioFormat(audio_format_t audioFormat,
+        const sp<AMessage> &){
+    return audioFormat;
+}
+
+static bool dumbSniffer(
+        const sp<DataSource> &, String8 *,
+        float *, sp<AMessage> *) {
+    return false;
+}
+
+DataSource::SnifferFunc AVUtils::getExtendedSniffer() {
+    return dumbSniffer;
+}
+
+sp<MediaCodec> AVUtils::createCustomComponentByName(
+           const sp<ALooper> &, const char* , bool, const sp<AMessage> &) {
+               return NULL;
+}
+
+int32_t AVUtils::getAudioMaxInputBufferSize(audio_format_t, const sp<AMessage> &) {
+    return 0;
+}
+
+bool AVUtils::mapAACProfileToAudioFormat(const sp<MetaData> &, audio_format_t &,
+                 uint64_t  /*eAacProfile*/) {
+    return false ;
+}
+
+bool AVUtils::mapAACProfileToAudioFormat(const sp<AMessage> &,  audio_format_t &,
+                 uint64_t  /*eAacProfile*/) {
+    return false ;
+}
+
+bool AVUtils::canOffloadAPE(const sp<MetaData> &) {
+   return true;
+}
+
+bool AVUtils::isEnhancedExtension(const char *) {
+    return false;
+}
+
+bool AVUtils::isAudioMuxFormatSupported(const char *) {
+    return true;
+}
+
+void AVUtils::cacheCaptureBuffers(sp<hardware::ICamera>, video_encoder) {
+    return;
+}
+
+const char *AVUtils::getCustomCodecsLocation() {
+    return "/etc/media_codecs.xml";
+}
+
+void AVUtils::setIntraPeriod(
+        int, int, const sp<IOMX>,
+        IOMX::node_id) {
+    return;
+}
+
+const char *AVUtils::getCustomCodecsPerformanceLocation() {
+    return "/etc/media_codecs_performance.xml";
+}
+
+// ----- NO TRESSPASSING BEYOND THIS LINE ------
+AVUtils::AVUtils() {}
+
+AVUtils::~AVUtils() {}
+
+//static
+AVUtils *AVUtils::sInst =
+        ExtensionsLoader<AVUtils>::createInstance("createExtendedUtils");
+
+} //namespace android
+
diff --git a/media/libavextensions/stagefright/ExtendedMediaDefs.cpp b/media/libavextensions/stagefright/ExtendedMediaDefs.cpp
new file mode 100644
index 0000000..5ff1178
--- /dev/null
+++ b/media/libavextensions/stagefright/ExtendedMediaDefs.cpp
@@ -0,0 +1,68 @@
+/*Copyright (c) 2012 - 2016, The Linux Foundation. All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are
+ * met:
+ *     * Redistributions of source code must retain the above copyright
+ *      notice, this list of conditions and the following disclaimer.
+ *     * Redistributions in binary form must reproduce the above
+ *       copyright notice, this list of conditions and the following
+ *       disclaimer in the documentation and/or other materials provided
+ *      with the distribution.
+ *     * Neither the name of The Linux Foundation nor the names of its
+ *      contributors may be used to endorse or promote products derived
+ *       from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
+ * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
+ * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE
+ * OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN
+ * IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+ *
+ */
+
+#include <stagefright/ExtendedMediaDefs.h>
+
+namespace android {
+
+const char *MEDIA_MIMETYPE_AUDIO_EVRC = "audio/evrc";
+const char *MEDIA_MIMETYPE_VIDEO_WMV = "video/x-ms-wmv";
+const char *MEDIA_MIMETYPE_VIDEO_WMV_VC1 = "video/wvc1";
+const char *MEDIA_MIMETYPE_AUDIO_WMA = "audio/x-ms-wma";
+const char *MEDIA_MIMETYPE_AUDIO_WMA_PRO = "audio/x-ms-wma-pro";
+const char *MEDIA_MIMETYPE_AUDIO_WMA_LOSSLESS = "audio/x-ms-wma-lossless";
+const char *MEDIA_MIMETYPE_CONTAINER_ASF = "video/x-ms-asf";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX = "video/divx";
+const char *MEDIA_MIMETYPE_CONTAINER_AAC = "audio/aac";
+const char *MEDIA_MIMETYPE_CONTAINER_QCP = "audio/vnd.qcelp";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX311 = "video/divx311";
+const char *MEDIA_MIMETYPE_VIDEO_DIVX4 = "video/divx4";
+const char *MEDIA_MIMETYPE_CONTAINER_MPEG2 = "video/mp2";
+const char *MEDIA_MIMETYPE_CONTAINER_3G2 = "video/3g2";
+const char *MEDIA_MIMETYPE_AUDIO_DTS = "audio/dts";
+const char *MEDIA_MIMETYPE_AUDIO_DTS_LBR = "audio/dts-lbr";
+const char *MEDIA_MIMETYPE_AUDIO_AMR_WB_PLUS = "audio/amr-wb-plus";
+const char *MEDIA_MIMETYPE_AUDIO_AIFF = "audio/x-aiff";
+const char *MEDIA_MIMETYPE_AUDIO_ALAC = "audio/alac";
+const char *MEDIA_MIMETYPE_AUDIO_APE = "audio/x-ape";
+const char *MEDIA_MIMETYPE_CONTAINER_QCAMR_NB = "audio/qc-amr";
+const char *MEDIA_MIMETYPE_CONTAINER_QCAMR_WB = "audio/qc-amr-wb";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG = "audio/qc-mpeg";
+const char *MEDIA_MIMETYPE_CONTAINER_QCWAV = "audio/qc-wav";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG2TS = "video/qc-mp2ts";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG2PS = "video/qc-mp2ps";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMPEG4 = "video/qc-mp4";
+const char *MEDIA_MIMETYPE_CONTAINER_QCMATROSKA = "video/qc-matroska";
+const char *MEDIA_MIMETYPE_CONTAINER_QCOGG = "video/qc-ogg";
+const char *MEDIA_MIMETYPE_CONTAINER_QCFLV = "video/qc-flv";
+const char *MEDIA_MIMETYPE_VIDEO_VPX = "video/x-vnd.on2.vp8"; //backward compatibility
+const char *MEDIA_MIMETYPE_CONTAINER_QTIFLAC = "audio/qti-flac";
+const char *MEDIA_MIMETYPE_VIDEO_MPEG4_DP = "video/mp4v-esdp";
+
+}  // namespace android
diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index 2bdfd43..df4e4b6 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -80,7 +80,7 @@ LOCAL_SHARED_LIBRARIES := \
         libcamera_client libstagefright_foundation \
         libgui libdl libaudioutils libnbaio
 
-LOCAL_WHOLE_STATIC_LIBRARIES := libmedia_helper
+LOCAL_WHOLE_STATIC_LIBRARIES := libmedia_helper libavmediaextentions
 
 # for memory heap analysis
 LOCAL_STATIC_LIBRARIES := libc_malloc_debug_backtrace libc_logging
@@ -93,6 +93,7 @@ LOCAL_C_INCLUDES := \
     $(TOP)/frameworks/native/include/media/openmax \
     $(TOP)/frameworks/av/include/media/ \
     $(TOP)/frameworks/av/media/libstagefright \
+    $(TOP)/frameworks/av/media/libavextensions \
     $(call include-path-for, audio-effects) \
     $(call include-path-for, audio-utils)
 
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 7663fef..ee0c509 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -30,6 +30,7 @@
 #include <media/IAudioFlinger.h>
 #include <media/AudioPolicyHelper.h>
 #include <media/AudioResamplerPublic.h>
+#include "media/AVMediaExtensions.h"
 
 #define WAIT_PERIOD_MS                  10
 #define WAIT_STREAM_END_TIMEOUT_SEC     120
@@ -1315,6 +1316,7 @@ status_t AudioTrack::createTrack_l()
             frameCount = mSharedBuffer->size();
         } else if (frameCount == 0) {
             frameCount = mAfFrameCount;
+            frameCount = AVMediaUtils::get()->AudioTrackGetOffloadFrameCount(frameCount);
         }
         if (mNotificationFramesAct != frameCount) {
             mNotificationFramesAct = frameCount;
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 8d86366..499b965 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -43,6 +43,9 @@ LOCAL_STATIC_LIBRARIES :=       \
     libstagefright_rtsp         \
     libstagefright_timedtext    \
 
+LOCAL_WHOLE_STATIC_LIBRARIES := \
+    libavmediaserviceextensions \
+
 LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/av/media/libstagefright/include               \
     $(TOP)/frameworks/av/media/libstagefright/rtsp                  \
@@ -54,13 +57,14 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/native/include/media/hardware                 \
     $(TOP)/external/tremolo/Tremolo                                 \
     libcore/include                                                 \
+    $(TOP)/frameworks/av/media/libavextensions                      \
 
 LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
 LOCAL_CLANG := true
 
 LOCAL_MODULE:= libmediaplayerservice
 
-LOCAL_32_BIT_ONLY := true
+#LOCAL_32_BIT_ONLY := true
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/media/libmediaplayerservice/MediaPlayerFactory.cpp b/media/libmediaplayerservice/MediaPlayerFactory.cpp
index 605c710..864dce2 100644
--- a/media/libmediaplayerservice/MediaPlayerFactory.cpp
+++ b/media/libmediaplayerservice/MediaPlayerFactory.cpp
@@ -32,6 +32,7 @@
 
 #include "TestPlayerStub.h"
 #include "nuplayer/NuPlayerDriver.h"
+#include <mediaplayerservice/AVMediaServiceExtensions.h>
 
 namespace android {
 
@@ -241,6 +242,8 @@ class TestPlayerFactory : public MediaPlayerFactory::IFactory {
 };
 
 void MediaPlayerFactory::registerBuiltinFactories() {
+
+    MediaPlayerFactory::IFactory* pCustomFactory = NULL;
     Mutex::Autolock lock_(&sLock);
 
     if (sInitComplete)
@@ -248,6 +251,11 @@ void MediaPlayerFactory::registerBuiltinFactories() {
 
     registerFactory_l(new NuPlayerFactory(), NU_PLAYER);
     registerFactory_l(new TestPlayerFactory(), TEST_PLAYER);
+    AVMediaServiceUtils::get()->getDashPlayerFactory(pCustomFactory, DASH_PLAYER);
+    if(pCustomFactory != NULL) {
+        ALOGV("Registering DASH_PLAYER");
+        registerFactory_l(pCustomFactory, DASH_PLAYER);
+    }
 
     sInitComplete = true;
 }
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index bd16e91..921eb3d 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -21,6 +21,7 @@
 #define LOG_TAG "MediaPlayerService"
 #include <utils/Log.h>
 
+#include <inttypes.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <sys/time.h>
@@ -770,8 +771,7 @@ status_t MediaPlayerService::Client::setDataSource(
 
 status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64_t length)
 {
-    ALOGV("setDataSource fd=%d (%s), offset=%lld, length=%lld",
-            fd, nameForFd(fd).c_str(), (long long) offset, (long long) length);
+    ALOGV("setDataSource fd=%d, offset=%" PRId64 ", length=%" PRId64 "", fd, offset, length);
     struct stat sb;
     int ret = fstat(fd, &sb);
     if (ret != 0) {
@@ -779,11 +779,11 @@ status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64
         return UNKNOWN_ERROR;
     }
 
-    ALOGV("st_dev  = %llu", static_cast<unsigned long long>(sb.st_dev));
+    ALOGV("st_dev  = %" PRIu64 "", static_cast<uint64_t>(sb.st_dev));
     ALOGV("st_mode = %u", sb.st_mode);
     ALOGV("st_uid  = %lu", static_cast<unsigned long>(sb.st_uid));
     ALOGV("st_gid  = %lu", static_cast<unsigned long>(sb.st_gid));
-    ALOGV("st_size = %llu", static_cast<unsigned long long>(sb.st_size));
+    ALOGV("st_size = %" PRId64 "", sb.st_size);
 
     if (offset >= sb.st_size) {
         ALOGE("offset error");
@@ -791,7 +791,7 @@ status_t MediaPlayerService::Client::setDataSource(int fd, int64_t offset, int64
     }
     if (offset + length > sb.st_size) {
         length = sb.st_size - offset;
-        ALOGV("calculated length = %lld", (long long)length);
+        ALOGV("calculated length = %" PRId64 "\n", length);
     }
 
     player_type playerType = MediaPlayerFactory::getPlayerType(this,
diff --git a/media/libmediaplayerservice/MediaRecorderClient.cpp b/media/libmediaplayerservice/MediaRecorderClient.cpp
index d011d70..7ba3b97 100644
--- a/media/libmediaplayerservice/MediaRecorderClient.cpp
+++ b/media/libmediaplayerservice/MediaRecorderClient.cpp
@@ -18,6 +18,7 @@
 #define LOG_TAG "MediaRecorderService"
 #include <utils/Log.h>
 
+#include <inttypes.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -39,6 +40,7 @@
 
 #include "StagefrightRecorder.h"
 #include <gui/IGraphicBufferProducer.h>
+#include "mediaplayerservice/AVMediaServiceExtensions.h"
 
 namespace android {
 
@@ -163,7 +165,7 @@ status_t MediaRecorderClient::setAudioEncoder(int ae)
 
 status_t MediaRecorderClient::setOutputFile(int fd, int64_t offset, int64_t length)
 {
-    ALOGV("setOutputFile(%d, %lld, %lld)", fd, (long long)offset, (long long)length);
+    ALOGV("setOutputFile(%d, %" PRId64 ", %" PRId64 ")", fd, offset, length);
     Mutex::Autolock lock(mLock);
     if (mRecorder == NULL) {
         ALOGE("recorder is not initialized");
@@ -325,7 +327,7 @@ MediaRecorderClient::MediaRecorderClient(const sp<MediaPlayerService>& service,
 {
     ALOGV("Client constructor");
     mPid = pid;
-    mRecorder = new StagefrightRecorder(opPackageName);
+    mRecorder = AVMediaServiceFactory::get()->createStagefrightRecorder(opPackageName);
     mMediaPlayerService = service;
 }
 
diff --git a/media/libmediaplayerservice/MetadataRetrieverClient.cpp b/media/libmediaplayerservice/MetadataRetrieverClient.cpp
index 793f476..9d634ec 100644
--- a/media/libmediaplayerservice/MetadataRetrieverClient.cpp
+++ b/media/libmediaplayerservice/MetadataRetrieverClient.cpp
@@ -19,6 +19,7 @@
 #define LOG_TAG "MetadataRetrieverClient"
 #include <utils/Log.h>
 
+#include <inttypes.h>
 #include <sys/types.h>
 #include <sys/stat.h>
 #include <dirent.h>
@@ -134,8 +135,7 @@ status_t MetadataRetrieverClient::setDataSource(
 
 status_t MetadataRetrieverClient::setDataSource(int fd, int64_t offset, int64_t length)
 {
-    ALOGV("setDataSource fd=%d (%s), offset=%lld, length=%lld",
-            fd, nameForFd(fd).c_str(), (long long) offset, (long long) length);
+    ALOGV("setDataSource fd=%d, offset=%" PRId64 ", length=%" PRId64 "", fd, offset, length);
     Mutex::Autolock lock(mLock);
     struct stat sb;
     int ret = fstat(fd, &sb);
@@ -143,20 +143,19 @@ status_t MetadataRetrieverClient::setDataSource(int fd, int64_t offset, int64_t
         ALOGE("fstat(%d) failed: %d, %s", fd, ret, strerror(errno));
         return BAD_VALUE;
     }
-    ALOGV("st_dev  = %llu", static_cast<unsigned long long>(sb.st_dev));
+    ALOGV("st_dev  = %" PRIu64 "", static_cast<uint64_t>(sb.st_dev));
     ALOGV("st_mode = %u", sb.st_mode);
     ALOGV("st_uid  = %lu", static_cast<unsigned long>(sb.st_uid));
     ALOGV("st_gid  = %lu", static_cast<unsigned long>(sb.st_gid));
-    ALOGV("st_size = %llu", static_cast<unsigned long long>(sb.st_size));
+    ALOGV("st_size = %" PRIu64 "", sb.st_size);
 
     if (offset >= sb.st_size) {
-        ALOGE("offset (%lld) bigger than file size (%llu)",
-                (long long)offset, (unsigned long long)sb.st_size);
+        ALOGE("offset (%" PRId64 ") bigger than file size (%" PRIu64 ")", offset, sb.st_size);
         return BAD_VALUE;
     }
     if (offset + length > sb.st_size) {
         length = sb.st_size - offset;
-        ALOGV("calculated length = %lld", (long long)length);
+        ALOGV("calculated length = %" PRId64 "", length);
     }
 
     player_type playerType =
@@ -195,7 +194,7 @@ Mutex MetadataRetrieverClient::sLock;
 
 sp<IMemory> MetadataRetrieverClient::getFrameAtTime(int64_t timeUs, int option)
 {
-    ALOGV("getFrameAtTime: time(%lld us) option(%d)", (long long)timeUs, option);
+    ALOGV("getFrameAtTime: time(%" PRId64 " us) option(%d)", timeUs, option);
     Mutex::Autolock lock(mLock);
     Mutex::Autolock glock(sLock);
     mThumbnail.clear();
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index d9bcf56..6490d4d 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -19,6 +19,7 @@
 #include <inttypes.h>
 #include <utils/Log.h>
 
+#include <inttypes.h>
 #include "WebmWriter.h"
 #include "StagefrightRecorder.h"
 
@@ -56,6 +57,7 @@
 #include <system/audio.h>
 
 #include "ARTPWriter.h"
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -255,7 +257,7 @@ status_t StagefrightRecorder::setInputSurface(
 }
 
 status_t StagefrightRecorder::setOutputFile(int fd, int64_t offset, int64_t length) {
-    ALOGV("setOutputFile: %d, %lld, %lld", fd, (long long)offset, (long long)length);
+    ALOGV("setOutputFile: %d, %" PRId64 ", %" PRId64 "", fd, offset, length);
     // These don't make any sense, do they?
     CHECK_EQ(offset, 0ll);
     CHECK_EQ(length, 0ll);
@@ -422,40 +424,39 @@ status_t StagefrightRecorder::setParamVideoRotation(int32_t degrees) {
 }
 
 status_t StagefrightRecorder::setParamMaxFileDurationUs(int64_t timeUs) {
-    ALOGV("setParamMaxFileDurationUs: %lld us", (long long)timeUs);
+    ALOGV("setParamMaxFileDurationUs: %" PRId64 " us", timeUs);
 
     // This is meant for backward compatibility for MediaRecorder.java
     if (timeUs <= 0) {
-        ALOGW("Max file duration is not positive: %lld us. Disabling duration limit.",
-                (long long)timeUs);
+        ALOGW("Max file duration is not positive: %" PRId64 " us. Disabling duration limit.", timeUs);
         timeUs = 0; // Disable the duration limit for zero or negative values.
     } else if (timeUs <= 100000LL) {  // XXX: 100 milli-seconds
-        ALOGE("Max file duration is too short: %lld us", (long long)timeUs);
+        ALOGE("Max file duration is too short: %" PRId64 " us", timeUs);
         return BAD_VALUE;
     }
 
     if (timeUs <= 15 * 1000000LL) {
-        ALOGW("Target duration (%lld us) too short to be respected", (long long)timeUs);
+        ALOGW("Target duration (%" PRId64 " us) too short to be respected", timeUs);
     }
     mMaxFileDurationUs = timeUs;
     return OK;
 }
 
 status_t StagefrightRecorder::setParamMaxFileSizeBytes(int64_t bytes) {
-    ALOGV("setParamMaxFileSizeBytes: %lld bytes", (long long)bytes);
+    ALOGV("setParamMaxFileSizeBytes: %" PRId64 " bytes", bytes);
 
     // This is meant for backward compatibility for MediaRecorder.java
     if (bytes <= 0) {
-        ALOGW("Max file size is not positive: %lld bytes. "
-             "Disabling file size limit.", (long long)bytes);
+        ALOGW("Max file size is not positive: %" PRId64 " bytes. "
+             "Disabling file size limit.", bytes);
         bytes = 0; // Disable the file size limit for zero or negative values.
     } else if (bytes <= 1024) {  // XXX: 1 kB
-        ALOGE("Max file size is too small: %lld bytes", (long long)bytes);
+        ALOGE("Max file size is too small: %" PRId64 " bytes", bytes);
         return BAD_VALUE;
     }
 
     if (bytes <= 100 * 1024) {
-        ALOGW("Target file size (%lld bytes) is too small to be respected", (long long)bytes);
+        ALOGW("Target file size (%" PRId64 " bytes) is too small to be respected", bytes);
     }
 
     mMaxFileSizeBytes = bytes;
@@ -507,9 +508,9 @@ status_t StagefrightRecorder::setParamVideoCameraId(int32_t cameraId) {
 }
 
 status_t StagefrightRecorder::setParamTrackTimeStatus(int64_t timeDurationUs) {
-    ALOGV("setParamTrackTimeStatus: %lld", (long long)timeDurationUs);
+    ALOGV("setParamTrackTimeStatus: %" PRId64 "", timeDurationUs);
     if (timeDurationUs < 20000) {  // Infeasible if shorter than 20 ms?
-        ALOGE("Tracking time duration too short: %lld us", (long long)timeDurationUs);
+        ALOGE("Tracking time duration too short: %" PRId64 " us", timeDurationUs);
         return BAD_VALUE;
     }
     mTrackEveryTimeDurationUs = timeDurationUs;
@@ -592,7 +593,7 @@ status_t StagefrightRecorder::setParamCaptureFps(float fps) {
 
     // Not allowing time more than a day
     if (timeUs <= 0 || timeUs > 86400*1E6) {
-        ALOGE("Time between frame capture (%lld) is out of range [0, 1 Day]", (long long)timeUs);
+        ALOGE("Time between frame capture (%" PRId64 ") is out of range [0, 1 Day]", timeUs);
         return BAD_VALUE;
     }
 
@@ -1451,22 +1452,23 @@ status_t StagefrightRecorder::setupCameraSource(
     videoSize.height = mVideoHeight;
     if (mCaptureFpsEnable) {
         if (mTimeBetweenCaptureUs < 0) {
-            ALOGE("Invalid mTimeBetweenTimeLapseFrameCaptureUs value: %lld",
-                    (long long)mTimeBetweenCaptureUs);
+            ALOGE("Invalid mTimeBetweenTimeLapseFrameCaptureUs value: %" PRId64 "",
+                mTimeBetweenCaptureUs);
             return BAD_VALUE;
         }
 
-        mCameraSourceTimeLapse = CameraSourceTimeLapse::CreateFromCamera(
+        mCameraSourceTimeLapse = AVFactory::get()->CreateCameraSourceTimeLapseFromCamera(
                 mCamera, mCameraProxy, mCameraId, mClientName, mClientUid, mClientPid,
                 videoSize, mFrameRate, mPreviewSurface,
                 mTimeBetweenCaptureUs);
         *cameraSource = mCameraSourceTimeLapse;
     } else {
-        *cameraSource = CameraSource::CreateFromCamera(
+        *cameraSource = AVFactory::get()->CreateCameraSourceFromCamera(
                 mCamera, mCameraProxy, mCameraId, mClientName, mClientUid, mClientPid,
                 videoSize, mFrameRate,
                 mPreviewSurface);
     }
+    AVUtils::get()->cacheCaptureBuffers(mCamera, mVideoEncoder);
     mCamera.clear();
     mCameraProxy.clear();
     if (*cameraSource == NULL) {
@@ -1556,14 +1558,16 @@ status_t StagefrightRecorder::setupVideoEncoder(
         // set up time lapse/slow motion for surface source
         if (mCaptureFpsEnable) {
             if (mTimeBetweenCaptureUs <= 0) {
-                ALOGE("Invalid mTimeBetweenCaptureUs value: %lld",
-                        (long long)mTimeBetweenCaptureUs);
+                ALOGE("Invalid mTimeBetweenCaptureUs value: %" PRId64 "",
+                        mTimeBetweenCaptureUs);
                 return BAD_VALUE;
             }
             format->setInt64("time-lapse", mTimeBetweenCaptureUs);
         }
     }
 
+    setupCustomVideoEncoderParams(cameraSource, format);
+
     format->setInt32("bitrate", mVideoBitRate);
     format->setInt32("frame-rate", mFrameRate);
     format->setInt32("i-frame-interval", mIFramesIntervalSec);
@@ -1693,7 +1697,7 @@ status_t StagefrightRecorder::setupMPEG4orWEBMRecording() {
     if (mOutputFormat == OUTPUT_FORMAT_WEBM) {
         writer = new WebmWriter(mOutputFd);
     } else {
-        writer = mp4writer = new MPEG4Writer(mOutputFd);
+        writer = mp4writer = AVFactory::get()->CreateMPEG4Writer(mOutputFd);
     }
 
     if (mVideoSource < VIDEO_SOURCE_LIST_END) {
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 4ed8e66..063eade 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -42,6 +42,7 @@ class IGraphicBufferConsumer;
 class IGraphicBufferProducer;
 class SurfaceMediaSource;
 struct ALooper;
+struct AMessage;
 
 struct StagefrightRecorder : public MediaRecorderBase {
     StagefrightRecorder(const String16 &opPackageName);
@@ -74,7 +75,7 @@ struct StagefrightRecorder : public MediaRecorderBase {
     // Querying a SurfaceMediaSourcer
     virtual sp<IGraphicBufferProducer> querySurfaceMediaSource() const;
 
-private:
+protected:
     sp<hardware::ICamera> mCamera;
     sp<ICameraRecordingProxy> mCameraProxy;
     sp<IGraphicBufferProducer> mPreviewSurface;
@@ -141,7 +142,7 @@ private:
 
     static const int kMaxHighSpeedFps = 1000;
 
-    status_t prepareInternal();
+    virtual status_t prepareInternal();
     status_t setupMPEG4orWEBMRecording();
     void setupMPEG4orWEBMMetaData(sp<MetaData> *meta);
     status_t setupAMRRecording();
@@ -159,6 +160,8 @@ private:
     status_t setupCameraSource(sp<CameraSource> *cameraSource);
     status_t setupAudioEncoder(const sp<MediaWriter>& writer);
     status_t setupVideoEncoder(sp<MediaSource> cameraSource, sp<MediaCodecSource> *source);
+    virtual void setupCustomVideoEncoderParams(sp<MediaSource> /*cameraSource*/,
+            sp<AMessage> &/*format*/) {}
 
     // Encoding parameter handling utilities
     status_t setParameter(const String8 &key, const String8 &value);
diff --git a/media/libmediaplayerservice/nuplayer/Android.mk b/media/libmediaplayerservice/nuplayer/Android.mk
index cd20837..005cb4b 100644
--- a/media/libmediaplayerservice/nuplayer/Android.mk
+++ b/media/libmediaplayerservice/nuplayer/Android.mk
@@ -23,7 +23,8 @@ LOCAL_C_INCLUDES := \
 	$(TOP)/frameworks/av/media/libstagefright/rtsp                \
 	$(TOP)/frameworks/av/media/libstagefright/timedtext           \
 	$(TOP)/frameworks/av/media/libmediaplayerservice              \
-	$(TOP)/frameworks/native/include/media/openmax
+	$(TOP)/frameworks/native/include/media/openmax                \
+        $(TOP)/frameworks/av/media/libavextensions                    \
 
 LOCAL_CFLAGS += -Werror -Wall
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index dc4e5d4..89301d0 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -56,6 +56,7 @@
 
 #include "ESDS.h"
 #include <media/stagefright/Utils.h>
+#include "mediaplayerservice/AVNuExtensions.h"
 
 namespace android {
 
@@ -1636,7 +1637,7 @@ status_t NuPlayer::instantiateDecoder(
 
             const bool hasVideo = (mSource->getFormat(false /*audio */) != NULL);
             format->setInt32("has-video", hasVideo);
-            *decoder = new DecoderPassThrough(notify, mSource, mRenderer);
+            *decoder = AVNuFactory::get()->createPassThruDecoder(notify, mSource, mRenderer);
         } else {
             mSource->setOffloadAudio(false /* offload */);
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index ae17c76..ffd7e86 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -86,12 +86,14 @@ protected:
     virtual ~NuPlayer();
 
     virtual void onMessageReceived(const sp<AMessage> &msg);
-
+    virtual bool ifDecodedPCMOffload() {return false;}
+    virtual void setDecodedPcmOffload(bool /*decodePcmOffload*/) {}
+    virtual bool canOffloadDecodedPCMStream(const sp<MetaData> /*meta*/,
+            bool /*hasVideo*/, bool /*isStreaming*/, audio_stream_type_t /*streamType*/) {return false;}
 public:
     struct NuPlayerStreamListener;
     struct Source;
 
-private:
     struct Decoder;
     struct DecoderBase;
     struct DecoderPassThrough;
@@ -109,6 +111,7 @@ private:
     struct PostMessageAction;
     struct SimpleAction;
 
+protected:
     enum {
         kWhatSetDataSource              = '=DaS',
         kWhatPrepare                    = 'prep',
@@ -231,7 +234,7 @@ private:
             int64_t currentPositionUs, bool forceNonOffload, bool needsToCreateAudioDecoder);
     void determineAudioModeChange(const sp<AMessage> &audioFormat);
 
-    status_t instantiateDecoder(
+    virtual status_t instantiateDecoder(
             bool audio, sp<DecoderBase> *decoder, bool checkAudioModeChange = true);
 
     status_t onInstantiateSecureDecoders();
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index 594128c..c2adabf 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -36,6 +36,8 @@
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MediaErrors.h>
 
+#include <stagefright/AVExtensions.h>
+#include "mediaplayerservice/AVNuExtensions.h"
 #include <gui/Surface.h>
 
 #include "avc_utils.h"
@@ -264,8 +266,11 @@ void NuPlayer::Decoder::onConfigure(const sp<AMessage> &format) {
     mComponentName.append(" decoder");
     ALOGV("[%s] onConfigure (surface=%p)", mComponentName.c_str(), mSurface.get());
 
+    mCodec = AVUtils::get()->createCustomComponentByName(mCodecLooper, mime.c_str(), false /* encoder */, format);
+    if (mCodec == NULL) {
     mCodec = MediaCodec::CreateByType(
             mCodecLooper, mime.c_str(), false /* encoder */, NULL /* err */, mPid);
+    }
     int32_t secure = 0;
     if (format->findInt32("secure", &secure) && secure != 0) {
         if (mCodec != NULL) {
@@ -665,6 +670,12 @@ bool NuPlayer::Decoder::handleAnOutputBuffer(
         }
 
         mSkipRenderingUntilMediaTimeUs = -1;
+    } else if ((flags & MediaCodec::BUFFER_FLAG_DATACORRUPT) &&
+            AVNuUtils::get()->dropCorruptFrame()) {
+        ALOGV("[%s] dropping corrupt buffer at time %lld as requested.",
+                     mComponentName.c_str(), (long long)timeUs);
+        reply->post();
+        return true;
     }
 
     mNumFramesTotal += !mIsAudio;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
index 0c619ed..aedbcc9 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
@@ -50,7 +50,6 @@ protected:
     virtual void onShutdown(bool notifyComplete);
     virtual bool doRequestBuffers();
 
-private:
     enum {
         kWhatCodecNotify         = 'cdcN',
         kWhatRenderBuffer        = 'rndr',
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
index f224635..50f914f 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
@@ -34,18 +34,17 @@
 
 namespace android {
 
-// TODO optimize buffer size for power consumption
-// The offload read buffer size is 32 KB but 24 KB uses less power.
-static const size_t kAggregateBufferSizeBytes = 24 * 1024;
 static const size_t kMaxCachedBytes = 200000;
-
 NuPlayer::DecoderPassThrough::DecoderPassThrough(
         const sp<AMessage> &notify,
         const sp<Source> &source,
         const sp<Renderer> &renderer)
     : DecoderBase(notify),
+      mAggregateBufferSizeBytes(24 * 1024),
       mSource(source),
       mRenderer(renderer),
+      // TODO optimize buffer size for power consumption
+      // The offload read buffer size is 32 KB but 24 KB uses less power.
       mSkipRenderingUntilMediaTimeUs(-1ll),
       mReachedEOS(true),
       mPendingAudioErr(OK),
@@ -172,9 +171,9 @@ sp<ABuffer> NuPlayer::DecoderPassThrough::aggregateBuffer(
     size_t smallSize = accessUnit->size();
     if ((mAggregateBuffer == NULL)
             // Don't bother if only room for a few small buffers.
-            && (smallSize < (kAggregateBufferSizeBytes / 3))) {
+            && (smallSize < (mAggregateBufferSizeBytes / 3))) {
         // Create a larger buffer for combining smaller buffers from the extractor.
-        mAggregateBuffer = new ABuffer(kAggregateBufferSizeBytes);
+        mAggregateBuffer = new ABuffer(mAggregateBufferSizeBytes);
         mAggregateBuffer->setRange(0, 0); // start empty
     }
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
index 5850efa..be888c3 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.h
@@ -43,8 +43,10 @@ protected:
     virtual void onFlush();
     virtual void onShutdown(bool notifyComplete);
     virtual bool doRequestBuffers();
+    virtual sp<ABuffer> aggregateBuffer(const sp<ABuffer> &accessUnit);
+
+    size_t mAggregateBufferSizeBytes;
 
-private:
     enum {
         kWhatBufferConsumed     = 'bufC',
     };
@@ -60,7 +62,7 @@ private:
     sp<ABuffer> mPendingAudioAccessUnit;
     status_t    mPendingAudioErr;
     sp<ABuffer> mAggregateBuffer;
-
+private:
     // mPendingBuffersToDrain are only for debugging. It can be removed
     // when the power investigation is done.
     size_t  mPendingBuffersToDrain;
@@ -71,7 +73,6 @@ private:
     bool isDoneFetching() const;
 
     status_t dequeueAccessUnit(sp<ABuffer> *accessUnit);
-    sp<ABuffer> aggregateBuffer(const sp<ABuffer> &accessUnit);
     status_t fetchInputData(sp<AMessage> &reply);
     void doFlush(bool notifyComplete);
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
index 0f4dce9..e1d5ee8 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
@@ -31,6 +31,8 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
 
+#include "mediaplayerservice/AVNuExtensions.h"
+
 namespace android {
 
 NuPlayerDriver::NuPlayerDriver(pid_t pid)
@@ -54,7 +56,7 @@ NuPlayerDriver::NuPlayerDriver(pid_t pid)
             true,  /* canCallJava */
             PRIORITY_AUDIO);
 
-    mPlayer = new NuPlayer(pid);
+    mPlayer = AVNuFactory::get()->createNuPlayer(pid);
     mLooper->registerHandler(mPlayer);
 
     mPlayer->setDriver(this);
@@ -113,6 +115,7 @@ status_t NuPlayerDriver::setDataSource(int fd, int64_t offset, int64_t length) {
         mCondition.wait(mLock);
     }
 
+    AVNuUtils::get()->printFileName(fd);
     return mAsyncResult;
 }
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index b742762..20670ee 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -34,6 +34,7 @@
 
 #include <inttypes.h>
 
+#include "stagefright/AVExtensions.h"
 namespace android {
 
 /*
@@ -1798,9 +1799,12 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
                     "audio_format", mime.c_str());
             onDisableOffloadAudio();
         } else {
+            int32_t bitWidth = 16;
             ALOGV("Mime \"%s\" mapped to audio_format 0x%x",
                     mime.c_str(), audioFormat);
 
+            audioFormat = AVUtils::get()->updateAudioFormat(audioFormat, format);
+            bitWidth = AVUtils::get()->getAudioSampleBits(format);
             int avgBitRate = -1;
             format->findInt32("bitrate", &avgBitRate);
 
@@ -1808,12 +1812,24 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
             if (audioFormat == AUDIO_FORMAT_AAC
                     && format->findInt32("aac-profile", &aacProfile)) {
                 // Redefine AAC format as per aac profile
-                mapAACProfileToAudioFormat(
-                        audioFormat,
-                        aacProfile);
+                int32_t isADTSSupported;
+                isADTSSupported = AVUtils::get()->mapAACProfileToAudioFormat(format,
+                                          audioFormat,
+                                          aacProfile);
+                if (!isADTSSupported) {
+                    mapAACProfileToAudioFormat(audioFormat,
+                            aacProfile);
+                } else {
+                    ALOGV("Format is AAC ADTS\n");
+                }
             }
 
+            int32_t offloadBufferSize =
+                                    AVUtils::get()->getAudioMaxInputBufferSize(
+                                                   audioFormat,
+                                                   format);
             audio_offload_info_t offloadInfo = AUDIO_INFO_INITIALIZER;
+
             offloadInfo.duration_us = -1;
             format->findInt64(
                     "durationUs", &offloadInfo.duration_us);
@@ -1824,6 +1840,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
             offloadInfo.bit_rate = avgBitRate;
             offloadInfo.has_video = hasVideo;
             offloadInfo.is_streaming = true;
+            offloadInfo.offload_buffer_size = offloadBufferSize;
 
             if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
                 ALOGV("openAudioSink: no change in offload mode");
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
index fe7f8fa..c7df096 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
@@ -102,7 +102,6 @@ protected:
 
     virtual void onMessageReceived(const sp<AMessage> &msg);
 
-private:
     enum {
         kWhatDrainAudioQueue     = 'draA',
         kWhatDrainVideoQueue     = 'draV',
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index ed7179e..e11edee 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -55,6 +55,8 @@
 #include "include/DataConverter.h"
 #include "omx/OMXUtils.h"
 
+#include <stagefright/AVExtensions.h>
+
 namespace android {
 
 enum {
@@ -549,6 +551,10 @@ ACodec::ACodec()
 ACodec::~ACodec() {
 }
 
+status_t ACodec::setupCustomCodec(status_t err, const char *, const sp<AMessage> &) {
+    return err;
+}
+
 void ACodec::setNotificationMessage(const sp<AMessage> &msg) {
     mNotify = msg;
 }
@@ -2245,6 +2251,8 @@ status_t ACodec::configureCodec(
         } else {
             err = setupEAC3Codec(encoder, numChannels, sampleRate);
         }
+    } else {
+        err = setupCustomCodec(err, mime, msg);
     }
 
     if (err != OK) {
@@ -3217,7 +3225,7 @@ static const struct VideoCodingMapEntry {
     { MEDIA_MIMETYPE_VIDEO_DOLBY_VISION, OMX_VIDEO_CodingDolbyVision },
 };
 
-static status_t GetVideoCodingTypeFromMime(
+status_t ACodec::GetVideoCodingTypeFromMime(
         const char *mime, OMX_VIDEO_CODINGTYPE *codingType) {
     for (size_t i = 0;
          i < sizeof(kVideoCodingMapEntry) / sizeof(kVideoCodingMapEntry[0]);
@@ -4070,6 +4078,7 @@ status_t ACodec::setupMPEG4EncoderParameters(const sp<AMessage> &msg) {
         mpeg4type.eLevel = static_cast<OMX_VIDEO_MPEG4LEVELTYPE>(level);
     }
 
+    setBFrames(&mpeg4type);
     err = mOMX->setParameter(
             mNode, OMX_IndexParamVideoMpeg4, &mpeg4type, sizeof(mpeg4type));
 
@@ -4269,12 +4278,18 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         err = verifySupportForProfileAndLevel(profile, level);
 
         if (err != OK) {
+            ALOGE("%s does not support profile %x @ level %x",
+                    mComponentName.c_str(), profile, level);
             return err;
         }
 
         h264type.eProfile = static_cast<OMX_VIDEO_AVCPROFILETYPE>(profile);
         h264type.eLevel = static_cast<OMX_VIDEO_AVCLEVELTYPE>(level);
-    } else {
+
+    } 
+#if 0
+      else {
+        // Use baseline profile for AVC recording if profile is not specified.
         h264type.eProfile = OMX_VIDEO_AVCProfileBaseline;
 #if 0   /* DON'T YET DEFAULT TO HIGHEST PROFILE */
         // Use largest supported profile for AVC recording if profile is not specified.
@@ -4287,6 +4302,7 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         }
 #endif
     }
+#endif
 
     ALOGI("setupAVCEncoderParameters with [profile: %s] [level: %s]",
             asString(h264type.eProfile), asString(h264type.eLevel));
@@ -4327,6 +4343,7 @@ status_t ACodec::setupAVCEncoderParameters(const sp<AMessage> &msg) {
         h264type.nCabacInitIdc = 1;
     }
 
+    setBFrames(&h264type, iFrameInterval, frameRate);
     if (h264type.nBFrames != 0) {
         h264type.nAllowedPictureTypes |= OMX_VIDEO_PictureTypeB;
     }
@@ -4396,6 +4413,8 @@ status_t ACodec::setupHEVCEncoderParameters(const sp<AMessage> &msg) {
         frameRate = (float)tmp;
     }
 
+    AVUtils::get()->setIntraPeriod(setPFramesSpacing(iFrameInterval, frameRate), 0, mOMX, mNode);
+
     OMX_VIDEO_PARAM_HEVCTYPE hevcType;
     InitOMXParams(&hevcType);
     hevcType.nPortIndex = kPortIndexOutput;
@@ -5487,6 +5506,8 @@ void ACodec::sendFormatChange() {
     sp<AMessage> notify = mNotify->dup();
     notify->setInt32("what", kWhatOutputFormatChanged);
     notify->setMessage("format", mOutputFormat);
+    getVQZIPInfo(notify);
+
     notify->post();
 
     // mLastOutputFormat is not used when tunneled; doing this just to stay consistent
@@ -6303,6 +6324,7 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                 mCodec->mSkipCutBuffer->submit(info->mData);
             }
             info->mData->meta()->setInt64("timeUs", timeUs);
+            info->mData->meta()->setObject("graphic-buffer", info->mGraphicBuffer);
 
             sp<AMessage> notify = mCodec->mNotify->dup();
             notify->setInt32("what", CodecBase::kWhatDrainThisBuffer);
@@ -6834,6 +6856,7 @@ bool ACodec::LoadedState::onConfigureComponent(
     {
         sp<AMessage> notify = mCodec->mNotify->dup();
         notify->setInt32("what", CodecBase::kWhatComponentConfigured);
+        notify->setString("componentName", mCodec->mComponentName.c_str());
         notify->setMessage("input-format", mCodec->mInputFormat);
         notify->setMessage("output-format", mCodec->mOutputFormat);
         notify->post();
@@ -7577,6 +7600,13 @@ void ACodec::onSignalEndOfInputStream() {
     notify->post();
 }
 
+sp<IOMXObserver> ACodec::createObserver() {
+    sp<CodecObserver> observer = new CodecObserver;
+    sp<AMessage> notify = new AMessage(kWhatOMXMessageList, this);
+    observer->setNotificationMessage(notify);
+    return observer;
+}
+
 bool ACodec::ExecutingState::onOMXFrameRendered(int64_t mediaTimeUs, nsecs_t systemNano) {
     mCodec->onFrameRendered(mediaTimeUs, systemNano);
     return true;
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 3848502..0a26bd9 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -66,6 +66,7 @@ LOCAL_SRC_FILES:=                         \
 
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
+        $(TOP)/frameworks/av/media/libavextensions \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
@@ -100,7 +101,7 @@ LOCAL_SHARED_LIBRARIES := \
         libutils \
         libvorbisidec \
         libz \
-        libpowermanager
+        libpowermanager \
 
 LOCAL_STATIC_LIBRARIES := \
         libstagefright_color_conversion \
@@ -117,6 +118,8 @@ LOCAL_STATIC_LIBRARIES := \
         libFLAC \
         libmedia_helper \
 
+LOCAL_WHOLE_STATIC_LIBRARIES := libavextensions
+
 LOCAL_SHARED_LIBRARIES += \
         libstagefright_enc_common \
         libstagefright_avc_common \
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index 893da89..fa2a3a4 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -36,6 +36,8 @@
 #include <utils/String8.h>
 #include <cutils/properties.h>
 
+#include <stagefright/AVExtensions.h>
+
 #if LOG_NDEBUG
 #define UNUSED_UNLESS_VERBOSE(x) (void)(x)
 #else
@@ -677,6 +679,8 @@ status_t CameraSource::initWithCameraAccess(
     mMeta->setInt32(kKeyStride,      mVideoSize.width);
     mMeta->setInt32(kKeySliceHeight, mVideoSize.height);
     mMeta->setInt32(kKeyFrameRate,   mVideoFrameRate);
+    AVUtils::get()->extractCustomCameraKeys(params, mMeta);
+
     return OK;
 }
 
diff --git a/media/libstagefright/DataSource.cpp b/media/libstagefright/DataSource.cpp
index 163a527..c2cff65 100644
--- a/media/libstagefright/DataSource.cpp
+++ b/media/libstagefright/DataSource.cpp
@@ -49,6 +49,7 @@
 #include <cutils/properties.h>
 
 #include <private/android_filesystem_config.h>
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -180,6 +181,7 @@ void DataSource::RegisterDefaultSniffers() {
         RegisterSniffer_l(SniffWVM);
     }
     RegisterSniffer_l(SniffMidi);
+    RegisterSniffer_l(AVUtils::get()->getExtendedSniffer());
 
     char value[PROPERTY_VALUE_MAX];
     if (property_get("drm.service.enabled", value, NULL)
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index 5e96c2b..c400cc0 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -49,6 +49,7 @@
 #include "include/ESDS.h"
 #include "include/HevcUtils.h"
 #include "include/avc_utils.h"
+#include <stagefright/AVExtensions.h>
 
 #ifndef __predict_false
 #define __predict_false(exp) __builtin_expect((exp) != 0, 0)
@@ -542,6 +543,11 @@ status_t MPEG4Writer::addSource(const sp<IMediaSource> &source) {
         return ERROR_UNSUPPORTED;
     }
 
+    if (isAudio && !AVUtils::get()->isAudioMuxFormatSupported(mime)) {
+        ALOGE("Muxing is not supported for %s", mime);
+        return ERROR_UNSUPPORTED;
+    }
+
     // At this point, we know the track to be added is either
     // video or audio. Thus, we only need to check whether it
     // is an audio track or not (if it is not, then it must be
@@ -629,7 +635,7 @@ int64_t MPEG4Writer::estimateMoovBoxSize(int32_t bitRate) {
 
     // If the estimation is wrong, we will pay the price of wasting
     // some reserved space. This should not happen so often statistically.
-    static const int32_t factor = mUse32BitOffset? 1: 2;
+    int32_t factor = mUse32BitOffset? 1: 2;
     static const int64_t MIN_MOOV_BOX_SIZE = 3 * 1024;  // 3 KB
     static const int64_t MAX_MOOV_BOX_SIZE = (180 * 3000000 * 6LL / 8000);
     int64_t size = MIN_MOOV_BOX_SIZE;
@@ -1171,7 +1177,7 @@ off64_t MPEG4Writer::addSample_l(MediaBuffer *buffer) {
     return old_offset;
 }
 
-static void StripStartcode(MediaBuffer *buffer) {
+void MPEG4Writer::StripStartcode(MediaBuffer *buffer) {
     if (buffer->range_length() < 4) {
         return;
     }
@@ -2450,17 +2456,23 @@ status_t MPEG4Writer::Track::threadEntry() {
             continue;
         }
 
-        ++nActualFrames;
-
-        // Make a deep copy of the MediaBuffer and Metadata and release
-        // the original as soon as we can
-        MediaBuffer *copy = new MediaBuffer(buffer->range_length());
-        memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
-                buffer->range_length());
-        copy->set_range(0, buffer->range_length());
-        meta_data = new MetaData(*buffer->meta_data().get());
-        buffer->release();
-        buffer = NULL;
+        MediaBuffer *copy = NULL;
+        // Check if the upstream source hints it is OK to hold on to the
+        // buffer without releasing immediately and avoid cloning the buffer
+        if (AVUtils::get()->canDeferRelease(buffer->meta_data())) {
+            copy = buffer;
+            meta_data = new MetaData(*buffer->meta_data().get());
+        } else {
+            // Make a deep copy of the MediaBuffer and Metadata and release
+            // the original as soon as we can
+            copy = new MediaBuffer(buffer->range_length());
+            memcpy(copy->data(), (uint8_t *)buffer->data() + buffer->range_offset(),
+                    buffer->range_length());
+            copy->set_range(0, buffer->range_length());
+            meta_data = new MetaData(*buffer->meta_data().get());
+            buffer->release();
+            buffer = NULL;
+        }
 
         if (mIsAvc || mIsHevc) StripStartcode(copy);
 
diff --git a/media/libstagefright/MediaCodec.cpp b/media/libstagefright/MediaCodec.cpp
index e476424..ea01847 100644
--- a/media/libstagefright/MediaCodec.cpp
+++ b/media/libstagefright/MediaCodec.cpp
@@ -50,6 +50,7 @@
 #include <private/android_filesystem_config.h>
 #include <utils/Log.h>
 #include <utils/Singleton.h>
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -318,7 +319,7 @@ void MediaCodec::PostReplyWithError(const sp<AReplyToken> &replyID, int32_t err)
 sp<CodecBase> MediaCodec::GetCodecBase(const AString &name, bool nameIsType) {
     // at this time only ACodec specifies a mime type.
     if (nameIsType || name.startsWithIgnoreCase("omx.")) {
-        return new ACodec;
+        return AVFactory::get()->createACodec();;
     } else if (name.startsWithIgnoreCase("android.filter.")) {
         return new MediaFilter;
     } else {
@@ -1071,6 +1072,12 @@ bool MediaCodec::handleDequeueOutputBuffer(const sp<AReplyToken> &replyID, bool
         if (omxFlags & OMX_BUFFERFLAG_EOS) {
             flags |= BUFFER_FLAG_EOS;
         }
+        if (omxFlags & OMX_BUFFERFLAG_EXTRADATA) {
+            flags |= BUFFER_FLAG_EXTRADATA;
+        }
+        if (omxFlags & OMX_BUFFERFLAG_DATACORRUPT) {
+            flags |= BUFFER_FLAG_DATACORRUPT;
+        }
 
         response->setInt32("flags", flags);
         response->postReply(replyID);
@@ -1264,6 +1271,7 @@ void MediaCodec::onMessageReceived(const sp<AMessage> &msg) {
                     // reset input surface flag
                     mHaveInputSurface = false;
 
+                    CHECK(msg->findString("componentName", &mComponentName));
                     CHECK(msg->findMessage("input-format", &mInputFormat));
                     CHECK(msg->findMessage("output-format", &mOutputFormat));
                     ALOGV("[%s] configured as input format: %s, output format: %s",
@@ -2791,6 +2799,9 @@ void MediaCodec::onOutputBufferAvailable() {
         if (omxFlags & OMX_BUFFERFLAG_EOS) {
             flags |= BUFFER_FLAG_EOS;
         }
+        if (omxFlags & OMX_BUFFERFLAG_DATACORRUPT) {
+            flags |= BUFFER_FLAG_DATACORRUPT;
+        }
 
         msg->setInt32("flags", flags);
 
diff --git a/media/libstagefright/MediaCodecList.cpp b/media/libstagefright/MediaCodecList.cpp
index 0fb5072..7954acf 100644
--- a/media/libstagefright/MediaCodecList.cpp
+++ b/media/libstagefright/MediaCodecList.cpp
@@ -41,6 +41,7 @@
 
 #include <cutils/properties.h>
 #include <expat.h>
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -175,8 +176,9 @@ MediaCodecList::MediaCodecList()
     : mInitCheck(NO_INIT),
       mUpdate(false),
       mGlobalSettings(new AMessage()) {
-    parseTopLevelXMLFile("/etc/media_codecs.xml");
-    parseTopLevelXMLFile("/etc/media_codecs_performance.xml", true/* ignore_errors */);
+    parseTopLevelXMLFile(AVUtils::get()->getCustomCodecsLocation());
+    parseTopLevelXMLFile(AVUtils::get()->getCustomCodecsPerformanceLocation(),
+                            true/* ignore_errors */);
     parseTopLevelXMLFile(kProfilingResults, true/* ignore_errors */);
 }
 
@@ -944,7 +946,13 @@ status_t MediaCodecList::addLimit(const char **attrs) {
     // complexity: range + default
     bool found;
 
-    if (name == "aspect-ratio" || name == "bitrate" || name == "block-count"
+    // VT specific limits
+    if (name.find("vt-") == 0) {
+        AString value;
+        if (msg->findString("value", &value) && value.size()) {
+            mCurrentInfo->addDetail(name, value);
+        }
+    } else if (name == "aspect-ratio" || name == "bitrate" || name == "block-count"
             || name == "blocks-per-second" || name == "complexity"
             || name == "frame-rate" || name == "quality" || name == "size"
             || name == "measured-blocks-per-second" || name.startsWith("measured-frame-rate-")) {
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index ceb82eb..4d99645 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -37,6 +37,7 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/PersistentSurface.h>
 #include <media/stagefright/Utils.h>
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -680,6 +681,9 @@ status_t MediaCodecSource::feedEncoderInputBuffers() {
             // push decoding time for video, or drift time for audio
             if (mIsVideo) {
                 mDecodingTimeQueue.push_back(timeUs);
+                if (mFlags & FLAG_USE_METADATA_INPUT) {
+                    AVUtils::get()->addDecodingTimesFromBatch(mbuf, mDecodingTimeQueue);
+                }
             } else {
 #if DEBUG_DRIFT_TIME
                 if (mFirstSampleTimeUs < 0ll) {
@@ -866,6 +870,9 @@ void MediaCodecSource::onMessageReceived(const sp<AMessage> &msg) {
             MediaBuffer *mbuf = new MediaBuffer(outbuf->size());
             mbuf->setObserver(this);
             mbuf->add_ref();
+            memcpy(mbuf->data(), outbuf->data(), outbuf->size());
+            sp<MetaData> meta = mbuf->meta_data();
+            AVUtils::get()->setDeferRelease(meta);
 
             if (!(flags & MediaCodec::BUFFER_FLAG_CODECCONFIG)) {
                 if (mIsVideo) {
diff --git a/media/libstagefright/MediaExtractor.cpp b/media/libstagefright/MediaExtractor.cpp
index 92ce88c..307c0fd 100644
--- a/media/libstagefright/MediaExtractor.cpp
+++ b/media/libstagefright/MediaExtractor.cpp
@@ -50,6 +50,8 @@
 #include <private/android_filesystem_config.h>
 
 
+#include <stagefright/AVExtensions.h>
+
 namespace android {
 
 MediaExtractor::MediaExtractor():
@@ -233,7 +235,8 @@ sp<MediaExtractor> MediaExtractor::CreateFromService(
     }
 
     MediaExtractor *ret = NULL;
-    if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
+    if ((ret = AVFactory::get()->createExtendedExtractor(source, mime, meta)) != NULL) {
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_CONTAINER_MPEG4)
             || !strcasecmp(mime, "audio/mp4")) {
         ret = new MPEG4Extractor(source);
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_MPEG)) {
@@ -262,6 +265,7 @@ sp<MediaExtractor> MediaExtractor::CreateFromService(
         ret = new MidiExtractor(source);
     }
 
+    ret = AVFactory::get()->updateExtractor(ret, source, mime, meta);
     if (ret != NULL) {
        if (isDrm) {
            ret->setDrmFlag(true);
diff --git a/media/libstagefright/MediaMuxer.cpp b/media/libstagefright/MediaMuxer.cpp
index b13877d..798a855 100644
--- a/media/libstagefright/MediaMuxer.cpp
+++ b/media/libstagefright/MediaMuxer.cpp
@@ -35,6 +35,7 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/MPEG4Writer.h>
 #include <media/stagefright/Utils.h>
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -42,7 +43,7 @@ MediaMuxer::MediaMuxer(int fd, OutputFormat format)
     : mFormat(format),
       mState(UNINITIALIZED) {
     if (format == OUTPUT_FORMAT_MPEG_4) {
-        mWriter = new MPEG4Writer(fd);
+        mWriter = AVFactory::get()->CreateMPEG4Writer(fd);
     } else if (format == OUTPUT_FORMAT_WEBM) {
         mWriter = new WebmWriter(fd);
     }
diff --git a/media/libstagefright/StagefrightMediaScanner.cpp b/media/libstagefright/StagefrightMediaScanner.cpp
index f0c27ac..fc34357 100644
--- a/media/libstagefright/StagefrightMediaScanner.cpp
+++ b/media/libstagefright/StagefrightMediaScanner.cpp
@@ -28,6 +28,7 @@
 #include <media/mediametadataretriever.h>
 #include <private/media/VideoFrame.h>
 
+#include <stagefright/AVExtensions.h>
 namespace android {
 
 StagefrightMediaScanner::StagefrightMediaScanner() {}
@@ -75,7 +76,8 @@ MediaScanResult StagefrightMediaScanner::processFileInternal(
         return MEDIA_SCAN_RESULT_SKIPPED;
     }
 
-    if (!FileHasAcceptableExtension(extension)) {
+    if (!FileHasAcceptableExtension(extension)
+        && !AVUtils::get()->isEnhancedExtension(extension)) {
         return MEDIA_SCAN_RESULT_SKIPPED;
     }
 
diff --git a/media/libstagefright/StagefrightMetadataRetriever.cpp b/media/libstagefright/StagefrightMetadataRetriever.cpp
index be5067d..2b2d78f 100644
--- a/media/libstagefright/StagefrightMetadataRetriever.cpp
+++ b/media/libstagefright/StagefrightMetadataRetriever.cpp
@@ -46,6 +46,8 @@
 
 #include <CharacterEncodingDetector.h>
 
+#include <stagefright/AVExtensions.h>
+
 namespace android {
 
 static const int64_t kBufferTimeOutUs = 30000ll; // 30 msec
@@ -100,6 +102,7 @@ status_t StagefrightMetadataRetriever::setDataSource(
     fd = dup(fd);
 
     ALOGV("setDataSource(%d, %" PRId64 ", %" PRId64 ")", fd, offset, length);
+    AVUtils::get()->printFileName(fd);
 
     clearMetadata();
     mSource = new FileSource(fd, offset, length);
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 1c76ad7..3a232da 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -45,6 +45,8 @@
 #include <media/stagefright/Utils.h>
 #include <media/AudioParameter.h>
 
+#include <stagefright/AVExtensions.h>
+
 namespace android {
 
 uint16_t U16_AT(const uint8_t *ptr) {
@@ -1056,6 +1058,7 @@ status_t convertMetaDataToMessage(
         memcpy(buffer->data(), data, size);
     }
 
+    AVUtils::get()->convertMetaDataToMessage(meta, &msg);
     *format = msg;
 
     return OK;
@@ -1483,7 +1486,7 @@ status_t sendMetaDataToHal(sp<MediaPlayerBase::AudioSink>& sink,
     if (meta->findInt32(kKeyEncoderPadding, &paddingSamples)) {
         param.addInt(String8(AUDIO_OFFLOAD_CODEC_PADDING_SAMPLES), paddingSamples);
     }
-
+    AVUtils::get()->sendMetaDataToHal(meta, &param);
     ALOGV("sendMetaDataToHal: bitRate %d, sampleRate %d, chanMask %d,"
           "delaySample %d, paddingSample %d", bitRate, sampleRate,
           channelMask, delaySamples, paddingSamples);
@@ -1519,7 +1522,7 @@ const struct mime_conv_t* p = &mimeLookup[0];
         ++p;
     }
 
-    return BAD_VALUE;
+    return AVUtils::get()->mapMimeToAudioFormat(format, mime);
 }
 
 struct aac_format_conv_t {
@@ -1573,18 +1576,25 @@ bool canOffloadStream(const sp<MetaData>& meta, bool hasVideo,
     } else {
         ALOGV("Mime type \"%s\" mapped to audio_format %d", mime, info.format);
     }
-
     if (AUDIO_FORMAT_INVALID == info.format) {
         // can't offload if we don't know what the source format is
         ALOGE("mime type \"%s\" not a known audio format", mime);
         return false;
     }
 
+    if (AVUtils::get()->canOffloadAPE(meta) != true) {
+        return false;
+    }
     // Redefine aac format according to its profile
     // Offloading depends on audio DSP capabilities.
     int32_t aacaot = -1;
     if (meta->findInt32(kKeyAACAOT, &aacaot)) {
-        mapAACProfileToAudioFormat(info.format,(OMX_AUDIO_AACPROFILETYPE) aacaot);
+        bool isADTSSupported = false;
+        isADTSSupported = AVUtils::get()->mapAACProfileToAudioFormat(meta, info.format,
+                                  (OMX_AUDIO_AACPROFILETYPE) aacaot);
+        if (!isADTSSupported) {
+           mapAACProfileToAudioFormat(info.format,(OMX_AUDIO_AACPROFILETYPE) aacaot);
+        }
     }
 
     int32_t srate = -1;
diff --git a/media/libstagefright/codecs/aacdec/SoftAAC2.cpp b/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
index ff76bc8..ad02728 100644
--- a/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
+++ b/media/libstagefright/codecs/aacdec/SoftAAC2.cpp
@@ -77,6 +77,8 @@ SoftAAC2::SoftAAC2(
       mOutputBufferCount(0),
       mSignalledError(false),
       mLastInHeader(NULL),
+      mLastHeaderTimeUs(-1),
+      mNextOutBufferTimeUs(0),
       mOutputPortSettingsChange(NONE) {
     initPorts();
     CHECK_EQ(initDecoder(), (status_t)OK);
@@ -541,6 +543,27 @@ int32_t SoftAAC2::outputDelayRingBufferSpaceLeft() {
     return mOutputDelayRingBufferSize - outputDelayRingBufferSamplesAvailable();
 }
 
+void SoftAAC2::updateTimeStamp(int64_t inHeaderTimeUs) {
+    // use new input buffer timestamp as Anchor Time if its
+    //    a) first buffer or
+    //    b) first buffer post seek or
+    //    c) different from last buffer timestamp
+    //If input buffer timestamp is same as last input buffer timestamp then
+    //treat this as a erroneous timestamp and ignore new input buffer
+    //timestamp and use last output buffer timestamp as Anchor Time.
+    int64_t anchorTimeUs = 0;
+    if ((mLastHeaderTimeUs != inHeaderTimeUs)) {
+        anchorTimeUs = inHeaderTimeUs;
+        mLastHeaderTimeUs = inHeaderTimeUs;
+        //Store current buffer's timestamp so that it can used as reference
+        //in cases where first frame/buffer is skipped/dropped.
+        //e.g to compensate decoder delay
+        mNextOutBufferTimeUs = inHeaderTimeUs;
+    } else {
+        anchorTimeUs = mNextOutBufferTimeUs;
+    }
+    mBufferTimestamps.add(anchorTimeUs);
+}
 
 void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
     if (mSignalledError || mOutputPortSettingsChange != NONE) {
@@ -669,7 +692,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                 // insert buffer size and time stamp
                 mBufferSizes.add(inBufferLength[0]);
                 if (mLastInHeader != inHeader) {
-                    mBufferTimestamps.add(inHeader->nTimeStamp);
+                    updateTimeStamp(inHeader->nTimeStamp);
                     mLastInHeader = inHeader;
                 } else {
                     int64_t currentTime = mBufferTimestamps.top();
@@ -681,7 +704,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                 inBuffer[0] = inHeader->pBuffer + inHeader->nOffset;
                 inBufferLength[0] = inHeader->nFilledLen;
                 mLastInHeader = inHeader;
-                mBufferTimestamps.add(inHeader->nTimeStamp);
+                updateTimeStamp(inHeader->nTimeStamp);
                 mBufferSizes.add(inHeader->nFilledLen);
             }
 
@@ -793,11 +816,33 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                  * Thus, we could not say for sure whether a stream is
                  * AAC+/eAAC+ until the first data frame is decoded.
                  */
-                if (!mStreamInfo->sampleRate || !mStreamInfo->numChannels) {
-                    if ((mInputBufferCount > 2) && (mOutputBufferCount <= 1)) {
-                        ALOGW("Invalid AAC stream");
-                        mSignalledError = true;
-                        notify(OMX_EventError, OMX_ErrorUndefined, decoderErr, NULL);
+                if (mInputBufferCount <= 2 || mOutputBufferCount > 1) { // TODO: <= 1
+                    if (mStreamInfo->sampleRate != prevSampleRate ||
+                        mStreamInfo->numChannels != prevNumChannels) {
+                        ALOGI("Reconfiguring decoder: %d->%d Hz, %d->%d channels",
+                              prevSampleRate, mStreamInfo->sampleRate,
+                              prevNumChannels, mStreamInfo->numChannels);
+
+                        notify(OMX_EventPortSettingsChanged, 1, 0, NULL);
+                        mOutputPortSettingsChange = AWAITING_DISABLED;
+
+                        if (inHeader && inHeader->nFilledLen == 0) {
+                            inInfo->mOwnedByUs = false;
+                            mInputBufferCount++;
+
+                            //During Port reconfiguration current frames is skipped and next frame
+                            //is sent for decoding.
+                            //Update mNextOutBufferTimeUs with current frame's timestamp if port reconfiguration is
+                            //happening in last frame of current buffer otherwise LastOutBufferTimeUs
+                            //will be zero(post seek).
+                            mNextOutBufferTimeUs = mBufferTimestamps.top() + mStreamInfo->aacSamplesPerFrame *
+                                                       1000000ll / mStreamInfo->aacSampleRate;
+                            inQueue.erase(inQueue.begin());
+                            mLastInHeader = NULL;
+                            inInfo = NULL;
+                            notifyEmptyBufferDone(inHeader);
+                            inHeader = NULL;
+                        }
                         return;
                     }
                 } else if ((mStreamInfo->sampleRate != prevSampleRate) ||
@@ -926,6 +971,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                         *currentBufLeft -= decodedSize;
                         *nextTimeStamp += mStreamInfo->aacSamplesPerFrame *
                                 1000000ll / mStreamInfo->aacSampleRate;
+                        mNextOutBufferTimeUs = *nextTimeStamp;
                         ALOGV("adjusted nextTimeStamp/size to %lld/%d",
                                 (long long) *nextTimeStamp, *currentBufLeft);
                     } else {
@@ -933,6 +979,7 @@ void SoftAAC2::onQueueFilled(OMX_U32 /* portIndex */) {
                         if (mBufferTimestamps.size() > 0) {
                             mBufferTimestamps.removeAt(0);
                             nextTimeStamp = &mBufferTimestamps.editItemAt(0);
+                            mNextOutBufferTimeUs = *nextTimeStamp;
                             mBufferSizes.removeAt(0);
                             currentBufLeft = &mBufferSizes.editItemAt(0);
                             ALOGV("moved to next time/size: %lld/%d",
@@ -1027,6 +1074,8 @@ void SoftAAC2::onPortFlushCompleted(OMX_U32 portIndex) {
         mDecodedSizes.clear();
         mLastInHeader = NULL;
         mEndOfInput = false;
+        mLastHeaderTimeUs = -1;
+        mNextOutBufferTimeUs = 0;
     } else {
         int avail;
         while ((avail = outputDelayRingBufferSamplesAvailable()) > 0) {
@@ -1089,6 +1138,8 @@ void SoftAAC2::onReset() {
     mBufferSizes.clear();
     mDecodedSizes.clear();
     mLastInHeader = NULL;
+    mLastHeaderTimeUs = -1;
+    mNextOutBufferTimeUs = 0;
 
     // To make the codec behave the same before and after a reset, we need to invalidate the
     // streaminfo struct. This does that:
diff --git a/media/libstagefright/codecs/aacdec/SoftAAC2.h b/media/libstagefright/codecs/aacdec/SoftAAC2.h
index a1cf285..59b7754 100644
--- a/media/libstagefright/codecs/aacdec/SoftAAC2.h
+++ b/media/libstagefright/codecs/aacdec/SoftAAC2.h
@@ -59,6 +59,8 @@ private:
     size_t mOutputBufferCount;
     bool mSignalledError;
     OMX_BUFFERHEADERTYPE *mLastInHeader;
+    int64_t mLastHeaderTimeUs;
+    int64_t mNextOutBufferTimeUs;
     Vector<int32_t> mBufferSizes;
     Vector<int32_t> mDecodedSizes;
     Vector<int64_t> mBufferTimestamps;
@@ -89,6 +91,7 @@ private:
     int32_t outputDelayRingBufferGetSamples(INT_PCM *samples, int numSamples);
     int32_t outputDelayRingBufferSamplesAvailable();
     int32_t outputDelayRingBufferSpaceLeft();
+    void updateTimeStamp(int64_t inHeaderTimesUs);
 
     DISALLOW_EVIL_CONSTRUCTORS(SoftAAC2);
 };
diff --git a/media/libstagefright/codecs/mp3dec/SoftMP3.cpp b/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
index 0822c34..a059a24 100644
--- a/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
+++ b/media/libstagefright/codecs/mp3dec/SoftMP3.cpp
@@ -51,7 +51,9 @@ SoftMP3::SoftMP3(
       mSignalledError(false),
       mSawInputEos(false),
       mSignalledOutputEos(false),
-      mOutputPortSettingsChange(NONE) {
+      mOutputPortSettingsChange(NONE),
+      mLastAnchorTimeUs(-1),
+      mNextOutBufferTimeUs(0) {
     initPorts();
     initDecoder();
 }
@@ -239,7 +241,7 @@ void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
 
     List<BufferInfo *> &inQueue = getPortQueue(0);
     List<BufferInfo *> &outQueue = getPortQueue(1);
-
+    int64_t tmpTime = 0;
     while ((!inQueue.empty() || (mSawInputEos && !mSignalledOutputEos)) && !outQueue.empty()) {
         BufferInfo *inInfo = NULL;
         OMX_BUFFERHEADERTYPE *inHeader = NULL;
@@ -254,7 +256,20 @@ void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
 
         if (inHeader) {
             if (inHeader->nOffset == 0 && inHeader->nFilledLen) {
-                mAnchorTimeUs = inHeader->nTimeStamp;
+                // use new input buffer timestamp as Anchor Time if its
+                //    a) first buffer or
+                //    b) first buffer post seek or
+                //    c) different from last buffer timestamp
+                //If input buffer timestamp is same as last input buffer timestamp then
+                //treat this as a erroneous timestamp and ignore new input buffer
+                //timestamp and use last output buffer timestamp as Anchor Time.
+                if ((mLastAnchorTimeUs != inHeader->nTimeStamp)) {
+                    mAnchorTimeUs = inHeader->nTimeStamp;
+                    mLastAnchorTimeUs = inHeader->nTimeStamp;
+                } else {
+                    mAnchorTimeUs = mNextOutBufferTimeUs;
+                }
+
                 mNumFramesOutput = 0;
             }
 
@@ -361,7 +376,7 @@ void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
 
         outHeader->nTimeStamp =
             mAnchorTimeUs + (mNumFramesOutput * 1000000ll) / mSamplingRate;
-
+        tmpTime = outHeader->nTimeStamp;
         if (inHeader) {
             CHECK_GE(inHeader->nFilledLen, mConfig->inputBufferUsedLength);
 
@@ -386,6 +401,10 @@ void SoftMP3::onQueueFilled(OMX_U32 /* portIndex */) {
         notifyFillBufferDone(outHeader);
         outHeader = NULL;
     }
+
+    if (tmpTime > 0) {
+        mNextOutBufferTimeUs = tmpTime;
+    }
 }
 
 void SoftMP3::onPortFlushCompleted(OMX_U32 portIndex) {
@@ -397,6 +416,8 @@ void SoftMP3::onPortFlushCompleted(OMX_U32 portIndex) {
         mSignalledError = false;
         mSawInputEos = false;
         mSignalledOutputEos = false;
+        mLastAnchorTimeUs = -1;
+        mNextOutBufferTimeUs = 0;
     }
 }
 
@@ -433,6 +454,8 @@ void SoftMP3::onReset() {
     mSawInputEos = false;
     mSignalledOutputEos = false;
     mOutputPortSettingsChange = NONE;
+    mLastAnchorTimeUs = -1;
+    mNextOutBufferTimeUs = 0;
 }
 
 }  // namespace android
diff --git a/media/libstagefright/codecs/mp3dec/SoftMP3.h b/media/libstagefright/codecs/mp3dec/SoftMP3.h
index 3bfa6c7..5b6af88 100644
--- a/media/libstagefright/codecs/mp3dec/SoftMP3.h
+++ b/media/libstagefright/codecs/mp3dec/SoftMP3.h
@@ -70,6 +70,9 @@ private:
         AWAITING_ENABLED
     } mOutputPortSettingsChange;
 
+    int64_t mLastAnchorTimeUs;
+    int64_t mNextOutBufferTimeUs;
+
     void initPorts();
     void initDecoder();
     void *memsetSafe(OMX_BUFFERHEADERTYPE *outHeader, int c, size_t len);
diff --git a/services/audiopolicy/common/managerdefinitions/Android.mk b/services/audiopolicy/common/managerdefinitions/Android.mk
index d7da0ad..84c7f1c 100644
--- a/services/audiopolicy/common/managerdefinitions/Android.mk
+++ b/services/audiopolicy/common/managerdefinitions/Android.mk
@@ -34,6 +34,23 @@ LOCAL_C_INCLUDES := \
     $(TOPDIR)frameworks/av/services/audiopolicy \
     $(TOPDIR)frameworks/av/services/audiopolicy/utilities \
 
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
+LOCAL_CFLAGS     += -DFLAC_OFFLOAD_ENABLED
+endif
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_WMA_OFFLOAD)),true)
+LOCAL_CFLAGS     += -DWMA_OFFLOAD_ENABLED
+endif
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_ALAC_OFFLOAD)),true)
+LOCAL_CFLAGS     += -DALAC_OFFLOAD_ENABLED
+endif
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_APE_OFFLOAD)),true)
+LOCAL_CFLAGS     += -DAPE_OFFLOAD_ENABLED
+endif
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_AAC_ADTS_OFFLOAD)),true)
+LOCAL_CFLAGS     += -DAAC_ADTS_OFFLOAD_ENABLED
+endif
+endif
 ifeq ($(USE_XML_AUDIO_POLICY_CONF), 1)
 
 LOCAL_SRC_FILES += src/Serializer.cpp
diff --git a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
index 48bfd79..74939f0 100644
--- a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
@@ -143,6 +143,31 @@ const FormatConverter::Table FormatConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_DTS_HD),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_IEC61937),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_DOLBY_TRUEHD),
+#ifdef FLAC_OFFLOAD_ENABLED
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_FLAC),
+#endif
+#ifdef WMA_OFFLOAD_ENABLED
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_WMA),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_WMA_PRO),
+#endif
+#ifdef ALAC_OFFLOAD_ENABLED
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_ALAC),
+#endif
+#ifdef APE_OFFLOAD_ENABLED
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_APE),
+#endif
+#ifdef AAC_ADTS_OFFLOAD_ENABLED
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_MAIN),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_LC),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_SSR),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_LTP),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_HE_V1),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_SCALABLE),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_ERLC),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_LD),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_HE_V2),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_ELD),
+#endif
 };
 template<>
 const size_t FormatConverter::mSize = sizeof(FormatConverter::mTable) /
@@ -156,6 +181,10 @@ const OutputChannelConverter::Table OutputChannelConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_QUAD),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_5POINT1),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_7POINT1),
+    MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_2POINT1),
+    MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_SURROUND),
+    MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_PENTA),
+    MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_6POINT1),
 };
 template<>
 const size_t OutputChannelConverter::mSize = sizeof(OutputChannelConverter::mTable) /
-- 
2.7.4


From 874d713b5778c58efe18904133eed1d6b043c815 Mon Sep 17 00:00:00 2001
From: Mingming Yin <mingming@codeaurora.org>
Date: Wed, 19 Aug 2015 20:32:33 -0700
Subject: [PATCH 05/39] audio: add encoding support for linear PCM format

- add encoding support for linear PCM format.
- add changes for buffer Aggregatation in AudioSource.

Change-Id: Iecf402064d67d35d5057b814c842d79af92756d0
---
 include/media/MediaProfiles.h                       |  1 +
 include/media/stagefright/AudioSource.h             |  5 +++--
 media/libavextensions/stagefright/AVExtensions.h    |  7 ++++++-
 media/libavextensions/stagefright/AVFactory.cpp     | 10 ++++++++++
 media/libmedia/MediaProfiles.cpp                    | 12 +++++++++++-
 media/libmediaplayerservice/StagefrightRecorder.cpp | 19 ++++++++++++-------
 media/libmediaplayerservice/StagefrightRecorder.h   |  4 ++--
 7 files changed, 45 insertions(+), 13 deletions(-)

diff --git a/include/media/MediaProfiles.h b/include/media/MediaProfiles.h
index b18553e..b1c7c15 100644
--- a/include/media/MediaProfiles.h
+++ b/include/media/MediaProfiles.h
@@ -406,6 +406,7 @@ private:
     static VideoEncoderCap* createDefaultH263VideoEncoderCap();
     static VideoEncoderCap* createDefaultM4vVideoEncoderCap();
     static AudioEncoderCap* createDefaultAmrNBEncoderCap();
+    static AudioEncoderCap* createDefaultLpcmEncoderCap();
 
     static int findTagForName(const NameToTagMap *map, size_t nMappings, const char *name);
 
diff --git a/include/media/stagefright/AudioSource.h b/include/media/stagefright/AudioSource.h
index 3fc6a9c..40d9b8e 100644
--- a/include/media/stagefright/AudioSource.h
+++ b/include/media/stagefright/AudioSource.h
@@ -61,7 +61,8 @@ protected:
     virtual ~AudioSource();
 
     enum {
-        kMaxBufferSize = 2048,
+        //calculated for max duration 80 msec with 48K sampling rate.
+        kMaxBufferSize = 30720,
 
         // After the initial mute, we raise the volume linearly
         // over kAutoRampDurationUs.
@@ -104,7 +105,7 @@ protected:
     void queueInputBuffer_l(MediaBuffer *buffer, int64_t timeUs);
     void releaseQueuedFrames_l();
     void waitOutstandingEncodingFrames_l();
-    status_t reset();
+    virtual status_t reset();
 
     AudioSource(const AudioSource &);
     AudioSource &operator=(const AudioSource &);
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index 1b76da1..adaa6d2 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -89,7 +89,12 @@ struct AVFactory {
             const sp<IGraphicBufferProducer>& surface,
             int64_t timeBetweenFrameCaptureUs,
             bool storeMetaDataInVideoBuffers = true);
-
+      virtual AudioSource* createAudioSource(
+            audio_source_t inputSource,
+            const String16 &opPackageName,
+            uint32_t sampleRate,
+            uint32_t channels,
+            uint32_t outSampleRate = 0);
     virtual MPEG4Writer *CreateMPEG4Writer(int fd);
 
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
diff --git a/media/libavextensions/stagefright/AVFactory.cpp b/media/libavextensions/stagefright/AVFactory.cpp
index 93fe413..e5cdc4d 100644
--- a/media/libavextensions/stagefright/AVFactory.cpp
+++ b/media/libavextensions/stagefright/AVFactory.cpp
@@ -42,6 +42,7 @@
 #include <media/stagefright/MediaExtractor.h>
 #include <media/stagefright/CameraSourceTimeLapse.h>
 #include <media/stagefright/MPEG4Writer.h>
+#include <media/stagefright/AudioSource.h>
 
 #include "common/ExtensionsLoader.hpp"
 #include "stagefright/AVExtensions.h"
@@ -100,6 +101,15 @@ MPEG4Writer* AVFactory::CreateMPEG4Writer(int fd) {
     return new MPEG4Writer(fd);
 }
 
+AudioSource* AVFactory::createAudioSource(
+            audio_source_t inputSource,
+            const String16 &opPackageName,
+            uint32_t sampleRate,
+            uint32_t channels,
+            uint32_t outSampleRate) {
+    return new AudioSource(inputSource, opPackageName, sampleRate,
+                            channels, outSampleRate);
+}
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVFactory::AVFactory() {
 }
diff --git a/media/libmedia/MediaProfiles.cpp b/media/libmedia/MediaProfiles.cpp
index b20a952..dd72c16 100644
--- a/media/libmedia/MediaProfiles.cpp
+++ b/media/libmedia/MediaProfiles.cpp
@@ -46,7 +46,8 @@ const MediaProfiles::NameToTagMap MediaProfiles::sAudioEncoderNameMap[] = {
     {"amrwb",  AUDIO_ENCODER_AMR_WB},
     {"aac",    AUDIO_ENCODER_AAC},
     {"heaac",  AUDIO_ENCODER_HE_AAC},
-    {"aaceld", AUDIO_ENCODER_AAC_ELD}
+    {"aaceld", AUDIO_ENCODER_AAC_ELD},
+    {"lpcm",  AUDIO_ENCODER_LPCM},
 };
 
 const MediaProfiles::NameToTagMap MediaProfiles::sFileFormatMap[] = {
@@ -794,6 +795,7 @@ MediaProfiles::createDefaultCamcorderProfiles(MediaProfiles *profiles)
 MediaProfiles::createDefaultAudioEncoders(MediaProfiles *profiles)
 {
     profiles->mAudioEncoders.add(createDefaultAmrNBEncoderCap());
+    profiles->mAudioEncoders.add(createDefaultLpcmEncoderCap());
 }
 
 /*static*/ void
@@ -828,6 +830,14 @@ MediaProfiles::createDefaultAmrNBEncoderCap()
         AUDIO_ENCODER_AMR_NB, 5525, 12200, 8000, 8000, 1, 1);
 }
 
+
+/*static*/ MediaProfiles::AudioEncoderCap*
+MediaProfiles::createDefaultLpcmEncoderCap()
+{
+    return new MediaProfiles::AudioEncoderCap(
+        AUDIO_ENCODER_LPCM, 768000, 4608000, 8000, 48000, 1, 6);
+}
+
 /*static*/ void
 MediaProfiles::createDefaultImageEncodingQualityLevels(MediaProfiles *profiles)
 {
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index 6490d4d..3bfb590 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -942,9 +942,7 @@ sp<MediaCodecSource> StagefrightRecorder::createAudioSource() {
             return NULL;
         }
     }
-
-    sp<AudioSource> audioSource =
-        new AudioSource(
+    sp<AudioSource> audioSource = AVFactory::get()->createAudioSource(
                 mAudioSource,
                 mOpPackageName,
                 sourceSampleRate,
@@ -1062,13 +1060,20 @@ status_t StagefrightRecorder::setupRawAudioRecording() {
     }
 
     sp<MediaCodecSource> audioEncoder = createAudioSource();
-    if (audioEncoder == NULL) {
+    if (audioEncoder != NULL) {
+        CHECK(mWriter != 0);
+        mWriter->addSource(audioEncoder);
+        mAudioEncoderSource = audioEncoder;
+    } else if (audioEncoder == NULL && mAudioEncoder == AUDIO_ENCODER_LPCM) {
+        sp<MediaSource> src;
+        src = setPCMRecording();
+        CHECK(mWriter != 0);
+        mWriter->addSource(src);
+    }
+    else if (audioEncoder == NULL) {
         return UNKNOWN_ERROR;
     }
 
-    CHECK(mWriter != 0);
-    mWriter->addSource(audioEncoder);
-    mAudioEncoderSource = audioEncoder;
 
     if (mMaxFileDurationUs != 0) {
         mWriter->setMaxFileDuration(mMaxFileDurationUs);
diff --git a/media/libmediaplayerservice/StagefrightRecorder.h b/media/libmediaplayerservice/StagefrightRecorder.h
index 063eade..01ce380 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.h
+++ b/media/libmediaplayerservice/StagefrightRecorder.h
@@ -21,7 +21,7 @@
 #include <media/MediaRecorderBase.h>
 #include <camera/CameraParameters.h>
 #include <utils/String8.h>
-
+#include <media/stagefright/MediaSource.h>
 #include <system/audio.h>
 
 #include <MetadataBufferType.h>
@@ -199,7 +199,7 @@ protected:
     virtual status_t handleCustomRecording() {return UNKNOWN_ERROR;}
     virtual status_t handleCustomAudioSource(sp<AMessage> /*format*/) {return UNKNOWN_ERROR;}
     virtual status_t handleCustomAudioEncoder() {return UNKNOWN_ERROR;}
-
+    virtual sp<MediaSource> setPCMRecording() {return NULL;}
 
     StagefrightRecorder(const StagefrightRecorder &);
     StagefrightRecorder &operator=(const StagefrightRecorder &);
-- 
2.7.4


From f4ee3f320a7e3ac7b622b27548a0f0d29992a63a Mon Sep 17 00:00:00 2001
From: Santhosh Behara <santhoshbehara@codeaurora.org>
Date: Mon, 18 Jul 2016 18:40:48 +0530
Subject: [PATCH 06/39] libstagefright: Populate the metadata flag for
 batchmode encoding

For the encoder batch mode to work, set mFlags to FLAG_USE_METADATA_INPUT
if the MetadataBufferType is set to kMetadataBufferTypeNativeHandleSource.

Change-Id: I7cead5088298c040477d5edabed1b3fc1f603894
---
 media/libstagefright/MediaCodecSource.cpp | 5 +++++
 1 file changed, 5 insertions(+)

diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index 4d99645..b5e2eea 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -427,12 +427,17 @@ MediaCodecSource::MediaCodecSource(
     CHECK(mLooper != NULL);
 
     AString mime;
+    int32_t storeMeta = kMetadataBufferTypeInvalid;
     CHECK(mOutputFormat->findString("mime", &mime));
 
     if (!strncasecmp("video/", mime.c_str(), 6)) {
         mIsVideo = true;
     }
 
+    if (mOutputFormat->findInt32("android._input-metadata-buffer-type", &storeMeta)
+            && storeMeta == kMetadataBufferTypeNativeHandleSource) {
+        mFlags |= FLAG_USE_METADATA_INPUT;
+    }
     if (!(mFlags & FLAG_USE_SURFACE_INPUT)) {
         mPuller = new Puller(source);
     }
-- 
2.7.4


From b2a32bda03602d0e607c88438c56b321986e4903 Mon Sep 17 00:00:00 2001
From: Arusha Goyal <arushag@codeaurora.org>
Date: Wed, 18 May 2016 17:33:51 +0530
Subject: [PATCH 07/39] av: compilation fix

AOSP refresh NRD42E

Change-Id: I690764ee0ae0944bc80ec277502cdd92b3c8aae6
---
 include/media/stagefright/MediaCodecSource.h   | 1 +
 include/media/stagefright/SurfaceMediaSource.h | 2 +-
 2 files changed, 2 insertions(+), 1 deletion(-)

diff --git a/include/media/stagefright/MediaCodecSource.h b/include/media/stagefright/MediaCodecSource.h
index 18b1955..1044ee4 100644
--- a/include/media/stagefright/MediaCodecSource.h
+++ b/include/media/stagefright/MediaCodecSource.h
@@ -37,6 +37,7 @@ struct MediaCodecSource : public MediaSource,
                           public MediaBufferObserver {
     enum FlagBits {
         FLAG_USE_SURFACE_INPUT      = 1,
+        FLAG_USE_METADATA_INPUT     = 2,
         FLAG_PREFER_SOFTWARE_CODEC  = 4,  // used for testing only
     };
 
diff --git a/include/media/stagefright/SurfaceMediaSource.h b/include/media/stagefright/SurfaceMediaSource.h
index ca3a3bf..1657a38 100644
--- a/include/media/stagefright/SurfaceMediaSource.h
+++ b/include/media/stagefright/SurfaceMediaSource.h
@@ -25,7 +25,7 @@
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MediaBuffer.h>
 
-#include <MetadataBufferType.h>
+#include <media/hardware/MetadataBufferType.h>
 
 #include "foundation/ABase.h"
 
-- 
2.7.4


From 6ec688b09e7d99cf08b2ee46377644979d650a6a Mon Sep 17 00:00:00 2001
From: Weiyin Jiang <wjiang@codeaurora.org>
Date: Thu, 11 Aug 2016 12:33:07 +0800
Subject: [PATCH 08/39] audio: support bitdepth meta in webm writer

bitdepth meta is not carried when assembling a new webm from orginal
clip with media muxer, which breaks native decoder CTS cases.

To fix this, we need to reserve bitdepth info when converting from
AMessage to MetaData, and insert bps in webm writer.

Change-Id: I97ca473be26ffc32df75b6b78948b802081b234e
CRs-Fixed: 1053234
---
 media/libavextensions/stagefright/AVExtensions.h          |  4 ++++
 media/libavextensions/stagefright/AVUtils.cpp             | 12 ++++++++++++
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp |  1 -
 media/libstagefright/Utils.cpp                            |  1 +
 media/libstagefright/webm/Android.mk                      |  5 ++++-
 media/libstagefright/webm/WebmWriter.cpp                  | 10 +++++++++-
 6 files changed, 30 insertions(+), 3 deletions(-)

diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index adaa6d2..e4c2045 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -108,6 +108,8 @@ struct AVUtils {
 
     virtual status_t convertMetaDataToMessage(
             const sp<MetaData> &meta, sp<AMessage> *format);
+    virtual status_t convertMessageToMetaData(
+            const sp<AMessage> &msg, sp<MetaData> &meta);
     virtual DataSource::SnifferFunc getExtendedSniffer();
     virtual status_t mapMimeToAudioFormat( audio_format_t& format, const char* mime);
     virtual status_t sendMetaDataToHal(const sp<MetaData>& meta, AudioParameter *param);
@@ -115,6 +117,8 @@ struct AVUtils {
                 const char* mime, bool encoder, const sp<AMessage> &format);
     virtual bool isEnhancedExtension(const char *extension);
 
+    virtual bool hasAudioSampleBits(const sp<MetaData> &);
+    virtual bool hasAudioSampleBits(const sp<AMessage> &);
     virtual int getAudioSampleBits(const sp<MetaData> &);
     virtual int getAudioSampleBits(const sp<AMessage> &);
     virtual audio_format_t updateAudioFormat(audio_format_t audioFormat,
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index edbec1f..8fe6aef 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -49,6 +49,11 @@ status_t AVUtils::convertMetaDataToMessage(
     return OK;
 }
 
+status_t AVUtils::convertMessageToMetaData(
+        const sp<AMessage> &, sp<MetaData> &) {
+    return OK;
+}
+
 status_t AVUtils::mapMimeToAudioFormat(
         audio_format_t&, const char* ) {
     return OK;
@@ -59,6 +64,13 @@ status_t AVUtils::sendMetaDataToHal(
     return OK;
 }
 
+bool AVUtils::hasAudioSampleBits(const sp<MetaData> &) {
+    return false;
+}
+
+bool AVUtils::hasAudioSampleBits(const sp<AMessage> &) {
+    return false;
+}
 
 int AVUtils::getAudioSampleBits(const sp<MetaData> &) {
     return 16;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 20670ee..38aed02 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -34,7 +34,6 @@
 
 #include <inttypes.h>
 
-#include "stagefright/AVExtensions.h"
 namespace android {
 
 /*
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index 3a232da..f047060 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -1437,6 +1437,7 @@ void convertMessageToMetaData(const sp<AMessage> &msg, sp<MetaData> &meta) {
     }
 
     // XXX TODO add whatever other keys there are
+    AVUtils::get()->convertMessageToMetaData(msg, meta);
 
 #if 0
     ALOGI("converted %s to:", msg->debugString(0).c_str());
diff --git a/media/libstagefright/webm/Android.mk b/media/libstagefright/webm/Android.mk
index ce580ae..0d96f76 100644
--- a/media/libstagefright/webm/Android.mk
+++ b/media/libstagefright/webm/Android.mk
@@ -14,7 +14,10 @@ LOCAL_SRC_FILES:= EbmlUtil.cpp        \
                   WebmWriter.cpp
 
 
-LOCAL_C_INCLUDES += $(TOP)/frameworks/av/include
+LOCAL_C_INCLUDES += $(TOP)/frameworks/av/include \
+                    $(TOP)/frameworks/av/media/libavextensions \
+                    $(TOP)/frameworks/av/media/libstagefright/mpeg2ts \
+                    $(TOP)/frameworks/native/include/media/openmax
 
 LOCAL_SHARED_LIBRARIES += libstagefright_foundation \
                           libstagefright \
diff --git a/media/libstagefright/webm/WebmWriter.cpp b/media/libstagefright/webm/WebmWriter.cpp
index e58964d..6126dc2 100644
--- a/media/libstagefright/webm/WebmWriter.cpp
+++ b/media/libstagefright/webm/WebmWriter.cpp
@@ -31,6 +31,8 @@
 #include <sys/stat.h>
 #include <inttypes.h>
 
+#include "stagefright/AVExtensions.h"
+
 using namespace webm;
 
 namespace {
@@ -118,6 +120,7 @@ sp<WebmElement> WebmWriter::audioTrack(const sp<MetaData>& md) {
             'a', 'n', 'd', 'r', 'o', 'i', 'd', 0, 0, 0, 0, 1 };
     const void *headerData3;
     size_t headerSize1, headerSize2 = sizeof(headerData2), headerSize3;
+    int32_t bitWidth = 0;
 
     if (!md->findInt32(kKeyChannelCount, &nChannels)
             || !md->findInt32(kKeySampleRate, &samplerate)
@@ -147,10 +150,15 @@ sp<WebmElement> WebmWriter::audioTrack(const sp<MetaData>& md) {
     off += headerSize2;
     memcpy(codecPrivateData + off, headerData3, headerSize3);
 
+    if (AVUtils::get()->hasAudioSampleBits(md)) {
+        bitWidth = AVUtils::get()->getAudioSampleBits(md);
+    }
+
     sp<WebmElement> entry = WebmElement::AudioTrackEntry(
             nChannels,
             samplerate,
-            codecPrivateBuf);
+            codecPrivateBuf,
+            bitWidth);
     return entry;
 }
 
-- 
2.7.4


From af9d09e326f8e3deaea87d9b8bf537595a3d8843 Mon Sep 17 00:00:00 2001
From: Sharad Sangle <assangle@codeaurora.org>
Date: Tue, 21 Jun 2016 13:35:31 +0530
Subject: [PATCH 09/39] audio: update extended audioSource as per AOSP code

 Update the creator function of extended audio source
 as per latest AOSP code, which accepts uid/pid as a
 parameters

Change-Id: I2dabb6d34daa30df47501518a417e13a2543cc35
---
 media/libavextensions/stagefright/AVExtensions.h | 6 ++++--
 media/libavextensions/stagefright/AVFactory.cpp  | 6 ++++--
 2 files changed, 8 insertions(+), 4 deletions(-)

diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index e4c2045..77c8984 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -89,12 +89,14 @@ struct AVFactory {
             const sp<IGraphicBufferProducer>& surface,
             int64_t timeBetweenFrameCaptureUs,
             bool storeMetaDataInVideoBuffers = true);
-      virtual AudioSource* createAudioSource(
+    virtual AudioSource* createAudioSource(
             audio_source_t inputSource,
             const String16 &opPackageName,
             uint32_t sampleRate,
             uint32_t channels,
-            uint32_t outSampleRate = 0);
+            uint32_t outSampleRate = 0,
+            uid_t clientUid = -1,
+            pid_t clientPid = -1);
     virtual MPEG4Writer *CreateMPEG4Writer(int fd);
 
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
diff --git a/media/libavextensions/stagefright/AVFactory.cpp b/media/libavextensions/stagefright/AVFactory.cpp
index e5cdc4d..32dcc57 100644
--- a/media/libavextensions/stagefright/AVFactory.cpp
+++ b/media/libavextensions/stagefright/AVFactory.cpp
@@ -106,9 +106,11 @@ AudioSource* AVFactory::createAudioSource(
             const String16 &opPackageName,
             uint32_t sampleRate,
             uint32_t channels,
-            uint32_t outSampleRate) {
+            uint32_t outSampleRate,
+            uid_t clientUid,
+            pid_t clientPid) {
     return new AudioSource(inputSource, opPackageName, sampleRate,
-                            channels, outSampleRate);
+                            channels, outSampleRate, clientUid, clientPid);
 }
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVFactory::AVFactory() {
-- 
2.7.4


From 497c4f20cb46e153eca7cdc2cee5bf77bf2565fa Mon Sep 17 00:00:00 2001
From: Sharad Sangle <assangle@codeaurora.org>
Date: Fri, 24 Jul 2015 11:19:31 +0530
Subject: [PATCH 10/39] audiopolicy: make audio policy extensible

make function virtual or protected so that
they can be extended in custom audio policy.

audio policy: move output handle to AudioOutputDescriptor base class
Change-Id: I96ef9fd1c5a94874acb897245501ba2f9c9ab0c0

Conflicts:
	services/audiopolicy/managerdefault/AudioPolicyManager.h

Change-Id: Ida7992f6b327491fab1f4ea376e85e8eb34b89ca
---
 .../managerdefinitions/include/AudioOutputDescriptor.h       |  2 +-
 .../common/managerdefinitions/src/AudioOutputDescriptor.cpp  |  4 ++--
 services/audiopolicy/managerdefault/AudioPolicyManager.h     | 12 ++++++------
 3 files changed, 9 insertions(+), 9 deletions(-)

diff --git a/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h b/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h
index dd3f8ae..3af6693 100644
--- a/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h
+++ b/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h
@@ -76,6 +76,7 @@ public:
 
     sp<AudioPort>       mPort;
     audio_devices_t mDevice;                   // current device this output is routed to
+    audio_io_handle_t mIoHandle;           // output handle
     uint32_t mRefCount[AUDIO_STREAM_CNT]; // number of streams of each type using this output
     nsecs_t mStopTime[AUDIO_STREAM_CNT];
     float mCurVolume[AUDIO_STREAM_CNT];   // current stream volume in dB
@@ -121,7 +122,6 @@ public:
     virtual void toAudioPort(struct audio_port *port) const;
 
     const sp<IOProfile> mProfile;          // I/O profile this output derives from
-    audio_io_handle_t mIoHandle;           // output handle
     uint32_t mLatency;                  //
     audio_output_flags_t mFlags;   //
     AudioMix *mPolicyMix;             // non NULL when used by a dynamic policy
diff --git a/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp b/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
index 79bbc54..6b2bbab 100644
--- a/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
@@ -33,7 +33,7 @@ namespace android {
 
 AudioOutputDescriptor::AudioOutputDescriptor(const sp<AudioPort>& port,
                                              AudioPolicyClientInterface *clientInterface)
-    : mPort(port), mDevice(AUDIO_DEVICE_NONE),
+    : mPort(port), mDevice(AUDIO_DEVICE_NONE),mIoHandle(0),
       mClientInterface(clientInterface), mPatchHandle(AUDIO_PATCH_HANDLE_NONE), mId(0)
 {
     // clear usage count for all stream types
@@ -221,7 +221,7 @@ void AudioOutputDescriptor::log(const char* indent)
 SwAudioOutputDescriptor::SwAudioOutputDescriptor(const sp<IOProfile>& profile,
                                                  AudioPolicyClientInterface *clientInterface)
     : AudioOutputDescriptor(profile, clientInterface),
-    mProfile(profile), mIoHandle(0), mLatency(0),
+    mProfile(profile), mLatency(0),
     mFlags((audio_output_flags_t)0), mPolicyMix(NULL),
     mOutput1(0), mOutput2(0), mDirectOpenCount(0), mGlobalRefCount(0)
 {
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.h b/services/audiopolicy/managerdefault/AudioPolicyManager.h
index 71bcd5f..0b2ec1c 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.h
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.h
@@ -394,7 +394,7 @@ protected:
         // must be called every time a condition that affects the device choice for a given output is
         // changed: connected device, phone state, force use, output start, output stop..
         // see getDeviceForStrategy() for the use of fromCache parameter
-        audio_devices_t getNewOutputDevice(const sp<AudioOutputDescriptor>& outputDesc,
+        virtual audio_devices_t getNewOutputDevice(const sp<AudioOutputDescriptor>& outputDesc,
                                            bool fromCache);
 
         // updates cache of device used by all strategies (mDeviceForStrategy[])
@@ -481,12 +481,12 @@ protected:
 
         // if argument "device" is different from AUDIO_DEVICE_NONE,  startSource() will force
         // the re-evaluation of the output device.
-        status_t startSource(sp<AudioOutputDescriptor> outputDesc,
+        virtual status_t startSource(sp<AudioOutputDescriptor> outputDesc,
                              audio_stream_type_t stream,
                              audio_devices_t device,
                              const char *address,
                              uint32_t *delayMs);
-        status_t stopSource(sp<AudioOutputDescriptor> outputDesc,
+        virtual status_t stopSource(sp<AudioOutputDescriptor> outputDesc,
                             audio_stream_type_t stream,
                             bool forceDeviceUpdate);
 
@@ -593,7 +593,7 @@ private:
         // If any, resolve any "dynamic" fields of an Audio Profiles collection
         void updateAudioProfiles(audio_devices_t device, audio_io_handle_t ioHandle,
                 AudioProfileVector &profiles);
-
+protected:
         // updates device caching and output for streams that can influence the
         //    routing of notifications
         void handleNotificationRoutingForStream(audio_stream_type_t stream);
@@ -608,7 +608,7 @@ private:
                 SortedVector<audio_io_handle_t>& outputs /*out*/);
         uint32_t curAudioPortGeneration() const { return mAudioPortGeneration; }
         // internal method to return the output handle for the given device and format
-        audio_io_handle_t getOutputForDevice(
+        virtual audio_io_handle_t getOutputForDevice(
                 audio_devices_t device,
                 audio_session_t session,
                 audio_stream_type_t stream,
@@ -644,7 +644,7 @@ private:
                                                         AudioMix **policyMix = NULL);
 
         // Called by setDeviceConnectionState().
-        status_t setDeviceConnectionStateInt(audio_devices_t device,
+        virtual status_t setDeviceConnectionStateInt(audio_devices_t device,
                                                           audio_policy_dev_state_t state,
                                                           const char *device_address,
                                                           const char *device_name);
-- 
2.7.4


From fb327ff29017e22f8c7b310b4842b568b9d027e3 Mon Sep 17 00:00:00 2001
From: sooorajjj <sooraj.sizon@micromaxinfo.com>
Date: Mon, 30 Jan 2017 10:43:34 +0530
Subject: [PATCH 11/39] we need this header!

---
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 38aed02..4f62d4f 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -31,9 +31,10 @@
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
 #include <media/stagefright/VideoFrameScheduler.h>
-
 #include <inttypes.h>
 
+#include "stagefright/AVExtensions.h"
+
 namespace android {
 
 /*
-- 
2.7.4


From 6f869ee6935d0f4a8d720ca81e3fa4e3ce00a71b Mon Sep 17 00:00:00 2001
From: Sharad Sangle <assangle@codeaurora.org>
Date: Wed, 30 Nov 2016 17:21:06 +0530
Subject: [PATCH 12/39] audio: Don't update the audio_output flag with track
 flags

 Use the AUDIO_OUTPUT_FLAG_DIRECT only for creating
 the track and do not add this in the audio_flags
 of AudioTrack, as adding this to audio_flags of
 AudioTrack is not expected and lead to side effects.

Change-Id: Ic85ad5aef91e147a209d1c7a3a7ef0728f3d4207
---
 media/libmedia/AudioTrack.cpp | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index ee0c509..6ee91f2 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -1375,6 +1375,7 @@ status_t AudioTrack::createTrack_l()
     }
 
     audio_output_flags_t flags = mFlags;
+    audio_output_flags_t trackFlags = mFlags;
 
     pid_t tid = -1;
     if (mFlags & AUDIO_OUTPUT_FLAG_FAST) {
@@ -1383,6 +1384,9 @@ status_t AudioTrack::createTrack_l()
         }
     }
 
+    if (mTrackOffloaded) {
+        trackFlags = (audio_output_flags_t)(flags | AUDIO_OUTPUT_FLAG_DIRECT);
+    }
     size_t temp = frameCount;   // temp may be replaced by a revised value of frameCount,
                                 // but we will still need the original value also
     audio_session_t originalSessionId = mSessionId;
@@ -1391,7 +1395,7 @@ status_t AudioTrack::createTrack_l()
                                                       mFormat,
                                                       mChannelMask,
                                                       &temp,
-                                                      &flags,
+                                                      &trackFlags,
                                                       mSharedBuffer,
                                                       output,
                                                       mClientPid,
-- 
2.7.4


From 87df36caaa20c28639f4d3c627cdb2f561cd8a88 Mon Sep 17 00:00:00 2001
From: vivek mehta <mvivek@codeaurora.org>
Date: Thu, 3 Sep 2015 18:25:56 -0700
Subject: [PATCH 13/39] audio: add support to enable Direct PCM output

This change squashes all changes done to enable
direct PCM output.

audio: use offload standby delay for direct pcm
Change-Id: Ifd0e39c5b3fe4a4af9f444dbbad21ef1e1a5edfa

AudioTrack: Set DIRECT track flag for direct pcm output
Change-Id: I13f840b5d67be56e03ec65d3bc7d44f1090b48c5

Direct_PCM: add support for effects
Change-Id: I2fbac63c623bf51a03e5e91828369739d33329f3

libmedia : audio: handle set playback rate when direct pcm used
Change-Id: I6df7c10b7115c77a19564e2f9fabc511d76a2410

audioflinger: Always process volume commands from a latest track
Change-Id: I9afbdd221db3a7311eb0ec8bb75852cf5409084e

Change-Id: I2ad7eacf11642a4ca9f892b61124293d0dc503a9
---
 include/media/AudioTrack.h                         |  2 +
 media/libavextensions/media/AVMediaExtensions.h    |  7 +-
 media/libavextensions/media/AVMediaUtils.cpp       |  8 +++
 media/libmedia/AudioTrack.cpp                      | 29 +++++++-
 services/audioflinger/AudioFlinger.cpp             |  6 +-
 services/audioflinger/Effects.cpp                  |  3 +-
 services/audioflinger/Threads.cpp                  | 80 +++++++++++++++++++---
 services/audioflinger/Threads.h                    |  1 +
 .../managerdefinitions/src/TypeConverter.cpp       |  1 +
 .../managerdefault/AudioPolicyManager.cpp          |  7 ++
 10 files changed, 125 insertions(+), 19 deletions(-)

diff --git a/include/media/AudioTrack.h b/include/media/AudioTrack.h
index 9eb89e3..3358a0b 100644
--- a/include/media/AudioTrack.h
+++ b/include/media/AudioTrack.h
@@ -1089,6 +1089,8 @@ protected:
     // For Device Selection API
     //  a value of AUDIO_PORT_HANDLE_NONE indicated default (AudioPolicyManager) routing.
     audio_port_handle_t     mSelectedDeviceId;
+    bool                    mTrackOffloaded;
+    bool                    mPlaybackRateSet;
 
 private:
     class DeathNotifier : public IBinder::DeathRecipient {
diff --git a/media/libavextensions/media/AVMediaExtensions.h b/media/libavextensions/media/AVMediaExtensions.h
index f8204e3..5ec9769 100644
--- a/media/libavextensions/media/AVMediaExtensions.h
+++ b/media/libavextensions/media/AVMediaExtensions.h
@@ -43,9 +43,10 @@ class MediaRecorder;
 struct AVMediaUtils {
 
 
-    virtual size_t AudioTrackGetOffloadFrameCount(size_t frameCount) {
-        return frameCount;
-    }
+    virtual size_t AudioTrackGetOffloadFrameCount(size_t frameCount);
+
+    virtual bool AudioTrackIsTrackOffloaded(audio_io_handle_t /*output*/);
+
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVMediaUtils);
 };
diff --git a/media/libavextensions/media/AVMediaUtils.cpp b/media/libavextensions/media/AVMediaUtils.cpp
index 752f6d0..b4ae9e0 100644
--- a/media/libavextensions/media/AVMediaUtils.cpp
+++ b/media/libavextensions/media/AVMediaUtils.cpp
@@ -46,6 +46,14 @@
 
 namespace android {
 
+size_t AVMediaUtils::AudioTrackGetOffloadFrameCount(size_t frameCount) {
+    return frameCount;
+}
+
+bool AVMediaUtils::AudioTrackIsTrackOffloaded(audio_io_handle_t output __unused) {
+    return false;
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVMediaUtils::AVMediaUtils() {
 }
diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 6ee91f2..8ad9800 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -177,7 +177,9 @@ AudioTrack::AudioTrack()
       mPreviousPriority(ANDROID_PRIORITY_NORMAL),
       mPreviousSchedulingGroup(SP_DEFAULT),
       mPausedPosition(0),
-      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)
+      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE),
+      mTrackOffloaded(false),
+      mPlaybackRateSet(false)
 {
     mAttributes.content_type = AUDIO_CONTENT_TYPE_UNKNOWN;
     mAttributes.usage = AUDIO_USAGE_UNKNOWN;
@@ -208,7 +210,9 @@ AudioTrack::AudioTrack(
       mPreviousPriority(ANDROID_PRIORITY_NORMAL),
       mPreviousSchedulingGroup(SP_DEFAULT),
       mPausedPosition(0),
-      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)
+      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE),
+      mTrackOffloaded(false),
+      mPlaybackRateSet(false)
 {
     mStatus = set(streamType, sampleRate, format, channelMask,
             frameCount, flags, cbf, user, notificationFrames,
@@ -239,7 +243,9 @@ AudioTrack::AudioTrack(
       mPreviousPriority(ANDROID_PRIORITY_NORMAL),
       mPreviousSchedulingGroup(SP_DEFAULT),
       mPausedPosition(0),
-      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE)
+      mSelectedDeviceId(AUDIO_PORT_HANDLE_NONE),
+      mTrackOffloaded(false),
+      mPlaybackRateSet(false)
 {
     mStatus = set(streamType, sampleRate, format, channelMask,
             0 /*frameCount*/, flags, cbf, user, notificationFrames,
@@ -905,6 +911,12 @@ status_t AudioTrack::setPlaybackRate(const AudioPlaybackRate &playbackRate)
     //set effective rates
     mProxy->setPlaybackRate(playbackRateTemp);
     mProxy->setSampleRate(effectiveRate); // FIXME: not quite "atomic" with setPlaybackRate
+
+    // Playback Rate cannot be changed for direct tracks, hence fallback to deep buffer
+    if (mTrackOffloaded) {
+        mPlaybackRateSet = true;
+        android_atomic_or(CBLK_INVALID, &mCblk->mFlags);
+    }
     return NO_ERROR;
 }
 
@@ -1235,6 +1247,13 @@ status_t AudioTrack::createTrack_l()
     // mFlags (not mOrigFlags) is modified depending on whether fast request is accepted.
     // After fast request is denied, we will request again if IAudioTrack is re-created.
 
+    // Playback Rate is set, ensure we dont get a direct output
+    audio_offload_info_t tOffloadInfo = AUDIO_INFO_INITIALIZER;
+    if (mPlaybackRateSet == true && mOffloadInfo == NULL
+        && audio_is_linear_pcm(mFormat)) {
+        mOffloadInfo = &tOffloadInfo;
+    }
+
     status_t status;
     status = AudioSystem::getOutputForAttr(attr, &output,
                                            mSessionId, &streamType, mClientUid,
@@ -1247,11 +1266,15 @@ status_t AudioTrack::createTrack_l()
               mSessionId, streamType, mAttributes.usage, mSampleRate, mFormat, mChannelMask, mFlags);
         return BAD_VALUE;
     }
+    //reset offload info if forced
+    mOffloadInfo = (mOffloadInfo == &tOffloadInfo) ? NULL : mOffloadInfo;
+
     {
     // Now that we have a reference to an I/O handle and have not yet handed it off to AudioFlinger,
     // we must release it ourselves if anything goes wrong.
 
     // Not all of these values are needed under all conditions, but it is easier to get them all
+    mTrackOffloaded = AVMediaUtils::get()->AudioTrackIsTrackOffloaded(output);
     status = AudioSystem::getLatency(output, &mAfLatency);
     if (status != NO_ERROR) {
         ALOGE("getLatency(%d) failed status %d", output, status);
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 1785a03..55ddb2c 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -1885,7 +1885,11 @@ sp<AudioFlinger::PlaybackThread> AudioFlinger::openOutput_l(audio_module_handle_
                 || !isValidPcmSinkFormat(config->format)
                 || !isValidPcmSinkChannelMask(config->channel_mask)) {
             thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady);
-            ALOGV("openOutput_l() created direct output: ID %d thread %p", *output, thread);
+            ALOGV("openOutput_l() created direct output: ID %d thread %p ", *output, thread);
+            //Check if this is DirectPCM, if so
+            if (flags & AUDIO_OUTPUT_FLAG_DIRECT_PCM) {
+                thread->mIsDirectPcm = true;
+            }
         } else {
             thread = new MixerThread(this, outputStream, *output, devices, mSystemReady);
             ALOGV("openOutput_l() created mixer output: ID %d thread %p", *output, thread);
diff --git a/services/audioflinger/Effects.cpp b/services/audioflinger/Effects.cpp
index 9711f2d..5b59c71 100644
--- a/services/audioflinger/Effects.cpp
+++ b/services/audioflinger/Effects.cpp
@@ -1170,7 +1170,8 @@ status_t AudioFlinger::EffectHandle::enable()
         mEnabled = false;
     } else {
         if (thread != 0) {
-            if (thread->type() == ThreadBase::OFFLOAD) {
+            if ((thread->type() == ThreadBase::OFFLOAD) ||
+                (thread->type() == ThreadBase::DIRECT && thread->mIsDirectPcm)) {
                 PlaybackThread *t = (PlaybackThread *)thread.get();
                 Mutex::Autolock _l(t->mLock);
                 t->broadcast_l();
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index 0f403ae..92e26c6 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -644,6 +644,7 @@ AudioFlinger::ThreadBase::ThreadBase(const sp<AudioFlinger>& audioFlinger, audio
         mNotifiedBatteryStart(false)
 {
     memset(&mPatch, 0, sizeof(struct audio_patch));
+    mIsDirectPcm = false;
 }
 
 AudioFlinger::ThreadBase::~ThreadBase()
@@ -1418,6 +1419,55 @@ sp<AudioFlinger::EffectHandle> AudioFlinger::ThreadBase::createEffect_l(
         goto Exit;
     }
 
+    // Reject any effect on Direct output threads for now, since the format of
+    // mSinkBuffer is not guaranteed to be compatible with effect processing (PCM 16 stereo).
+    // Exception: allow effects for Direct PCM
+    if (mType == DIRECT && !mIsDirectPcm) {
+        ALOGW("createEffect_l() Cannot add effect %s on Direct output type thread %s",
+                desc->name, mThreadName);
+        lStatus = BAD_VALUE;
+        goto Exit;
+    }
+
+    // Reject any effect on mixer or duplicating multichannel sinks.
+    // TODO: fix both format and multichannel issues with effects.
+    if ((mType == MIXER || mType == DUPLICATING) && mChannelCount != FCC_2) {
+        ALOGW("createEffect_l() Cannot add effect %s for multichannel(%d) %s threads",
+                desc->name, mChannelCount, mType == MIXER ? "MIXER" : "DUPLICATING");
+        lStatus = BAD_VALUE;
+        goto Exit;
+    }
+
+    // Allow global effects only on offloaded and mixer threads
+    // Exception: allow effects for Direct PCM
+    if (sessionId == AUDIO_SESSION_OUTPUT_MIX) {
+        switch (mType) {
+        case MIXER:
+        case OFFLOAD:
+            break;
+        case DIRECT:
+            if (mIsDirectPcm) {
+                // Allow effects when direct PCM enabled on Direct output
+                break;
+            }
+        case DUPLICATING:
+        case RECORD:
+        default:
+            ALOGW("createEffect_l() Cannot add global effect %s on thread %s",
+                    desc->name, mThreadName);
+            lStatus = BAD_VALUE;
+            goto Exit;
+        }
+    }
+
+    // Only Pre processor effects are allowed on input threads and only on input threads
+    if ((mType == RECORD) != ((desc->flags & EFFECT_FLAG_TYPE_MASK) == EFFECT_FLAG_TYPE_PRE_PROC)) {
+        ALOGW("createEffect_l() effect %s (flags %08x) created on wrong thread type %d",
+                desc->name, desc->flags, mType);
+        lStatus = BAD_VALUE;
+        goto Exit;
+    }
+
     ALOGV("createEffect_l() thread %p effect %s on session %d", this, desc->name, sessionId);
 
     { // scope for mLock
@@ -1457,7 +1507,13 @@ sp<AudioFlinger::EffectHandle> AudioFlinger::ThreadBase::createEffect_l(
             if (lStatus != NO_ERROR) {
                 goto Exit;
             }
-            effect->setOffloaded(mType == OFFLOAD, mId);
+
+            bool setVal = false;
+            if (mType == OFFLOAD || (mType == DIRECT && mIsDirectPcm)) {
+                setVal = true;
+            }
+
+            effect->setOffloaded(setVal, mId);
 
             lStatus = chain->addEffect_l(effect);
             if (lStatus != NO_ERROR) {
@@ -1543,7 +1599,13 @@ status_t AudioFlinger::ThreadBase::addEffect_l(const sp<EffectModule>& effect)
         return BAD_VALUE;
     }
 
-    effect->setOffloaded(mType == OFFLOAD, mId);
+    bool setval = false;
+
+    if ((mType == OFFLOAD) || (mType == DIRECT && mIsDirectPcm)) {
+        setval = true;
+    }
+
+    effect->setOffloaded(setval, mId);
 
     status_t status = chain->addEffect_l(effect);
     if (status != NO_ERROR) {
@@ -5259,6 +5321,8 @@ void AudioFlinger::DirectOutputThread::cacheParameters_l()
         mStandbyDelayNs = 0;
     } else if ((mType == OFFLOAD) && !audio_has_proportional_frames(mFormat)) {
         mStandbyDelayNs = kOffloadStandbyDelayNs;
+    } else if (mType == DIRECT && mIsDirectPcm) {
+        mStandbyDelayNs = kOffloadStandbyDelayNs;
     } else {
         mStandbyDelayNs = microseconds(mActiveSleepTimeUs*2);
     }
@@ -5449,15 +5513,9 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::OffloadThread::prepareTr
         if (track->isInvalid()) {
             ALOGW("An invalidated track shouldn't be in active list");
             tracksToRemove->add(track);
-            continue;
-        }
-
-        if (track->mState == TrackBase::IDLE) {
+        } else if (track->mState == TrackBase::IDLE) {
             ALOGW("An idle track shouldn't be in active list");
-            continue;
-        }
-
-        if (track->isPausing()) {
+        } else if (track->isPausing()) {
             track->setPaused();
             if (last) {
                 if (mHwSupportsPause && !mHwPaused) {
@@ -5485,7 +5543,7 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::OffloadThread::prepareTr
             if (last) {
                 mFlushPending = true;
             }
-        } else if (track->isResumePending()){
+        } else if (track->isResumePending()) {
             track->resumeAck();
             if (last) {
                 if (mPausedBytesRemaining) {
diff --git a/services/audioflinger/Threads.h b/services/audioflinger/Threads.h
index f353f3b..85bfa98 100644
--- a/services/audioflinger/Threads.h
+++ b/services/audioflinger/Threads.h
@@ -481,6 +481,7 @@ protected:
                 bool                    mSystemReady;
                 bool                    mNotifiedBatteryStart;
                 ExtendedTimestamp       mTimestamp;
+                bool                    mIsDirectPcm; // flag to indicate unique Direct thread
 };
 
 // --- PlaybackThread ---
diff --git a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
index 74939f0..d51f186 100644
--- a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
@@ -86,6 +86,7 @@ const size_t DeviceConverter::mSize = sizeof(DeviceConverter::mTable) /
 template <>
 const OutputFlagConverter::Table OutputFlagConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_DIRECT),
+    MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_DIRECT_PCM),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_PRIMARY),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_FAST),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_DEEP_BUFFER),
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 968b80f..7e8c27c 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -1987,6 +1987,7 @@ audio_io_handle_t AudioPolicyManager::selectOutputForEffects(
 
     audio_io_handle_t outputOffloaded = 0;
     audio_io_handle_t outputDeepBuffer = 0;
+    audio_io_handle_t outputDirectPcm = 0;
 
     for (size_t i = 0; i < outputs.size(); i++) {
         sp<SwAudioOutputDescriptor> desc = mOutputs.valueFor(outputs[i]);
@@ -1994,6 +1995,9 @@ audio_io_handle_t AudioPolicyManager::selectOutputForEffects(
         if ((desc->mFlags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) != 0) {
             outputOffloaded = outputs[i];
         }
+        if ((desc->mFlags & AUDIO_OUTPUT_FLAG_DIRECT_PCM) != 0) {
+            outputDirectPcm = outputs[i];
+        }
         if ((desc->mFlags & AUDIO_OUTPUT_FLAG_DEEP_BUFFER) != 0) {
             outputDeepBuffer = outputs[i];
         }
@@ -2004,6 +2008,9 @@ audio_io_handle_t AudioPolicyManager::selectOutputForEffects(
     if (outputOffloaded != 0) {
         return outputOffloaded;
     }
+    if (outputDirectPcm != 0) {
+        return outputDirectPcm;
+    }
     if (outputDeepBuffer != 0) {
         return outputDeepBuffer;
     }
-- 
2.7.4


From 559fbcf2a63bce28f1dfa0b86df641f22a0a3caa Mon Sep 17 00:00:00 2001
From: Susmitha Gummalla <vgummall@codeaurora.org>
Date: Tue, 29 Apr 2014 12:18:30 -0700
Subject: [PATCH 14/39] Camera: Add support for preview frame fd

-Add support for receiving dataCallback with fd/buffer as frame buffer

CRs-fixed: 654901
Change-Id: I5c16e560f1e209a6ab4afa4f3437602b02992b9b
---
 camera/ICameraClient.cpp | 17 ++++++++++++++---
 1 file changed, 14 insertions(+), 3 deletions(-)

diff --git a/camera/ICameraClient.cpp b/camera/ICameraClient.cpp
index 68cbfb8..8a7430f 100644
--- a/camera/ICameraClient.cpp
+++ b/camera/ICameraClient.cpp
@@ -50,7 +50,12 @@ public:
         data.writeInterfaceToken(ICameraClient::getInterfaceDescriptor());
         data.writeInt32(msgType);
         data.writeInt32(ext1);
-        data.writeInt32(ext2);
+        if ((msgType == CAMERA_MSG_PREVIEW_FRAME) && (ext1 == CAMERA_FRAME_DATA_FD)) {
+            ALOGD("notifyCallback: CAMERA_MSG_PREVIEW_FRAME fd = %d", ext2);
+            data.writeFileDescriptor(ext2);
+        } else {
+            data.writeInt32(ext2);
+        }
         remote()->transact(NOTIFY_CALLBACK, data, &reply, IBinder::FLAG_ONEWAY);
     }
 
@@ -105,8 +110,14 @@ status_t BnCameraClient::onTransact(
             ALOGV("NOTIFY_CALLBACK");
             CHECK_INTERFACE(ICameraClient, data, reply);
             int32_t msgType = data.readInt32();
-            int32_t ext1 = data.readInt32();
-            int32_t ext2 = data.readInt32();
+            int32_t ext1    = data.readInt32();
+            int32_t ext2    = 0;
+            if ((msgType == CAMERA_MSG_PREVIEW_FRAME) && (ext1 == CAMERA_FRAME_DATA_FD)) {
+                ext2 = data.readFileDescriptor();
+                ALOGD("onTransact: CAMERA_MSG_PREVIEW_FRAME fd = %d", ext2);
+            } else {
+                ext2 = data.readInt32();
+            }
             notifyCallback(msgType, ext1, ext2);
             return NO_ERROR;
         } break;
-- 
2.7.4


From 49b5ed519ec946040ae626b2584cf9335ac68ad5 Mon Sep 17 00:00:00 2001
From: Dhananjay Kumar <dhakumar@codeaurora.org>
Date: Thu, 25 Feb 2016 13:48:33 +0530
Subject: [PATCH 15/39] nuplayer: ignore openAudioSink while waiting for
 teardown completion

- AudioSink is reopened on AudioTearDown event as well as on
  decoder output format change. These events are from different
  contexts, independent of each other and can occur concurrently,
  doing set of thread-unsafe operations on audioSink, which
  sometimes may result in fatal error.

- Any request to openSink, after teardown event is received but
  before its completed, is redundant since once teardown is
  completed sink is anyway going to be opened again. Also
  ignoring sink reopen while in teardown would avoid concurrent
  processing of thread-unsafe operations on audioSink.

- Update nuplayer to prevent reopening of sink while teardown is
  still going on.

Conflicts:
	media/libmediaplayerservice/nuplayer/NuPlayer.cpp

 CRs-Fixed: 978013

Change-Id: Ieb3825f133c2099e07d6e92ef101dd5156af8a20
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  9 +++++++
 .../nuplayer/NuPlayerRenderer.cpp                  | 28 ++++++++++++++++++----
 .../nuplayer/NuPlayerRenderer.h                    |  5 +++-
 3 files changed, 36 insertions(+), 6 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 89301d0..99f63ea 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1159,6 +1159,15 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                     ALOGW("Receive a stale message for teardown.");
                     break;
                 }
+                closeAudioSink();
+                mRenderer->flush(
+                        true /* audio */, false /* notifyComplete */);
+                if (mVideoDecoder != NULL) {
+                    mRenderer->flush(
+                            false /* audio */, false /* notifyComplete */);
+                }
+                mRenderer->signalAudioTearDownComplete();
+
                 int64_t positionUs;
                 if (!msg->findInt64("positionUs", &positionUs)) {
                     positionUs = mPreviousSeekTimeUs;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 4f62d4f..42db053 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -124,7 +124,7 @@ NuPlayer::Renderer::Renderer(
       mNextAudioClockUpdateTimeUs(-1),
       mLastAudioMediaTimeUs(-1),
       mAudioOffloadPauseTimeoutGeneration(0),
-      mAudioTornDown(false),
+      mAudioTearingDown(false),
       mCurrentOffloadInfo(AUDIO_INFO_INITIALIZER),
       mCurrentPcmInfo(AUDIO_PCMINFO_INITIALIZER),
       mTotalBuffersQueued(0),
@@ -673,6 +673,12 @@ void NuPlayer::Renderer::onMessageReceived(const sp<AMessage> &msg) {
             break;
         }
 
+        case kWhatAudioTearDownComplete:
+        {
+            onAudioTearDownComplete();
+            break;
+        }
+
         case kWhatAudioOffloadPauseTimeout:
         {
             int32_t generation;
@@ -893,7 +899,7 @@ void NuPlayer::Renderer::drainAudioQueueUntilLastEOS() {
 
 bool NuPlayer::Renderer::onDrainAudioQueue() {
     // do not drain audio during teardown as queued buffers may be invalid.
-    if (mAudioTornDown) {
+    if (mAudioTearingDown) {
         return false;
     }
     // TODO: This call to getPosition checks if AudioTrack has been created
@@ -1726,10 +1732,10 @@ bool NuPlayer::Renderer::getSyncQueues() {
 }
 
 void NuPlayer::Renderer::onAudioTearDown(AudioTearDownReason reason) {
-    if (mAudioTornDown) {
+    if (mAudioTearingDown) {
         return;
     }
-    mAudioTornDown = true;
+    mAudioTearingDown = true;
 
     int64_t currentPositionUs;
     sp<AMessage> notify = mNotify->dup();
@@ -1774,6 +1780,11 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
         uint32_t flags) {
     ALOGV("openAudioSink: offloadOnly(%d) offloadingAudio(%d)",
             offloadOnly, offloadingAudio());
+
+    if (mAudioTearingDown) {
+        ALOGW("openAudioSink: not opening now!, would happen after teardown");
+        return OK;
+    }
     bool audioSinkChanged = false;
 
     int32_t numChannels;
@@ -1968,7 +1979,6 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
     if (audioSinkChanged) {
         onAudioSinkChanged();
     }
-    mAudioTornDown = false;
     return OK;
 }
 
@@ -1978,5 +1988,13 @@ void NuPlayer::Renderer::onCloseAudioSink() {
     mCurrentPcmInfo = AUDIO_PCMINFO_INITIALIZER;
 }
 
+void NuPlayer::Renderer::signalAudioTearDownComplete() {
+    (new AMessage(kWhatAudioTearDownComplete, this))->post();
+}
+
+void NuPlayer::Renderer::onAudioTearDownComplete() {
+    mAudioTearingDown = false;
+}
+
 }  // namespace android
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
index c7df096..16fa914 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
@@ -80,6 +80,7 @@ struct NuPlayer::Renderer : public AHandler {
             uint32_t flags,
             bool *isOffloaded);
     void closeAudioSink();
+    void signalAudioTearDownComplete();
 
     enum {
         kWhatEOS                      = 'eos ',
@@ -89,6 +90,7 @@ struct NuPlayer::Renderer : public AHandler {
         kWhatMediaRenderingStart      = 'mdrd',
         kWhatAudioTearDown            = 'adTD',
         kWhatAudioOffloadPauseTimeout = 'aOPT',
+        kWhatAudioTearDownComplete    = 'aTDC',
     };
 
     enum AudioTearDownReason {
@@ -185,7 +187,7 @@ protected:
     int64_t mLastAudioMediaTimeUs;
 
     int32_t mAudioOffloadPauseTimeoutGeneration;
-    bool mAudioTornDown;
+    bool mAudioTearingDown;
     audio_offload_info_t mCurrentOffloadInfo;
 
     struct PcmInfo {
@@ -257,6 +259,7 @@ protected:
             bool hasVideo,
             uint32_t flags);
     void onCloseAudioSink();
+    void onAudioTearDownComplete();
 
     void notifyEOS(bool audio, status_t finalResult, int64_t delayUs = 0);
     void notifyFlushComplete(bool audio);
-- 
2.7.4


From 1f04dd8bd5a94a8afa754c32a2ee330f69a1e735 Mon Sep 17 00:00:00 2001
From: Divya Narayanan Poojary <dnaray@codeaurora.org>
Date: Thu, 11 Aug 2016 18:13:02 +0530
Subject: [PATCH 16/39] NuPlayer: cancel pauseTimeout when tearing down offload

-Issue is when MO call is initiated during offload playback,
 audio is not resuming after disconnecting the call. Reason is,
 when call is started, audio will pause and pauseTimeOut will
 start for offload session. Meanwhile set_mode will invalidate
 all streams, which will send TEAR_DOWN event and restart audio
 with deep buffer mode. But pauseTimeout is not canceled. Since
 source is paused, empty buffers will not be sent to decoder
 during call, this is leading to pause timed out and tear down
 audio again. When call is disconnected, music will not resume
 because, nuplayer is in tearing down state.

-Fix is to call cancelPauseTimeOut when offload session is paused
 and the session is tearing down.

CRs-Fixed: 1049259

Change-Id: I2ddb802647453c6349bf30397f702e72776b649f
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp         | 1 +
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 4 ++++
 2 files changed, 5 insertions(+)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 99f63ea..9f9ae2e 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1157,6 +1157,7 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                 if (reason == Renderer::kDueToTimeout && !(mPaused && mOffloadAudio)) {
                     // TimeoutWhenPaused is only for offload mode.
                     ALOGW("Receive a stale message for teardown.");
+                    mRenderer->signalAudioTearDownComplete();
                     break;
                 }
                 closeAudioSink();
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 42db053..4651440 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1735,6 +1735,10 @@ void NuPlayer::Renderer::onAudioTearDown(AudioTearDownReason reason) {
     if (mAudioTearingDown) {
         return;
     }
+    if (offloadingAudio() && mPaused) {
+        cancelAudioOffloadPauseTimeout();
+    }
+
     mAudioTearingDown = true;
 
     int64_t currentPositionUs;
-- 
2.7.4


From 14f4094b70ae51dc2472b37b55700c692d6621e2 Mon Sep 17 00:00:00 2001
From: Zhou Song <zhous@codeaurora.org>
Date: Thu, 14 Apr 2016 12:10:06 +0800
Subject: [PATCH 17/39] audio: add support for error handling of dsp SSR

audio: Support for compress offload recovery
Change-Id: I08a5ea333732b76bb9df110d905daae074b7864b

AudioFlinger: Invalidate offload track during SSR
Change-Id: I728cfcadc8cd734914b94000a711d1e86bcfad9d

Audio: post error to client during SSR
Change-Id: Idf10939f1eb0c719a692e4f53f6e3040633fab40

nuplayer: update anchor time for offload usecase
Change-Id: Ib6e0f251207c87ad1525041d07187cef91f4dda5

Change-Id: I6404f6425d7b17260ade83f2681eacf31db488c5
---
 media/libmedia/AudioTrack.cpp                         |  8 ++++++--
 media/libmediaplayerservice/MediaPlayerService.cpp    |  6 +++++-
 .../nuplayer/NuPlayerRenderer.cpp                     | 18 +++++++++++++-----
 media/libstagefright/MPEG4Writer.cpp                  |  6 ++++--
 media/libstagefright/MediaCodecSource.cpp             | 10 +++++++---
 services/audioflinger/AudioFlinger.cpp                | 19 +++++++++++++++++--
 6 files changed, 52 insertions(+), 15 deletions(-)

diff --git a/media/libmedia/AudioTrack.cpp b/media/libmedia/AudioTrack.cpp
index 8ad9800..1d8ccb4 100644
--- a/media/libmedia/AudioTrack.cpp
+++ b/media/libmedia/AudioTrack.cpp
@@ -1109,6 +1109,7 @@ status_t AudioTrack::getPosition(uint32_t *position)
     // There may be some latency differences between the HAL position and the proxy position.
     if (isOffloadedOrDirect_l() && !isPurePcmData_l()) {
         uint32_t dspFrames = 0;
+        status_t status;
 
         if (isOffloaded_l() && ((mState == STATE_PAUSED) || (mState == STATE_PAUSED_STOPPING))) {
             ALOGV("getPosition called in paused state, return cached position %u", mPausedPosition);
@@ -1118,8 +1119,11 @@ status_t AudioTrack::getPosition(uint32_t *position)
 
         if (mOutput != AUDIO_IO_HANDLE_NONE) {
             uint32_t halFrames; // actually unused
-            (void) AudioSystem::getRenderPosition(mOutput, &halFrames, &dspFrames);
-            // FIXME: on getRenderPosition() error, we return OK with frame position 0.
+            status = AudioSystem::getRenderPosition(mOutput, &halFrames, &dspFrames);
+            if (status != NO_ERROR) {
+                ALOGW("failed to getRenderPosition for offload session");
+                return INVALID_OPERATION;
+            }
         }
         // FIXME: dspFrames may not be zero in (mState == STATE_STOPPED || mState == STATE_FLUSHED)
         // due to hardware latency. We leave this behavior for now.
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index 921eb3d..07a4395 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -1541,7 +1541,11 @@ int64_t MediaPlayerService::AudioOutput::getPlayedOutDurationUs(int64_t nowUs) c
         //        numFramesPlayed, (long long)numFramesPlayedAt);
     } else {                         // case 3: transitory at new track or audio fast tracks.
         res = mTrack->getPosition(&numFramesPlayed);
-        CHECK_EQ(res, (status_t)OK);
+        if (res != OK) {
+            // return with invalid duration to indicate playback position should
+            // be queried from MediaClock using system clock
+            return -1;
+        }
         numFramesPlayedAt = nowUs;
         numFramesPlayedAt += 1000LL * mTrack->latency() / 2; /* XXX */
         //ALOGD("getPosition: %u %lld", numFramesPlayed, (long long)numFramesPlayedAt);
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 4651440..9336418 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -483,9 +483,11 @@ void NuPlayer::Renderer::onMessageReceived(const sp<AMessage> &msg) {
 
             if (onDrainAudioQueue()) {
                 uint32_t numFramesPlayed;
-                CHECK_EQ(mAudioSink->getPosition(&numFramesPlayed),
-                         (status_t)OK);
-
+                if (mAudioSink->getPosition(&numFramesPlayed) != OK) {
+                    ALOGE("Error in time stamp query, return from here.\
+                             Fillbuffer is called as part of session recreation");
+                    break;
+                }
                 uint32_t numFramesPendingPlayout =
                     mNumFramesWritten - numFramesPlayed;
 
@@ -839,10 +841,16 @@ size_t NuPlayer::Renderer::fillAudioBuffer(void *buffer, size_t size) {
 
     if (mAudioFirstAnchorTimeMediaUs >= 0) {
         int64_t nowUs = ALooper::GetNowUs();
-        int64_t nowMediaUs =
-            mAudioFirstAnchorTimeMediaUs + mAudioSink->getPlayedOutDurationUs(nowUs);
+        int64_t nowMediaUs = 0;
+        int64_t playedDuration = mAudioSink->getPlayedOutDurationUs(nowUs);
+        if (playedDuration >= 0) {
+            nowMediaUs = mAudioFirstAnchorTimeMediaUs + playedDuration;
+        } else {
+            getCurrentPosition(&nowMediaUs);
+        }
         // we don't know how much data we are queueing for offloaded tracks.
         mMediaClock->updateAnchor(nowMediaUs, nowUs, INT64_MAX);
+        mAnchorTimeMediaUs = nowMediaUs;
     }
 
     // for non-offloaded audio, we need to compute the frames written because
diff --git a/media/libstagefright/MPEG4Writer.cpp b/media/libstagefright/MPEG4Writer.cpp
index c400cc0..aa05ea1 100644
--- a/media/libstagefright/MPEG4Writer.cpp
+++ b/media/libstagefright/MPEG4Writer.cpp
@@ -2803,8 +2803,10 @@ status_t MPEG4Writer::Track::threadEntry() {
     if (mIsAudio) {
         ALOGI("Audio track drift time: %" PRId64 " us", mOwner->getDriftTimeUs());
     }
-
-    if (err == ERROR_END_OF_STREAM) {
+    // if err is ERROR_IO (ex: during SSR), return OK to save the
+    // recorded file successfully. Session tear down will happen as part of
+    // client callback
+    if ((mIsAudio && (err == ERROR_IO)) || (err == ERROR_END_OF_STREAM)) {
         return OK;
     }
     return err;
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index b5e2eea..abd3338 100644
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -38,6 +38,7 @@
 #include <media/stagefright/PersistentSurface.h>
 #include <media/stagefright/Utils.h>
 #include <stagefright/AVExtensions.h>
+#include <OMX_Core.h>
 
 namespace android {
 
@@ -613,6 +614,9 @@ void MediaCodecSource::signalEOS(status_t err) {
             output->mBufferQueue.clear();
             output->mEncoderReachedEOS = true;
             output->mErrorCode = err;
+            if (err == OMX_ErrorHardware) {
+                output->mErrorCode = ERROR_IO;
+            }
             output->mCond.signal();
 
             reachedEOS = true;
@@ -707,7 +711,7 @@ status_t MediaCodecSource::feedEncoderInputBuffers() {
             status_t err = mEncoder->getInputBuffer(bufferIndex, &inbuf);
             if (err != OK || inbuf == NULL) {
                 mbuf->release();
-                signalEOS();
+                signalEOS(err);
                 break;
             }
 
@@ -868,7 +872,7 @@ void MediaCodecSource::onMessageReceived(const sp<AMessage> &msg) {
             sp<ABuffer> outbuf;
             status_t err = mEncoder->getOutputBuffer(index, &outbuf);
             if (err != OK || outbuf == NULL) {
-                signalEOS();
+                signalEOS(err);
                 break;
             }
 
@@ -942,7 +946,7 @@ void MediaCodecSource::onMessageReceived(const sp<AMessage> &msg) {
             CHECK(msg->findInt32("err", &err));
             ALOGE("Encoder (%s) reported error : 0x%x",
                     mIsVideo ? "video" : "audio", err);
-            signalEOS();
+            signalEOS(err);
        }
        break;
     }
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 55ddb2c..92df7b3 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -1121,9 +1121,24 @@ status_t AudioFlinger::setParameters(audio_io_handle_t ioHandle, const String8&
             }
             mHardwareStatus = AUDIO_HW_IDLE;
         }
-        // disable AEC and NS if the device is a BT SCO headset supporting those pre processings
+
         AudioParameter param = AudioParameter(keyValuePairs);
-        String8 value;
+        String8 value, key;
+        key = String8("SND_CARD_STATUS");
+        if (param.get(key, value) == NO_ERROR) {
+            ALOGV("Set keySoundCardStatus:%s", value.string());
+            if ((value.find("OFFLINE", 0) != -1)) {
+                ALOGV("OFFLINE detected - call InvalidateTracks()");
+                for (size_t i = 0; i < mPlaybackThreads.size(); i++) {
+                    PlaybackThread *thread = mPlaybackThreads.valueAt(i).get();
+                    if (thread->getOutput()->flags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) {
+                         thread->invalidateTracks(AUDIO_STREAM_MUSIC);
+                    }
+                }
+            }
+        }
+
+        // disable AEC and NS if the device is a BT SCO headset supporting those pre processings
         if (param.get(String8(AUDIO_PARAMETER_KEY_BT_NREC), value) == NO_ERROR) {
             bool btNrecIsOff = (value == AUDIO_PARAMETER_VALUE_OFF);
             if (mBtNrecIsOff != btNrecIsOff) {
-- 
2.7.4


From ec02b3643745fce199db44fc462193277ad2e3b6 Mon Sep 17 00:00:00 2001
From: Charlie Zheng <czhen@dolby.com>
Date: Mon, 29 Aug 2016 15:36:16 +0800
Subject: [PATCH 18/39] Merge DAX changes

Change-Id: Iccda9fd7166321ee3c2fdd446e0d862db32eefa2
(cherry picked from commit 803ce3d3258bc45ac322b8fa9c48f269adbf2c7b)
---
 cmds/stagefright/Android.mk                        |  18 +++
 cmds/stagefright/stagefright.cpp                   |  23 ++++
 include/media/stagefright/ACodec.h                 |  24 ++++
 include/media/stagefright/AudioPlayer.h            |  22 +++
 include/media/stagefright/MediaDefs.h              |  22 +++
 media/audioserver/Android.mk                       |  20 +++
 media/audioserver/main_audioserver.cpp             |  25 ++++
 media/libeffects/data/audio_effects.conf           |  43 ++++++
 media/libmediaplayerservice/Android.mk             |  18 +++
 media/libmediaplayerservice/MediaPlayerService.cpp |  38 +++++-
 media/libmediaplayerservice/MediaPlayerService.h   |  27 ++++
 media/libmediaplayerservice/nuplayer/Android.mk    |  18 +++
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  26 ++++
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |  22 +++
 .../nuplayer/NuPlayerDecoder.cpp                   |  25 ++++
 .../nuplayer/NuPlayerDecoder.h                     |  22 +++
 media/libstagefright/ACodec.cpp                    |  41 ++++++
 media/libstagefright/Android.mk                    |  18 +++
 media/libstagefright/AudioPlayer.cpp               |  25 ++++
 media/libstagefright/MPEG4Extractor.cpp            | 148 +++++++++++++++++++++
 media/libstagefright/MediaCodecList.cpp            |  22 +++
 media/libstagefright/MediaDefs.cpp                 |  22 +++
 media/libstagefright/Utils.cpp                     |  24 ++++
 media/libstagefright/mpeg2ts/ATSParser.cpp         |  28 ++++
 media/libstagefright/mpeg2ts/ATSParser.h           |  22 +++
 media/libstagefright/mpeg2ts/Android.mk            |  18 +++
 media/libstagefright/mpeg2ts/ESQueue.cpp           |  58 ++++++++
 media/libstagefright/mpeg2ts/ESQueue.h             |  27 ++++
 media/libstagefright/mpeg2ts/MPEG2PSExtractor.cpp  |  27 ++++
 media/libstagefright/omx/Android.mk                |  18 +++
 media/libstagefright/omx/SoftOMXPlugin.cpp         |  24 ++++
 services/audioflinger/Android.mk                   |  18 +++
 services/audioflinger/AudioFlinger.cpp             |  36 +++++
 services/audioflinger/AudioFlinger.h               |  25 ++++
 services/audioflinger/Effects.cpp                  |  31 +++++
 services/audioflinger/Threads.cpp                  |  78 +++++++++++
 services/audioflinger/Tracks.cpp                   |  58 ++++++++
 services/audiopolicy/Android.mk                    |  29 +++-
 .../managerdefault/AudioPolicyManager.cpp          |  88 ++++++++++++
 .../managerdefault/AudioPolicyManager.h            |  27 ++++
 40 files changed, 1302 insertions(+), 3 deletions(-)

diff --git a/cmds/stagefright/Android.mk b/cmds/stagefright/Android.mk
index 9e15a81..ea3214a 100644
--- a/cmds/stagefright/Android.mk
+++ b/cmds/stagefright/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
@@ -18,6 +31,11 @@ LOCAL_C_INCLUDES:= \
 	external/jpeg \
 
 LOCAL_CFLAGS += -Wno-multichar -Werror -Wall
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 LOCAL_CLANG := true
 
 LOCAL_MODULE_TAGS := optional
diff --git a/cmds/stagefright/stagefright.cpp b/cmds/stagefright/stagefright.cpp
index ca68722..ec8305e 100644
--- a/cmds/stagefright/stagefright.cpp
+++ b/cmds/stagefright/stagefright.cpp
@@ -12,6 +12,24 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #include <inttypes.h>
@@ -632,6 +650,11 @@ static void dumpCodecProfiles(bool queryDecoders) {
         MEDIA_MIMETYPE_AUDIO_G711_ALAW, MEDIA_MIMETYPE_AUDIO_VORBIS,
         MEDIA_MIMETYPE_VIDEO_VP8, MEDIA_MIMETYPE_VIDEO_VP9,
         MEDIA_MIMETYPE_VIDEO_DOLBY_VISION
+#ifdef DOLBY_ENABLE
+        ,
+        MEDIA_MIMETYPE_AUDIO_AC3,
+        MEDIA_MIMETYPE_AUDIO_EAC3
+#endif // DOLBY_END
     };
 
     const char *codecType = queryDecoders? "decoder" : "encoder";
diff --git a/include/media/stagefright/ACodec.h b/include/media/stagefright/ACodec.h
index 7da82c1..690bc37 100644
--- a/include/media/stagefright/ACodec.h
+++ b/include/media/stagefright/ACodec.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2015-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef A_CODEC_H_
@@ -563,6 +582,11 @@ protected:
 
     // Send EOS on input stream.
     void onSignalEndOfInputStream();
+#ifdef DOLBY_ENABLE
+    status_t setDolbyParameterOnEndpChange();
+    void     setDolbyParameter(const sp<AMessage> &msg);
+    status_t setDolbyParameterOnProcessedAudio(const sp<AMessage> &params);
+#endif // DOLBY_END
 
     virtual void setBFrames(OMX_VIDEO_PARAM_MPEG4TYPE *mpeg4type) {}
     virtual void setBFrames(OMX_VIDEO_PARAM_AVCTYPE *h264type,
diff --git a/include/media/stagefright/AudioPlayer.h b/include/media/stagefright/AudioPlayer.h
index f7499b6..460ee74 100644
--- a/include/media/stagefright/AudioPlayer.h
+++ b/include/media/stagefright/AudioPlayer.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2015-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef AUDIO_PLAYER_H_
@@ -118,6 +137,9 @@ private:
 
     AudioPlayer(const AudioPlayer &);
     AudioPlayer &operator=(const AudioPlayer &);
+#ifdef DOLBY_ENABLE
+    void setDolbyProcessedAudio(sp<MetaData> &format);
+#endif // DOLBY_END
 };
 
 }  // namespace android
diff --git a/include/media/stagefright/MediaDefs.h b/include/media/stagefright/MediaDefs.h
index 9eae7ca..bf86cc1 100644
--- a/include/media/stagefright/MediaDefs.h
+++ b/include/media/stagefright/MediaDefs.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef MEDIA_DEFS_H_
@@ -50,6 +69,9 @@ extern const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS;
 extern const char *MEDIA_MIMETYPE_AUDIO_MSGSM;
 extern const char *MEDIA_MIMETYPE_AUDIO_AC3;
 extern const char *MEDIA_MIMETYPE_AUDIO_EAC3;
+#ifdef DOLBY_ENABLE
+extern const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC;
+#endif // DOLBY_END
 
 extern const char *MEDIA_MIMETYPE_CONTAINER_MPEG4;
 extern const char *MEDIA_MIMETYPE_CONTAINER_WAV;
diff --git a/media/audioserver/Android.mk b/media/audioserver/Android.mk
index 5ce1798..0947687 100644
--- a/media/audioserver/Android.mk
+++ b/media/audioserver/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
@@ -55,5 +68,12 @@ LOCAL_MODULE := audioserver
 LOCAL_INIT_RC := audioserver.rc
 
 LOCAL_CFLAGS := -Werror -Wall
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+    LOCAL_SHARED_LIBRARIES += $(dolby_shared_service_lib)
+    LOCAL_STATIC_LIBRARIES += $(dolby_static_service_lib)
+endif
+# DOLBY_END
 
 include $(BUILD_EXECUTABLE)
diff --git a/media/audioserver/main_audioserver.cpp b/media/audioserver/main_audioserver.cpp
index 4a7a988..6a7f9ca 100644
--- a/media/audioserver/main_audioserver.cpp
+++ b/media/audioserver/main_audioserver.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #define LOG_TAG "audioserver"
@@ -33,6 +52,9 @@
 #include "MediaLogService.h"
 #include "RadioService.h"
 #include "SoundTriggerHwService.h"
+#ifdef DOLBY_ENABLE
+#include "DolbyMemoryService.h"
+#endif
 
 using namespace android;
 
@@ -128,6 +150,9 @@ int main(int argc __unused, char **argv)
         AudioFlinger::instantiate();
         AudioPolicyService::instantiate();
         RadioService::instantiate();
+#ifdef DOLBY_ENABLE
+        DolbyMemoryService::instantiate();
+#endif
         SoundTriggerHwService::instantiate();
         ProcessState::self()->startThreadPool();
         IPCThreadState::self()->joinThreadPool();
diff --git a/media/libeffects/data/audio_effects.conf b/media/libeffects/data/audio_effects.conf
index c3c4b67..9105b5d 100644
--- a/media/libeffects/data/audio_effects.conf
+++ b/media/libeffects/data/audio_effects.conf
@@ -1,3 +1,22 @@
+#
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+#  (C) 2012-2016 Dolby Laboratories, Inc.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+#
 # List of effect libraries to load. Each library element must contain a "path" element
 # giving the full path of the library .so file.
 #    libraries {
@@ -38,6 +57,14 @@ libraries {
   loudness_enhancer {
     path /system/lib/soundfx/libldnhncr.so
   }
+#DOLBY_ENABLE
+  dap_sw {
+    path /system/vendor/lib/soundfx/libswdap.so
+  }
+  dap_hw {
+    path /system/vendor/lib/soundfx/libhwdap.so
+  }
+#DOLBY_END
 }
 
 # Default pre-processing library. Add to audio_effect.conf "libraries" section if
@@ -129,6 +156,22 @@ effects {
     library loudness_enhancer
     uuid fa415329-2034-4bea-b5dc-5b381c8d1e2c
   }
+#DOLBY_ENABLE
+  dap {
+    library proxy
+    uuid 9d4921da-8225-4f29-aefa-39537a04bcaa
+
+    libsw {
+      library dap_sw
+      uuid 6ab06da4-c516-4611-8166-452799218539
+    }
+
+    libhw {
+      library dap_hw
+      uuid a0c30891-8246-4aef-b8ad-d53e26da0253
+    }
+  }
+#DOLBY_END
 }
 
 # Default pre-processing effects. Add to audio_effect.conf "effects" section if
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index 499b965..b261536 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 
 #
@@ -60,6 +73,11 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/frameworks/av/media/libavextensions                      \
 
 LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 LOCAL_CLANG := true
 
 LOCAL_MODULE:= libmediaplayerservice
diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index 07a4395..effe14d 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+**
+** This file was modified by Dolby Laboratories, Inc. The portions of the
+** code that are surrounded by "DOLBY..." are copyrighted and
+** licensed separately, as follows:
+**
+**  (C) 2011-2016 Dolby Laboratories, Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**    http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+**
 */
 
 // Proxy for media player implementations
@@ -82,6 +101,9 @@
 #include "HDCP.h"
 #include "HTTPBase.h"
 #include "RemoteDisplay.h"
+#ifdef DOLBY_ENABLE
+#include "DolbyMediaPlayerServiceExtImpl.h"
+#endif // DOLBY_END
 
 namespace {
 using android::media::Metadata;
@@ -1409,6 +1431,9 @@ MediaPlayerService::AudioOutput::AudioOutput(audio_session_t sessionId, int uid,
     }
 
     setMinBufferCount();
+#ifdef DOLBY_ENABLE
+    mProcessedAudio = false;
+#endif // DOLBY_END
 }
 
 MediaPlayerService::AudioOutput::~AudioOutput()
@@ -1586,6 +1611,9 @@ status_t MediaPlayerService::AudioOutput::getFramesWritten(uint32_t *frameswritt
 status_t MediaPlayerService::AudioOutput::setParameters(const String8& keyValuePairs)
 {
     Mutex::Autolock lock(mLock);
+#ifdef DOLBY_ENABLE
+    setDolbyParameters(keyValuePairs);
+#endif // DOLBY_END
     if (mTrack == 0) return NO_INIT;
     return mTrack->setParameters(keyValuePairs);
 }
@@ -1859,7 +1887,10 @@ status_t MediaPlayerService::AudioOutput::open(
                 mCallbackData->setOutput(this);
             }
             delete newcbd;
-            return updateTrack();
+#ifdef DOLBY_ENABLE
+            updateTrackOnAudioProcessed(mTrack, reuse);
+#endif // DOLBY_END
+            return OK;
         }
     }
 
@@ -1900,7 +1931,10 @@ status_t MediaPlayerService::AudioOutput::updateTrack() {
             res = mTrack->attachAuxEffect(mAuxEffectId);
         }
     }
-    ALOGV("updateTrack() DONE status %d", res);
+#ifdef DOLBY_ENABLE
+    updateTrackOnAudioProcessed(t, false);
+#endif // DOLBY_END
+    ALOGV("open() DONE status %d", res);
     return res;
 }
 
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index 7a41d9c..4c1af3e 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+**
+** This file was modified by Dolby Laboratories, Inc. The portions of the
+** code that are surrounded by "DOLBY..." are copyrighted and
+** licensed separately, as follows:
+**
+**  (C) 2011-2016 Dolby Laboratories, Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**    http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+**
 */
 
 #ifndef ANDROID_MEDIAPLAYERSERVICE_H
@@ -135,7 +154,15 @@ class MediaPlayerService : public BnMediaPlayerService
                 int event, void *me, void *info);
                void             deleteRecycledTrack_l();
                void             close_l();
+<<<<<<< HEAD
            status_t             updateTrack();
+=======
+#ifdef DOLBY_ENABLE
+               void             setDolbyParameters(const String8& keyValuePairs);
+               void             updateTrackOnAudioProcessed(sp<AudioTrack> t, bool trackReused);
+               bool             mProcessedAudio;
+#endif // DOLBY_END
+>>>>>>> 397691f... Merge DAX changes
 
         sp<AudioTrack>          mTrack;
         sp<AudioTrack>          mRecycledTrack;
diff --git a/media/libmediaplayerservice/nuplayer/Android.mk b/media/libmediaplayerservice/nuplayer/Android.mk
index 005cb4b..ef6100a 100644
--- a/media/libmediaplayerservice/nuplayer/Android.mk
+++ b/media/libmediaplayerservice/nuplayer/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
@@ -32,6 +45,11 @@ LOCAL_CFLAGS += -Werror -Wall
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 LOCAL_CFLAGS += -DENABLE_STAGEFRIGHT_EXPERIMENTS
 endif
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 
 LOCAL_CLANG := true
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 9f9ae2e..fbecef4 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -57,6 +76,9 @@
 #include "ESDS.h"
 #include <media/stagefright/Utils.h>
 #include "mediaplayerservice/AVNuExtensions.h"
+#ifdef DOLBY_ENABLE
+#include "DolbyNuPlayerExtImpl.h"
+#endif // DOLBY_END
 
 namespace android {
 
@@ -1075,6 +1097,10 @@ void NuPlayer::onMessageReceived(const sp<AMessage> &msg) {
                         break;                    // Finish anyways.
                 }
                 notifyListener(MEDIA_ERROR, MEDIA_ERROR_UNKNOWN, err);
+#ifdef DOLBY_ENABLE
+            } else if (what == kWhatDlbCpProc) {
+                onDolbyMessageReceived();
+#endif // DOLBY_END
             } else {
                 ALOGV("Unhandled decoder notification %d '%c%c%c%c'.",
                       what,
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index ffd7e86..44cc152 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2015-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef NU_PLAYER_H_
@@ -284,6 +303,9 @@ protected:
     void sendTimedTextData(const sp<ABuffer> &buffer);
 
     void writeTrackInfo(Parcel* reply, const sp<AMessage> format) const;
+#ifdef DOLBY_ENABLE
+    void onDolbyMessageReceived();
+#endif // DOLBY_END
 
     DISALLOW_EVIL_CONSTRUCTORS(NuPlayer);
 };
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index c2adabf..c1e7592 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -42,6 +61,9 @@
 
 #include "avc_utils.h"
 #include "ATSParser.h"
+#ifdef DOLBY_ENABLE
+#include "DolbyNuPlayerDecoderExtImpl.h"
+#endif // DOLBY_END
 
 namespace android {
 
@@ -332,6 +354,9 @@ void NuPlayer::Decoder::onConfigure(const sp<AMessage> &format) {
     sp<AMessage> reply = new AMessage(kWhatCodecNotify, this);
     mCodec->setCallback(reply);
 
+#ifdef DOLBY_ENABLE
+    setDolbyMessage();
+#endif // DOLBY_END
     err = mCodec->start();
     if (err != OK) {
         ALOGE("Failed to start %s decoder (err=%d)", mComponentName.c_str(), err);
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
index aedbcc9..e02ffab 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2015-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef NUPLAYER_DECODER_H_
@@ -129,6 +148,9 @@ protected:
     void finishHandleDiscontinuity(bool flushOnTimeChange);
 
     void notifyResumeCompleteIfNecessary();
+#ifdef DOLBY_ENABLE
+    void setDolbyMessage();
+#endif // DOLBY_END
 
     DISALLOW_EVIL_CONSTRUCTORS(Decoder);
 };
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index e11edee..52de6ad 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -54,6 +73,9 @@
 #include "include/avc_utils.h"
 #include "include/DataConverter.h"
 #include "omx/OMXUtils.h"
+#ifdef DOLBY_ENABLE
+#include "DolbyACodecExtImpl.h"
+#endif // DOLBY_END
 
 #include <stagefright/AVExtensions.h>
 
@@ -1681,6 +1703,10 @@ const char *ACodec::getComponentRole(
             "audio_decoder.ac3", "audio_encoder.ac3" },
         { MEDIA_MIMETYPE_AUDIO_EAC3,
             "audio_decoder.eac3", "audio_encoder.eac3" },
+#ifdef DOLBY_ENABLE
+        { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,
+            "audio_decoder.eac3_joc", NULL },
+#endif // DOLBY_END
     };
 
     static const size_t kNumMimeToRole =
@@ -6824,6 +6850,15 @@ bool ACodec::LoadedState::onMessageReceived(const sp<AMessage> &msg) {
             handled = true;
             break;
         }
+#ifdef DOLBY_ENABLE
+        case ACodec::kWhatSetParameters:
+        {
+            mCodec->setDolbyParameter(msg);
+
+            handled = true;
+            break;
+        }
+#endif // DOLBY_END
 
         default:
             return BaseState::onMessageReceived(msg);
@@ -7070,6 +7105,9 @@ void ACodec::LoadedState::onStart() {
     if (err != OK) {
         mCodec->signalError(OMX_ErrorUndefined, makeNoSideEffectStatus(err));
     } else {
+#ifdef DOLBY_ENABLE
+        mCodec->setDolbyParameterOnEndpChange();
+#endif // DOLBY_END
         mCodec->changeState(mCodec->mLoadedToIdleState);
     }
 }
@@ -7580,6 +7618,9 @@ status_t ACodec::setParameters(const sp<AMessage> &params) {
             err = OK;
         }
     }
+#ifdef DOLBY_ENABLE
+    return setDolbyParameterOnProcessedAudio(params);
+#endif // DOLBY_END
 
     status_t err = configureTemporalLayers(params, false /* inConfigure */, mOutputFormat);
     if (err != OK) {
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 0a26bd9..7187922 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
@@ -133,6 +146,11 @@ LOCAL_CFLAGS += -Wno-multichar -Werror -Wno-error=deprecated-declarations -Wall
 ifneq (,$(filter userdebug eng,$(TARGET_BUILD_VARIANT)))
 LOCAL_CFLAGS += -DENABLE_STAGEFRIGHT_EXPERIMENTS
 endif
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 
 LOCAL_CLANG := true
 LOCAL_SANITIZE := unsigned-integer-overflow signed-integer-overflow
diff --git a/media/libstagefright/AudioPlayer.cpp b/media/libstagefright/AudioPlayer.cpp
index b3fb8d4..99d7a7d 100644
--- a/media/libstagefright/AudioPlayer.cpp
+++ b/media/libstagefright/AudioPlayer.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #include <inttypes.h>
@@ -33,6 +52,9 @@
 #include <media/stagefright/MediaSource.h>
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
+#ifdef DOLBY_ENABLE
+#include "DolbyAudioPlayerExtImpl.h"
+#endif // DOLBY_END
 
 namespace android {
 
@@ -264,6 +286,9 @@ status_t AudioPlayer::start(bool sourceAlreadyStarted) {
 
     mStarted = true;
     mPlaying = true;
+#ifdef DOLBY_ENABLE
+    setDolbyProcessedAudio(format);
+#endif // DOLBY_END
 
     return OK;
 }
diff --git a/media/libstagefright/MPEG4Extractor.cpp b/media/libstagefright/MPEG4Extractor.cpp
index f42fbcf..bbcf741 100644
--- a/media/libstagefright/MPEG4Extractor.cpp
+++ b/media/libstagefright/MPEG4Extractor.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -215,6 +234,9 @@ MPEG4DataSource::MPEG4DataSource(const sp<DataSource> &source)
       mCachedOffset(0),
       mCachedSize(0),
       mCache(NULL) {
+#ifdef DOLBY_ENABLE
+      ALOGV("@DDP MPEG4DataSource::MPEG4DataSource");
+#endif // DOLBY_END
 }
 
 MPEG4DataSource::~MPEG4DataSource() {
@@ -323,6 +345,9 @@ static void hexdump(const void *_data, size_t size) {
 }
 
 static const char *FourCC2MIME(uint32_t fourcc) {
+#ifdef DOLBY_ENABLE
+    ALOGV("@DDP FourCC2MIME");
+#endif // DOLBY_END
     switch (fourcc) {
         case FOURCC('m', 'p', '4', 'a'):
             return MEDIA_MIMETYPE_AUDIO_AAC;
@@ -347,7 +372,18 @@ static const char *FourCC2MIME(uint32_t fourcc) {
         case FOURCC('h', 'v', 'c', '1'):
         case FOURCC('h', 'e', 'v', '1'):
             return MEDIA_MIMETYPE_VIDEO_HEVC;
+#ifdef DOLBY_ENABLE
+        case FOURCC('a', 'c', '-', '3'):
+            ALOGV("@DDP Track FOURCC = 'ac-3'");
+            return MEDIA_MIMETYPE_AUDIO_AC3;
+        case FOURCC('e', 'c', '-', '3'):
+            ALOGV("@DDP Track FOURCC = 'ec-3'");
+            return MEDIA_MIMETYPE_AUDIO_EAC3;
+#endif // DOLBY_END
         default:
+#ifdef DOLBY_ENABLE
+            ALOGD("@DDP FourCC2Mime default (not found)");
+#endif // DOLBY_END
             CHECK(!"should not be here.");
             return NULL;
     }
@@ -381,6 +417,9 @@ MPEG4Extractor::MPEG4Extractor(const sp<DataSource> &source)
       mFileMetaData(new MetaData),
       mFirstSINF(NULL),
       mIsDrm(false) {
+#ifdef DOLBY_ENABLE
+      ALOGV("@DDP MPEG4Extractor::MPEG4Extractor");
+#endif // DOLBY_END
 }
 
 MPEG4Extractor::~MPEG4Extractor() {
@@ -1394,6 +1433,10 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
         case FOURCC('e', 'n', 'c', 'a'):
         case FOURCC('s', 'a', 'm', 'r'):
         case FOURCC('s', 'a', 'w', 'b'):
+#ifdef DOLBY_ENABLE
+        case FOURCC('a', 'c', '-', '3'):
+        case FOURCC('e', 'c', '-', '3'):
+#endif // DOLBY_END
         {
             if (mIsQT && chunk_type == FOURCC('m', 'p', '4', 'a')
                     && depth >= 1 && mPath[depth - 1] == FOURCC('w', 'a', 'v', 'e')) {
@@ -1461,7 +1504,20 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
 
             if (chunk_type != FOURCC('e', 'n', 'c', 'a')) {
                 // if the chunk type is enca, we'll get the type from the sinf/frma box later
+#ifdef DOLBY_ENABLE
+                const char *mime;
+                CHECK(mLastTrack->meta->findCString(kKeyMIMEType, &mime));
+                // Track mime-type should have been set at 'trak'
+                // Only set the mimetype here to the chunk type if it hasn't changed
+                // Eg. EC3SpecificBox may already have set it to a more appropriate value
+                if (!strcmp(mime, "application/octet-stream")) {
+                    ALOGV("@DDP Set mimetype from %s to %s", mime, FourCC2MIME(chunk_type));
+#endif // DOLBY_END
                 mLastTrack->meta->setCString(kKeyMIMEType, FourCC2MIME(chunk_type));
+#ifdef DOLBY_ENABLE
+                ALOGV("@DDP FourCC:'%s'", FourCC2MIME(chunk_type));
+                }
+#endif // DOLBY_END
                 AdjustChannelsAndRate(chunk_type, &num_channels, &sample_rate);
             }
             ALOGV("*** coding='%s' %d channels, size %d, rate %d\n",
@@ -1481,7 +1537,96 @@ status_t MPEG4Extractor::parseChunk(off64_t *offset, int depth) {
             }
             break;
         }
+#ifdef DOLBY_ENABLE
+        case FOURCC('d', 'a', 'c', '3'):
+        {
+            uint8_t buffer[3];
+            if (chunk_data_size < (ssize_t)sizeof(buffer)) {
+                // 3 bytes for AC3SpecificBox.
+                return ERROR_MALFORMED;
+            }
+
+            if (mDataSource->readAt(
+                        data_offset, buffer, sizeof(buffer)) < (ssize_t)sizeof(buffer)) {
+                return ERROR_IO;
+            }
+            uint32_t acmod = (buffer[1] >> 3) & 0x3;
+            if (acmod > 2) {
+               mLastTrack->meta->setInt32(kKeyChannelCount, 6); // 5.1 case
+            }
+            *offset += chunk_size;
+            break;
+        }
+
+        case FOURCC('d', 'e', 'c', '3'):
+        {
+            // Only allowed on E-AC3 tracks
+            if (!(mPath.size() >= 2 && (
+                    mPath[mPath.size() - 2] == FOURCC('e', 'c', '-', '3')))) {
+                return ERROR_MALFORMED;
+            }
+
+            // Minimum EC3SpecificBox Length
+            if (chunk_data_size < 5) {
+                return ERROR_MALFORMED;
+            }
+
+            // JOC Extensions allow EC3SpecificBox to be boundless in size
+            // Impose a realistic limit of 256 bytes
+            uint8_t buffer[256];
+            if (chunk_data_size > (off64_t)sizeof(buffer)) {
+                return ERROR_BUFFER_TOO_SMALL;
+            }
+
+            if (mDataSource->readAt(
+                    data_offset, buffer, chunk_data_size) < chunk_data_size) {
+                return ERROR_IO;
+            }
+            ALOGV("@DDP - Valid EC3SpecificBox detected");
 
+            uint8_t data_offset = 1;
+            uint32_t num_channels = 2;
+            uint8_t num_ind_sub = (buffer[data_offset] & 0x7) + 1; // 0 = One I substream
+            ALOGV("@DDP - EC3SpecificBox reports num_ind_sub = %d", num_ind_sub);
+
+            for (uint8_t i = 0; i < num_ind_sub; i++) {
+                data_offset += 2;
+                uint32_t acmod = (buffer[data_offset] >> 1) & 0x3;
+                if (acmod > 2) {
+                    num_channels = 6;
+                }
+                data_offset++;
+                uint8_t num_dep_sub = (buffer[data_offset] >> 1) & 0xF;
+
+                ALOGV("@DDP - I%d : num_dep_sub = %d", i, num_dep_sub);
+                if (num_dep_sub > 0) {
+                    data_offset++; // chan_loc byte
+                    if ((buffer[data_offset] >> 1) & 0x1) { // Only support Lrs/Rrs case
+                        num_channels = 8;
+                    }
+                }
+            }
+
+            if (num_channels != 2) {
+                mLastTrack->meta->setInt32(kKeyChannelCount, num_channels);
+            }
+            if (chunk_data_size - (data_offset + 1) >= 2) {
+                // JOC requires at least 2 bytes extension data
+                data_offset++;
+                if (buffer[data_offset] & 0x1) {
+                    mLastTrack->meta->setCString(
+                            kKeyMIMEType, MEDIA_MIMETYPE_AUDIO_EAC3_JOC);
+                    ALOGV("@DDP - flag_eac3_extension_type_a = 1 - Set EAC3/JOC mimetype");
+                }
+            }
+            else if (chunk_data_size > (data_offset +1)){
+                ALOGE("@DDP - Invalid EC3SpecificBox extension data");
+                return ERROR_MALFORMED;
+            }
+            *offset += chunk_size;
+            break;
+        }
+#endif // DOLBY_END
         case FOURCC('m', 'p', '4', 'v'):
         case FOURCC('e', 'n', 'c', 'v'):
         case FOURCC('s', '2', '6', '3'):
@@ -3583,6 +3728,9 @@ MPEG4Source::MPEG4Source(
       mBuffer(NULL),
       mWantsNALFragments(false),
       mSrcBuffer(NULL) {
+#ifdef DOLBY_ENABLE
+      ALOGV("@DDP MPEG4Source::MPEG4Source");
+#endif // DOLBY_END
 
     memset(&mTrackFragmentHeaderInfo, 0, sizeof(mTrackFragmentHeaderInfo));
 
diff --git a/media/libstagefright/MediaCodecList.cpp b/media/libstagefright/MediaCodecList.cpp
index 7954acf..53f7cea 100644
--- a/media/libstagefright/MediaCodecList.cpp
+++ b/media/libstagefright/MediaCodecList.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -1131,6 +1150,9 @@ const sp<AMessage> MediaCodecList::getGlobalSettings() const {
 //static
 bool MediaCodecList::isSoftwareCodec(const AString &componentName) {
     return componentName.startsWithIgnoreCase("OMX.google.")
+#ifdef DOLBY_ENABLE
+        || componentName.startsWithIgnoreCase("OMX.dolby.")
+#endif
         || !componentName.startsWithIgnoreCase("OMX.");
 }
 
diff --git a/media/libstagefright/MediaDefs.cpp b/media/libstagefright/MediaDefs.cpp
index 845462b..1035ab4 100644
--- a/media/libstagefright/MediaDefs.cpp
+++ b/media/libstagefright/MediaDefs.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #include <media/stagefright/MediaDefs.h>
@@ -48,6 +67,9 @@ const char *MEDIA_MIMETYPE_AUDIO_AAC_ADTS = "audio/aac-adts";
 const char *MEDIA_MIMETYPE_AUDIO_MSGSM = "audio/gsm";
 const char *MEDIA_MIMETYPE_AUDIO_AC3 = "audio/ac3";
 const char *MEDIA_MIMETYPE_AUDIO_EAC3 = "audio/eac3";
+#ifdef DOLBY_ENABLE
+const char *MEDIA_MIMETYPE_AUDIO_EAC3_JOC = "audio/eac3-joc";
+#endif // DOLBY_END
 
 const char *MEDIA_MIMETYPE_CONTAINER_MPEG4 = "video/mp4";
 const char *MEDIA_MIMETYPE_CONTAINER_WAV = "audio/x-wav";
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index f047060..b92b1c4 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -1509,6 +1528,11 @@ static const struct mime_conv_t mimeLookup[] = {
     { MEDIA_MIMETYPE_AUDIO_AAC,         AUDIO_FORMAT_AAC },
     { MEDIA_MIMETYPE_AUDIO_VORBIS,      AUDIO_FORMAT_VORBIS },
     { MEDIA_MIMETYPE_AUDIO_OPUS,        AUDIO_FORMAT_OPUS},
+#ifdef DOLBY_ENABLE
+    { MEDIA_MIMETYPE_AUDIO_AC3,         AUDIO_FORMAT_AC3},
+    { MEDIA_MIMETYPE_AUDIO_EAC3,        AUDIO_FORMAT_E_AC3},
+    { MEDIA_MIMETYPE_AUDIO_EAC3_JOC,    AUDIO_FORMAT_E_AC3},
+#endif // DOLBY_END
     { 0, AUDIO_FORMAT_INVALID }
 };
 
diff --git a/media/libstagefright/mpeg2ts/ATSParser.cpp b/media/libstagefright/mpeg2ts/ATSParser.cpp
index 844479e..541a377 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -628,6 +647,12 @@ ATSParser::Stream::Stream(
             mQueue = new ElementaryStreamQueue(
                     ElementaryStreamQueue::AC3);
             break;
+#ifdef DOLBY_ENABLE
+        case STREAMTYPE_EAC3:
+            mQueue = new ElementaryStreamQueue(
+                    ElementaryStreamQueue::EAC3);
+            break;
+#endif // DOLBY_END
 
         case STREAMTYPE_METADATA:
             mQueue = new ElementaryStreamQueue(
@@ -757,6 +782,9 @@ bool ATSParser::Stream::isAudio() const {
         case STREAMTYPE_MPEG2_AUDIO_ADTS:
         case STREAMTYPE_LPCM_AC3:
         case STREAMTYPE_AC3:
+#ifdef DOLBY_ENABLE
+        case STREAMTYPE_EAC3:
+#endif // DOLBY_END
             return true;
 
         default:
diff --git a/media/libstagefright/mpeg2ts/ATSParser.h b/media/libstagefright/mpeg2ts/ATSParser.h
index 9d9102d..b0a6bff 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.h
+++ b/media/libstagefright/mpeg2ts/ATSParser.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef A_TS_PARSER_H_
@@ -136,6 +155,9 @@ struct ATSParser : public RefBase {
         // Stream type 0x83 is non-standard,
         // it could be LPCM or TrueHD AC3
         STREAMTYPE_LPCM_AC3             = 0x83,
+#ifdef DOLBY_ENABLE
+        STREAMTYPE_EAC3                 = 0x87,
+#endif // DOLBY_END
     };
 
 protected:
diff --git a/media/libstagefright/mpeg2ts/Android.mk b/media/libstagefright/mpeg2ts/Android.mk
index 70afde9..099296b 100644
--- a/media/libstagefright/mpeg2ts/Android.mk
+++ b/media/libstagefright/mpeg2ts/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
@@ -14,6 +27,11 @@ LOCAL_C_INCLUDES:= \
 	$(TOP)/frameworks/native/include/media/openmax
 
 LOCAL_CFLAGS += -Werror -Wall
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 LOCAL_CLANG := true
 LOCAL_SANITIZE := unsigned-integer-overflow signed-integer-overflow
 
diff --git a/media/libstagefright/mpeg2ts/ESQueue.cpp b/media/libstagefright/mpeg2ts/ESQueue.cpp
index 96ca405..fad814d 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.cpp
+++ b/media/libstagefright/mpeg2ts/ESQueue.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -33,6 +52,10 @@
 
 #include <inttypes.h>
 #include <netinet/in.h>
+#include <stagefright/AVExtensions.h>
+#ifdef DOLBY_ENABLE
+#include "DolbyESQueueExtImpl.h"
+#endif // DOLBY_END
 
 namespace android {
 
@@ -40,6 +63,9 @@ ElementaryStreamQueue::ElementaryStreamQueue(Mode mode, uint32_t flags)
     : mMode(mode),
       mFlags(flags),
       mEOSReached(false) {
+#ifdef DOLBY_ENABLE
+    independent_streams_processed = 0;
+#endif // DOLBY_END
 }
 
 sp<MetaData> ElementaryStreamQueue::getFormat() {
@@ -388,6 +414,34 @@ status_t ElementaryStreamQueue::appendData(
                 size -= startOffset;
                 break;
             }
+#ifdef DOLBY_ENABLE
+            case EAC3:
+            {
+                uint8_t *ptr = (uint8_t *)data;
+
+                ssize_t startOffset = -1;
+                for (size_t i = 0; i < size; ++i) {
+                    if (IsSeeminglyValidEAC3AudioHeader(&ptr[i], size - i)) {
+                        startOffset = i;
+                        break;
+                    }
+                }
+
+                if (startOffset < 0) {
+                    return ERROR_MALFORMED;
+                }
+
+                if (startOffset > 0) {
+                    ALOGI("found something resembling a DDP audio "
+                         "syncword at offset %zd",
+                         startOffset);
+                }
+
+                data = &ptr[startOffset];
+                size -= startOffset;
+                break;
+            }
+#endif // DOLBY_END
 
             case MPEG_AUDIO:
             {
@@ -496,6 +550,10 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnit() {
             return dequeueAccessUnitAAC();
         case AC3:
             return dequeueAccessUnitAC3();
+#ifdef DOLBY_ENABLE
+        case EAC3:
+            return dequeueAccessUnitEAC3();
+#endif // DOLBY_END
         case MPEG_VIDEO:
             return dequeueAccessUnitMPEGVideo();
         case MPEG4_VIDEO:
diff --git a/media/libstagefright/mpeg2ts/ESQueue.h b/media/libstagefright/mpeg2ts/ESQueue.h
index e9f96b7..1c7ee2d 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.h
+++ b/media/libstagefright/mpeg2ts/ESQueue.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #ifndef ES_QUEUE_H_
@@ -33,6 +52,9 @@ struct ElementaryStreamQueue {
         H264,
         AAC,
         AC3,
+#ifdef DOLBY_ENABLE
+        EAC3,
+#endif // DOLBY_END
         MPEG_AUDIO,
         MPEG_VIDEO,
         MPEG4_VIDEO,
@@ -77,6 +99,11 @@ private:
     sp<ABuffer> dequeueAccessUnitMPEG4Video();
     sp<ABuffer> dequeueAccessUnitPCMAudio();
     sp<ABuffer> dequeueAccessUnitMetadata();
+#ifdef DOLBY_ENABLE
+    sp<ABuffer> dequeueAccessUnitEAC3();
+    unsigned independent_streams_processed;
+    unsigned independent_stream_num_channels;
+#endif // DOLBY_END
 
     // consume a logical (compressed) access unit of size "size",
     // returns its timestamp in us (or -1 if no time information).
diff --git a/media/libstagefright/mpeg2ts/MPEG2PSExtractor.cpp b/media/libstagefright/mpeg2ts/MPEG2PSExtractor.cpp
index 078a5f0..0f62a8d 100644
--- a/media/libstagefright/mpeg2ts/MPEG2PSExtractor.cpp
+++ b/media/libstagefright/mpeg2ts/MPEG2PSExtractor.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -607,6 +626,14 @@ MPEG2PSExtractor::Track::Track(
         case ATSParser::STREAMTYPE_MPEG2_AUDIO:
             mode = ElementaryStreamQueue::MPEG_AUDIO;
             break;
+#ifdef DOLBY_ENABLE
+        case ATSParser::STREAMTYPE_AC3:
+            mode = ElementaryStreamQueue::AC3;
+            break;
+        case ATSParser::STREAMTYPE_EAC3:
+            mode = ElementaryStreamQueue::EAC3;
+            break;
+#endif // DOLBY_END
 
         case ATSParser::STREAMTYPE_MPEG1_VIDEO:
         case ATSParser::STREAMTYPE_MPEG2_VIDEO:
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index e4fbd81..19370e7 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 include $(CLEAR_VARS)
 
@@ -33,6 +46,11 @@ LOCAL_SHARED_LIBRARIES :=               \
 
 LOCAL_MODULE:= libstagefright_omx
 LOCAL_CFLAGS += -Werror -Wall
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 LOCAL_CLANG := true
 LOCAL_SANITIZE := unsigned-integer-overflow signed-integer-overflow
 
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
index 0f9c00c..e9044f7 100755
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2011-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 //#define LOG_NDEBUG 0
@@ -59,6 +78,11 @@ static const struct {
     { "OMX.google.raw.decoder", "rawdec", "audio_decoder.raw" },
     { "OMX.google.flac.encoder", "flacenc", "audio_encoder.flac" },
     { "OMX.google.gsm.decoder", "gsmdec", "audio_decoder.gsm" },
+#ifdef DOLBY_ENABLE
+    { "OMX.dolby.ac3.decoder", "ddpdec", "audio_decoder.ac3" },
+    { "OMX.dolby.eac3.decoder", "ddpdec", "audio_decoder.eac3" },
+    { "OMX.dolby.eac3_joc.decoder", "ddpdec", "audio_decoder.eac3_joc" },
+#endif // DOLBY_END
 };
 
 static const size_t kNumComponents =
diff --git a/services/audioflinger/Android.mk b/services/audioflinger/Android.mk
index 8b831f0..aed4260 100644
--- a/services/audioflinger/Android.mk
+++ b/services/audioflinger/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
@@ -85,6 +98,11 @@ LOCAL_CFLAGS += -DSTATE_QUEUE_INSTANTIATIONS='"StateQueueInstantiations.cpp"'
 LOCAL_CFLAGS += -fvisibility=hidden
 
 LOCAL_CFLAGS += -Werror -Wall
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 
 include $(BUILD_SHARED_LIBRARY)
 
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 92df7b3..42e478a 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+**
+** This file was modified by Dolby Laboratories, Inc. The portions of the
+** code that are surrounded by "DOLBY..." are copyrighted and
+** licensed separately, as follows:
+**
+**  (C) 2011-2016 Dolby Laboratories, Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**    http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+**
 */
 
 
@@ -80,6 +99,9 @@
 #define ALOGVV(a...) do { } while(0)
 #endif
 
+#ifdef DOLBY_ENABLE
+#include "EffectDapController_impl.h"
+#endif // DOLBY_END
 namespace android {
 
 static const char kDeadlockedString[] = "AudioFlinger may be deadlocked\n";
@@ -225,6 +247,9 @@ AudioFlinger::AudioFlinger()
         mTeeSinkTrackEnabled = true;
     }
 #endif
+#ifdef DOLBY_ENABLE
+    EffectDapController::mInstance = new EffectDapController(this);
+#endif // DOLBY_END
 }
 
 void AudioFlinger::onFirstRef()
@@ -252,6 +277,9 @@ void AudioFlinger::onFirstRef()
 
 AudioFlinger::~AudioFlinger()
 {
+#ifdef DOLBY_ENABLE
+    delete EffectDapController::mInstance;
+#endif // DOLBY_END
     while (!mRecordThreads.isEmpty()) {
         // closeInput_nonvirtual() will remove specified entry from mRecordThreads
         closeInput_nonvirtual(mRecordThreads.keyAt(0));
@@ -2848,6 +2876,11 @@ status_t AudioFlinger::moveEffects(audio_session_t sessionId, audio_io_handle_t
 
     Mutex::Autolock _dl(dstThread->mLock);
     Mutex::Autolock _sl(srcThread->mLock);
+#ifdef DOLBY_ENABLE
+    if (static_cast<int>(sessionId) == DOLBY_MOVE_EFFECT_SIGNAL) {
+        return EffectDapController::instance()->moveEffect(AUDIO_SESSION_OUTPUT_MIX, srcThread, dstThread);
+    }
+#endif // DOLBY_END
     return moveEffectChain_l(sessionId, srcThread, dstThread, false);
 }
 
@@ -2926,6 +2959,9 @@ status_t AudioFlinger::moveEffectChain_l(audio_session_t sessionId,
     if (status != NO_ERROR) {
         for (size_t i = 0; i < removed.size(); i++) {
             srcThread->addEffect_l(removed[i]);
+#ifdef DOLBY_ENABLE
+            EffectDapController::instance()->restartEffect(effect);
+#endif // DOLBY_END
             if (dstChain != 0 && reRegister) {
                 AudioSystem::unregisterEffect(removed[i]->id());
                 AudioSystem::registerEffect(&removed[i]->desc(),
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index c56dcc1..50c1116 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+**
+** This file was modified by Dolby Laboratories, Inc. The portions of the
+** code that are surrounded by "DOLBY..." are copyrighted and
+** licensed separately, as follows:
+**
+**  (C) 2011-2016 Dolby Laboratories, Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**    http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+**
 */
 
 #ifndef ANDROID_AUDIO_FLINGER_H
@@ -63,6 +82,9 @@
 
 #include <media/nbaio/NBLog.h>
 #include <private/media/AudioTrackShared.h>
+#ifdef DOLBY_ENABLE
+#include "ds_config.h"
+#endif // DOLBY_END
 
 namespace android {
 
@@ -762,6 +784,9 @@ private:
     sp<PatchPanel> mPatchPanel;
 
     bool        mSystemReady;
+#ifdef DOLBY_ENABLE
+#include "EffectDapController.h"
+#endif // DOLBY_END
 };
 
 #undef INCLUDING_FROM_AUDIOFLINGER_H
diff --git a/services/audioflinger/Effects.cpp b/services/audioflinger/Effects.cpp
index 5b59c71..787f188 100644
--- a/services/audioflinger/Effects.cpp
+++ b/services/audioflinger/Effects.cpp
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+**
+** This file was modified by Dolby Laboratories, Inc. The portions of the
+** code that are surrounded by "DOLBY..." are copyrighted and
+** licensed separately, as follows:
+**
+**  (C) 2011-2016 Dolby Laboratories, Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**    http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+**
 */
 
 
@@ -827,6 +846,9 @@ status_t AudioFlinger::EffectModule::setAudioSource(audio_source_t source)
 
 void AudioFlinger::EffectModule::setSuspended(bool suspended)
 {
+#ifdef DOLBY_ENABLE
+    EffectDapController::instance()->effectSuspended(this, suspended);
+#endif // DOLBY_END
     Mutex::Autolock _l(mLock);
     mSuspended = suspended;
 }
@@ -1645,8 +1667,12 @@ status_t AudioFlinger::EffectChain::addEffect_l(const sp<EffectModule>& effect)
         ALOGV("addEffect_l() effect %p, added in chain %p at rank %zu", effect.get(), this,
                 idx_insert);
     }
+#ifdef DOLBY_ENABLE
+    return effect->configure();
+#else // DOLBY_END
     effect->configure();
     return NO_ERROR;
+#endif // LINE_ADDED_BY_DOLBY
 }
 
 // removeEffect_l() must be called with PlaybackThread::mLock held
@@ -1676,6 +1702,11 @@ size_t AudioFlinger::EffectChain::removeEffect_l(const sp<EffectModule>& effect)
             mEffects.removeAt(i);
             ALOGV("removeEffect_l() effect %p, removed from chain %p at rank %zu", effect.get(),
                     this, i);
+#ifdef DOLBY_ENABLE
+            if (effect->suspended() && EffectDapController::instance()->isDapEffect(effect)) {
+                effect->setSuspended(false);
+            }
+#endif // DOLBY_END
             break;
         }
     }
diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index 92e26c6..f501dd6 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+**
+** This file was modified by Dolby Laboratories, Inc. The portions of the
+** code that are surrounded by "DOLBY..." are copyrighted and
+** licensed separately, as follows:
+**
+**  (C) 2011-2016 Dolby Laboratories, Inc.
+**
+** Licensed under the Apache License, Version 2.0 (the "License");
+** you may not use this file except in compliance with the License.
+** You may obtain a copy of the License at
+**
+**    http://www.apache.org/licenses/LICENSE-2.0
+**
+** Unless required by applicable law or agreed to in writing, software
+** distributed under the License is distributed on an "AS IS" BASIS,
+** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+** See the License for the specific language governing permissions and
+** limitations under the License.
+**
 */
 
 
@@ -1525,6 +1544,9 @@ sp<AudioFlinger::EffectHandle> AudioFlinger::ThreadBase::createEffect_l(
             effect->setDevice(mInDevice);
             effect->setMode(mAudioFlinger->getMode());
             effect->setAudioSource(mAudioSource);
+#ifdef DOLBY_ENABLE
+            EffectDapController::instance()->effectCreated(effect, this);
+#endif // DOLBY_END
         }
         // create effect handle and connect it to effect module
         handle = new EffectHandle(effect, client, effectClient, priority);
@@ -1619,6 +1641,9 @@ status_t AudioFlinger::ThreadBase::addEffect_l(const sp<EffectModule>& effect)
     effect->setDevice(mInDevice);
     effect->setMode(mAudioFlinger->getMode());
     effect->setAudioSource(mAudioSource);
+#ifdef DOLBY_ENABLE
+    EffectDapController::instance()->updateOffload(this);
+#endif // DOLBY_END
     return NO_ERROR;
 }
 
@@ -2827,6 +2852,10 @@ void AudioFlinger::PlaybackThread::threadLoop_exit()
             track->invalidate();
         }
     }
+#ifdef DOLBY_ENABLE // DOLBY_DAP_PREGAIN
+    // When a thread is closed set associated volume to 0
+    EffectDapController::instance()->updatePregain(mType, mId, mOutput->flags, 0);
+#endif // DOLBY_END
 }
 
 /*
@@ -3233,6 +3262,13 @@ bool AudioFlinger::PlaybackThread::threadLoop()
             }
             // mMixerStatusIgnoringFastTracks is also updated internally
             mMixerStatus = prepareTracks_l(&tracksToRemove);
+#ifdef DOLBY_ENABLE // DOLBY_DAP_PREGAIN
+            // If there are no active tracks, then reset volume to zero for this thread.
+            if (mMixerStatus == MIXER_IDLE) {
+                ALOGV("EffectDapController: Reset volumes to zeros for threadType = %d flags = %d", mType, mOutput->flags);
+                EffectDapController::instance()->updatePregain(mType, mId, mOutput->flags, 0);
+            }
+#endif // DOLBY_END
 
             // compare with previously applied list
             if (lastGeneration != mActiveTracksGeneration) {
@@ -4070,6 +4106,12 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
 
     float masterVolume = mMasterVolume;
     bool masterMute = mMasterMute;
+#ifdef DOLBY_ENABLE // DOLBY_DAP_PREGAIN
+    // The maximum volume of left channel and right channel for pregain calculation.
+    uint32_t max_vol = 0;
+    float dvlf = 0.0f;
+    float dvrf = 0.0f;
+#endif // DOLBY_END
 
     if (masterMute) {
         masterVolume = 0;
@@ -4396,6 +4438,10 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
                 vaf = v * sendLevel * (1. / MAX_GAIN_INT);
             }
 
+#ifdef DOLBY_ENABLE // DOLBY_DAP_PREGAIN
+            dvlf = vlf;
+            dvrf = vrf;
+#endif // DOLBY_END
             // Delegate volume control to effect in track effect chain if needed
             if (chain != 0 && chain->setVolume_l(&vl, &vr)) {
                 // Do not ramp volume if volume is controlled by effect
@@ -4412,6 +4458,17 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
                 }
                 track->mHasVolumeController = false;
             }
+#ifdef DOLBY_ENABLE // DOLBY_DAP_PREGAIN
+            // Select the maximum volume by scanning all the active audio tracks but not the output one.
+            if (!track->isOutputTrack() && !EffectDapController::instance()->bypassTrack(track)) {
+                if (track->mHasVolumeController) {
+                    const float scaleto8_24 = MAX_GAIN_INT * MAX_GAIN_INT;
+                    max_vol = max(max_vol, max(((uint32_t) (scaleto8_24 * vlf * dvlf)), ((uint32_t) (scaleto8_24 * vrf * dvrf))));
+                } else {
+                    max_vol = max(max_vol, max(vl, vr));
+                }
+            }
+#endif // DOLBY_END
 
             // XXX: these things DON'T need to be done each time
             mAudioMixer->setBufferProvider(name, track);
@@ -4532,6 +4589,11 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
                     if (track->isStopped()) {
                         track->reset();
                     }
+#ifdef DOLBY_ENABLE // DOLBY_UDC_VIRTUALIZE_AUDIO
+                    // Since this track is being removed from active tracks, check if we
+                    // should re-enable content processing in DAP.
+                    EffectDapController::instance()->trackStateChanged(track->mId, track->mState);
+#endif // DOLBY_END
                     tracksToRemove->add(track);
                 }
             } else {
@@ -4641,6 +4703,16 @@ AudioFlinger::PlaybackThread::mixer_state AudioFlinger::MixerThread::prepareTrac
     if (fastTracks > 0) {
         mixerStatus = MIXER_TRACKS_READY;
     }
+#ifdef DOLBY_ENABLE
+    // DOLBY_DAP_BYPASS_SOUND_TYPES
+    EffectDapController::instance()->checkForBypass(mActiveTracks, mOutput->flags, mId);
+    // DOLBY_DAP_PREGAIN
+    // Skip the DS pregain setting if there're no active tracks, or all the active tracks are pausing ones,
+    // so that the last pregain will be adopted and zero volume level will not be sent in the 2 cases above.
+    if (mMixerStatusIgnoringFastTracks == MIXER_TRACKS_READY) {
+        EffectDapController::instance()->updatePregain(mType, mId, mOutput->flags, max_vol);
+    }
+#endif // DOLBY_END
     return mixerStatus;
 }
 
@@ -4903,6 +4975,12 @@ void AudioFlinger::DirectOutputThread::processVolume_l(Track *track, bool lastTr
             if (mOutput->stream->set_volume) {
                 mOutput->stream->set_volume(mOutput->stream, left, right);
             }
+#ifdef DOLBY_ENABLE // DOLBY_DAP_PREGAIN
+            if (!EffectDapController::instance()->bypassTrack(track)) {
+                // Update the volume set for the current thread
+                EffectDapController::instance()->updatePregain(mType, mId, mOutput->flags, max(vl, vr));
+            }
+#endif // DOLBY_END
         }
     }
 }
diff --git a/services/audioflinger/Tracks.cpp b/services/audioflinger/Tracks.cpp
index ba6e6e5..9580525 100644
--- a/services/audioflinger/Tracks.cpp
+++ b/services/audioflinger/Tracks.cpp
@@ -13,6 +13,25 @@
 ** WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 ** See the License for the specific language governing permissions and
 ** limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
 */
 
 
@@ -34,6 +53,10 @@
 #include <media/nbaio/Pipe.h>
 #include <media/nbaio/PipeReader.h>
 #include <audio_utils/minifloat.h>
+#ifdef DOLBY_ENABLE // DOLBY_UDC_VIRTUALIZE_AUDIO
+#include <media/AudioParameter.h>
+#include "ds_config.h"
+#endif // DOLBY_END
 
 // ----------------------------------------------------------------------------
 
@@ -422,6 +445,9 @@ AudioFlinger::PlaybackThread::Track::~Track()
     if (mSharedBuffer != 0) {
         mSharedBuffer.clear();
     }
+#ifdef DOLBY_ENABLE // DOLBY_UDC_VIRTUALIZE_AUDIO
+    EffectDapController::instance()->trackDestroyed(mId);
+#endif // DOLBY_END
 }
 
 status_t AudioFlinger::PlaybackThread::Track::initCheck() const
@@ -686,6 +712,14 @@ status_t AudioFlinger::PlaybackThread::Track::start(AudioSystem::sync_event_t ev
                 mState = state;
             }
         }
+#ifdef DOLBY_ENABLE // DOLBY_UDC_VIRTUALIZE_AUDIO
+        if (mState != state) {
+            // This call will disable content processing in global DAP if this track
+            // is carrying processed audio. The content processing will be re-enabled
+            // when this track has been exhausted by MixerThread::prepareTracks_l()
+            EffectDapController::instance()->trackStateChanged(mId, mState);
+        }
+#endif // DOLBY_END
         // track was already in the active list, not a problem
         if (status == ALREADY_EXISTS) {
             status = NO_ERROR;
@@ -860,6 +894,22 @@ void AudioFlinger::PlaybackThread::Track::reset()
 
 status_t AudioFlinger::PlaybackThread::Track::setParameters(const String8& keyValuePairs)
 {
+#ifdef DOLBY_ENABLE // DOLBY_UDC_VIRTUALIZE_AUDIO
+    AudioParameter ap(keyValuePairs);
+    int value = 0;
+    if (ap.getInt(String8(DOLBY_PARAM_PROCESSED_AUDIO), value) == NO_ERROR) {
+        if (value) {
+            // Bypass content processing if processed audio is flowing through this track.
+            ALOGI("%s(): Marking track %d as containing processed audio", __FUNCTION__, mId);
+            EffectDapController::instance()->trackContainsProcessedAudio(mId, mState);
+        } else {
+            // Remove the track if it is no longer carrying processed audio.
+            ALOGI("%s(): Clearing track %d processed audio mark", __FUNCTION__, mId);
+            EffectDapController::instance()->trackDestroyed(mId);
+        }
+        return NO_ERROR;
+    }
+#endif // DOLBY_END
     sp<ThreadBase> thread = mThread.promote();
     if (thread == 0) {
         ALOGE("thread is dead");
@@ -889,6 +939,14 @@ status_t AudioFlinger::PlaybackThread::Track::getTimestamp(AudioTimestamp& times
 
 status_t AudioFlinger::PlaybackThread::Track::attachAuxEffect(int EffectId)
 {
+#ifdef DOLBY_ENABLE // DOLBY_UDC_VIRTUALIZE_AUDIO
+    // The track contains processed audio if EffectId is DOLBY_PROCESSED_AUDIO_EFFECT_ID
+    if (EffectId == DOLBY_PROCESSED_AUDIO_EFFECT_ID) {
+        ALOGI("%s(): Marking track %d as containing processed audio", __FUNCTION__, mId);
+        EffectDapController::instance()->trackContainsProcessedAudio(mId, mState);
+        return NO_ERROR;
+    }
+#endif // DOLBY_END
     status_t status = DEAD_OBJECT;
     sp<ThreadBase> thread = mThread.promote();
     if (thread != 0) {
diff --git a/services/audiopolicy/Android.mk b/services/audiopolicy/Android.mk
index c8e5148..a2b1ca1 100644
--- a/services/audiopolicy/Android.mk
+++ b/services/audiopolicy/Android.mk
@@ -1,3 +1,16 @@
+# This file was modified by Dolby Laboratories, Inc. The portions of the
+# code that are surrounded by "DOLBY..." are copyrighted and
+# licensed separately, as follows:
+#
+# (C)  2016 Dolby Laboratories, Inc.
+# All rights reserved.
+#
+# This program is protected under international and U.S. Copyright laws as
+# an unpublished work. This program is confidential and proprietary to the
+# copyright owners. Reproduction or disclosure, in whole or in part, or the
+# production of derivative works therefrom without the express permission of
+# the copyright owners is prohibited.
+#
 LOCAL_PATH:= $(call my-dir)
 
 include $(CLEAR_VARS)
@@ -50,7 +63,11 @@ LOCAL_MULTILIB := $(AUDIOSERVER_MULTILIB)
 LOCAL_MODULE:= libaudiopolicyservice
 
 LOCAL_CFLAGS += -fvisibility=hidden
-LOCAL_CFLAGS += -Wall -Werror
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 
 include $(BUILD_SHARED_LIBRARY)
 
@@ -102,6 +119,11 @@ LOCAL_SHARED_LIBRARIES += libicuuc
 
 LOCAL_CFLAGS += -DUSE_XML_AUDIO_POLICY_CONF
 endif #ifeq ($(USE_XML_AUDIO_POLICY_CONF), 1)
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 
 LOCAL_CFLAGS += -Wall -Werror
 
@@ -127,6 +149,11 @@ LOCAL_STATIC_LIBRARIES := \
 LOCAL_C_INCLUDES += \
     $(TOPDIR)frameworks/av/services/audiopolicy/common/include \
     $(TOPDIR)frameworks/av/services/audiopolicy/engine/interface
+# DOLBY_START
+ifeq ($(strip $(DOLBY_ENABLE)),true)
+    LOCAL_CFLAGS += $(dolby_cflags)
+endif
+# DOLBY_END
 
 LOCAL_CFLAGS := -Wall -Werror
 
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 7e8c27c..f9ee44e 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -12,6 +12,24 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
  */
 
 #define LOG_TAG "APM_AudioPolicyManager"
@@ -46,6 +64,9 @@
 #include <Serializer.h>
 #include "TypeConverter.h"
 #include <policy.h>
+#ifdef DOLBY_ENABLE
+#include "DolbyAudioPolicy_impl.h"
+#endif // DOLBY_END
 
 namespace android {
 
@@ -180,6 +201,11 @@ status_t AudioPolicyManager::setDeviceConnectionStateInt(audio_devices_t device,
         }
 
         updateDevicesAndOutputs();
+#ifdef DOLBY_ENABLE // DOLBY_UDC
+        // Before closing the opened outputs, update endpoint property with device capabilities
+        audio_devices_t audioOutputDevice = getDeviceForStrategy(getStrategy(AUDIO_STREAM_MUSIC), true);
+        mDolbyAudioPolicy.setEndpointSystemProperty(audioOutputDevice, mHwModules);
+#endif // DOLBY_END
         if (mEngine->getPhoneState() == AUDIO_MODE_IN_CALL && hasPrimaryOutput()) {
             audio_devices_t newDevice = getNewOutputDevice(mPrimaryOutput, false /*fromCache*/);
             updateCallRouting(newDevice);
@@ -971,7 +997,23 @@ audio_io_handle_t AudioPolicyManager::getOutputForDevice(
         addOutput(output, outputDesc);
         audio_io_handle_t dstOutput = getOutputForEffect();
         if (dstOutput == output) {
+#ifdef DOLBY_ENABLE
+            status_t status = mpClientInterface->moveEffects(AUDIO_SESSION_OUTPUT_MIX, srcOutput, dstOutput);
+            if (status == NO_ERROR) {
+                for (size_t i = 0; i < mEffects.size(); i++) {
+                    sp<EffectDescriptor> desc = mEffects.valueAt(i);
+                    if (desc->mSession == AUDIO_SESSION_OUTPUT_MIX) {
+                        // update the mIo member of EffectDescriptor for the global effect
+                        ALOGV("%s updating mIo", __FUNCTION__);
+                        desc->mIo = dstOutput;
+                    }
+                }
+            } else {
+                ALOGW("%s moveEffects from %d to %d failed", __FUNCTION__, srcOutput, dstOutput);
+            }
+#else // DOLBY_END
             mpClientInterface->moveEffects(AUDIO_SESSION_OUTPUT_MIX, srcOutput, dstOutput);
+#endif // LINE_ADDED_BY_DOLBY
         }
         mPreviousOutputs = mOutputs;
         ALOGV("getOutput() returns new direct output %d", output);
@@ -1144,6 +1186,22 @@ status_t AudioPolicyManager::startOutput(audio_io_handle_t output,
     if (delayMs != 0) {
         usleep(delayMs * 1000);
     }
+#ifdef DOLBY_ENABLE
+    // DOLBY_UDC
+    // It is observed that in some use-cases where multiple outputs are present eg. bluetooth and headphone,
+    // the output for particular stream type is decided in this routine. Hence we must call
+    // getDeviceForStrategy in order to get the current active output for this stream type and update
+    // the dolby system property.
+    if (stream == AUDIO_STREAM_MUSIC)
+    {
+        audio_devices_t audioOutputDevice = getDeviceForStrategy(getStrategy(AUDIO_STREAM_MUSIC), true);
+        mDolbyAudioPolicy.setEndpointSystemProperty(audioOutputDevice, mHwModules);
+    }
+    // DOLBY_DAP_MOVE_EFFECT
+    // Note: The global effect can't be taken away from the deep-buffered output (source output) if there're still
+    //       music playing on the deep-buffered output.
+    mDolbyAudioPolicy.moveOutput(stream, outputDesc, &mOutputs, mpClientInterface, output);
+#endif //DOLBY_END
 
     return status;
 }
@@ -1384,8 +1442,25 @@ void AudioPolicyManager::releaseOutput(audio_io_handle_t output,
             // output by default: move them back to the appropriate output.
             audio_io_handle_t dstOutput = getOutputForEffect();
             if (hasPrimaryOutput() && dstOutput != mPrimaryOutput->mIoHandle) {
+#ifdef DOLBY_ENABLE
+                status_t status = mpClientInterface->moveEffects(AUDIO_SESSION_OUTPUT_MIX,
+                                                                 mPrimaryOutput->mIoHandle, dstOutput);
+                if (status == NO_ERROR) {
+                    for (size_t i = 0; i < mEffects.size(); i++) {
+                        sp<EffectDescriptor> desc = mEffects.valueAt(i);
+                        if (desc->mSession == AUDIO_SESSION_OUTPUT_MIX) {
+                            // update the mIo member of EffectDescriptor for the global effect
+                            ALOGV("%s updating mIo", __FUNCTION__);
+                            desc->mIo = dstOutput;
+                        }
+                    }
+                } else {
+                    ALOGW("%s moveEffects from %d to %d failed", __FUNCTION__, mPrimaryOutput->mIoHandle, dstOutput);
+                }
+#else // DOLBY_END
                 mpClientInterface->moveEffects(AUDIO_SESSION_OUTPUT_MIX,
                                                mPrimaryOutput->mIoHandle, dstOutput);
+#endif // LINE_ADDED_BY_DOLBY
             }
             mpClientInterface->onAudioPortListUpdate();
         }
@@ -2047,7 +2122,11 @@ status_t AudioPolicyManager::registerEffect(const effect_descriptor_t *desc,
             return INVALID_OPERATION;
         }
     }
+#ifdef DOLBY_ENABLE
+    return mDolbyAudioPolicy.registerEffect(desc, io, strategy, session, id, &mEffects);
+#else // DOLBY_END
     return mEffects.registerEffect(desc, io, strategy, session, id);
+#endif // LINE_ADDED_BY_DOLBY
 }
 
 bool AudioPolicyManager::isStreamActive(audio_stream_type_t stream, uint32_t inPastMs) const
@@ -4247,8 +4326,17 @@ void AudioPolicyManager::checkOutputForStrategy(routing_strategy strategy)
                     if (moved.indexOf(effectDesc->mIo) < 0) {
                         ALOGV("checkOutputForStrategy() moving effect %d to output %d",
                               mEffects.keyAt(i), fxOutput);
+#ifdef DOLBY_ENABLE
+                        status_t status = mpClientInterface->moveEffects(AUDIO_SESSION_OUTPUT_MIX, effectDesc->mIo,
+                                                       fxOutput);
+                        if (status != NO_ERROR) {
+                            ALOGW("%s moveEffects from %d to %d failed", __FUNCTION__, effectDesc->mIo, fxOutput);
+                            continue;
+                        }
+#else // DOLBY_END
                         mpClientInterface->moveEffects(AUDIO_SESSION_OUTPUT_MIX, effectDesc->mIo,
                                                        fxOutput);
+#endif // LINE_ADDED_BY_DOLBY
                         moved.add(effectDesc->mIo);
                     }
                     effectDesc->mIo = fxOutput;
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.h b/services/audiopolicy/managerdefault/AudioPolicyManager.h
index 0b2ec1c..38ed55c 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.h
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.h
@@ -12,6 +12,25 @@
  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  * See the License for the specific language governing permissions and
  * limitations under the License.
+ *
+ * This file was modified by Dolby Laboratories, Inc. The portions of the
+ * code that are surrounded by "DOLBY..." are copyrighted and
+ * licensed separately, as follows:
+ *
+ *  (C) 2014-2016 Dolby Laboratories, Inc.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *    http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
  */
 
 #pragma once
@@ -173,6 +192,9 @@ public:
                                         int id);
         virtual status_t unregisterEffect(int id)
         {
+#ifdef DOLBY_ENABLE
+            mDolbyAudioPolicy.effectRemoved(&mEffects, id);
+#endif // DOLBY_END
             return mEffects.unregisterEffect(id);
         }
         virtual status_t setEffectEnabled(int id, bool enabled)
@@ -653,6 +675,11 @@ protected:
             param.addInt(String8(AUDIO_PARAMETER_MONO_OUTPUT), (int)mMasterMono);
             mpClientInterface->setParameters(output, param.toString());
         }
+#ifdef DOLBY_ENABLE
+protected:
+#include "DolbyAudioPolicy.h"
+        DolbyAudioPolicy mDolbyAudioPolicy;
+#endif // DOLBY_END
 };
 
 };
-- 
2.7.4


From ffae5f17123b01bdc040b0cbab573a8fc3745aad Mon Sep 17 00:00:00 2001
From: Li Sun <sunli@codeaurora.org>
Date: Sat, 19 Sep 2015 00:11:04 +0800
Subject: [PATCH 19/39] RTSP: add default implementations in NuPlayer for rtsp
 changes

Change access modifiers and qualify methods with virtual, to
allow extensions in RTSP. Add facility for loading customizations
(Extended classes) dynamically.

List of squashed changes:

rtsp: keep video damaged access unit to enhance fault tolerance
Change-Id: I3b7fb4b098aba5daf149cf36dab7e9380c6d2f69

rtsp: notify the client when receiving BYE message in RTCP
Change-Id: I461960f28610f998b71a6e1322fe79f9856c7a92

rtsp: do not drop early access units of seekable rtsp
Change-Id: I12793dbbf367650e66532195324adb5b5ad8fe85

NuPlayer: Fix ANR while resetting RTSP playback
Change-Id: I3f9efd9fefa66104ad452559ced5ff5218d73a66

RTSP: add RTSP extensions for customization support
Change-Id: I67adeb54b35d1f01911625bb9bad27e94ad0caf0

RTSP: add RTSP extensions for IPV6 support
Change-Id: Iaa67070d1832d56e0569dabfd8327c1998f04493

RTSP: add default implementations in NuPlayer for rtsp changes

Change-Id: I365cce317b4478cd1d12e458b5849ea842062a28
---
 media/libavextensions/Android.mk                   |  2 +
 .../mediaplayerservice/AVMediaServiceExtensions.h  | 30 +++++++++++++
 .../mediaplayerservice/AVMediaServiceFactory.cpp   | 11 +++++
 .../mediaplayerservice/AVMediaServiceUtils.cpp     | 51 ++++++++++++++++++++++
 .../mediaplayerservice/AVNuExtensions.h            |  1 +
 .../mediaplayerservice/AVNuUtils.cpp               |  4 ++
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  7 +++
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |  2 +-
 .../nuplayer/NuPlayerDecoder.cpp                   |  1 +
 .../nuplayer/NuPlayerDriver.cpp                    |  3 ++
 .../nuplayer/NuPlayerSource.h                      |  1 +
 .../libmediaplayerservice/nuplayer/RTSPSource.cpp  | 48 +++++++++++++++++---
 media/libmediaplayerservice/nuplayer/RTSPSource.h  |  4 ++
 media/libstagefright/rtsp/AH263Assembler.cpp       |  5 ++-
 media/libstagefright/rtsp/ARTPConnection.cpp       | 10 ++++-
 media/libstagefright/rtsp/ARTPConnection.h         |  7 +--
 media/libstagefright/rtsp/ARTSPConnection.cpp      | 13 +++++-
 media/libstagefright/rtsp/ARTSPConnection.h        |  7 ++-
 media/libstagefright/rtsp/ASessionDescription.cpp  |  4 +-
 media/libstagefright/rtsp/Android.mk               |  6 ++-
 media/libstagefright/rtsp/MyHandler.h              | 47 ++++++++++++++++----
 21 files changed, 238 insertions(+), 26 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index 8a72be4..18ee639 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -67,6 +67,8 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
         $(TOP)/frameworks/av/media/libmediaplayerservice \
         $(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/av/media/libstagefright/include \
+        $(TOP)/frameworks/av/media/libstagefright/rtsp \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/external/flac/include \
diff --git a/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h b/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h
index 892cb53..daf3b5b 100644
--- a/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h
+++ b/media/libavextensions/mediaplayerservice/AVMediaServiceExtensions.h
@@ -32,11 +32,20 @@
 #include <common/AVExtensionsCommon.h>
 #include <MediaPlayerFactory.h>
 
+#include <utils/List.h>
+#include <utils/RefBase.h>
 #include <utils/String16.h>
 
+#include <media/Metadata.h>
+
 namespace android {
 
 struct StagefrightRecorder;
+struct ARTSPConnection;
+struct ARTPConnection;
+struct AString;
+struct MyHandler;
+struct ABuffer;
 
 /*
  * Factory to create objects of base-classes in libmediaplayerservice
@@ -44,6 +53,10 @@ struct StagefrightRecorder;
 struct AVMediaServiceFactory {
     virtual StagefrightRecorder *createStagefrightRecorder(const String16 &);
 
+    // RTSP extensions
+    virtual sp<ARTSPConnection> createARTSPConnection(bool uidValid, uid_t uid);
+    virtual sp<ARTPConnection> createARTPConnection();
+
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVMediaServiceFactory);
 };
@@ -54,6 +67,23 @@ struct AVMediaServiceFactory {
 struct AVMediaServiceUtils {
     virtual void getDashPlayerFactory(MediaPlayerFactory::IFactory *&, player_type ) {}
 
+    // RTSP IPV6 utils
+    virtual bool pokeAHole(sp<MyHandler> handler, int rtpSocket, int rtcpSocket,
+            const AString &transport, const AString &sessionHost);
+    virtual void makePortPair(int *rtpSocket, int *rtcpSocket, unsigned *rtpPort,
+            bool isIPV6);
+    virtual const char* parseURL(AString *host);
+    // RTSP customization utils
+    virtual bool parseTrackURL(AString url, AString val);
+    virtual void appendRange(AString *request);
+    virtual void setServerTimeoutUs(int64_t timeout);
+    virtual void appendMeta(media::Metadata *meta);
+    virtual bool checkNPTMapping(uint32_t *rtpInfoTime, int64_t *playTimeUs,
+            bool *nptValid, uint32_t rtpTime);
+    virtual void addH263AdvancedPacket(const sp<ABuffer> &buffer,
+            List<sp<ABuffer>> *packets, uint32_t rtpTime);
+    virtual bool parseNTPRange(const char *s, float *npt1, float *npt2);
+
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVMediaServiceUtils);
 };
diff --git a/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp b/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp
index abbeb99..c229cce 100644
--- a/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp
+++ b/media/libavextensions/mediaplayerservice/AVMediaServiceFactory.cpp
@@ -32,6 +32,8 @@
 
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AMessage.h>
+#include "ARTPConnection.h"
+#include "ARTSPConnection.h"
 
 #include "MediaRecorderClient.h"
 #include "MediaPlayerService.h"
@@ -46,6 +48,15 @@ StagefrightRecorder *AVMediaServiceFactory::createStagefrightRecorder(
     return new StagefrightRecorder(opPackageName);
 }
 
+sp<ARTSPConnection> AVMediaServiceFactory::createARTSPConnection(
+        bool uidValid, uid_t uid) {
+    return new ARTSPConnection(uidValid, uid);
+}
+
+sp<ARTPConnection> AVMediaServiceFactory::createARTPConnection() {
+    return new ARTPConnection();
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVMediaServiceFactory::AVMediaServiceFactory() {
 }
diff --git a/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp b/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp
index 3e8876b..5306a39 100644
--- a/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVMediaServiceUtils.cpp
@@ -32,12 +32,63 @@
 #include <utils/Log.h>
 
 #include <media/stagefright/foundation/ADebug.h>
+#include "ARTPConnection.h"
+#include "ASessionDescription.h"
+#include "MyHandler.h"
 
 #include "common/ExtensionsLoader.hpp"
 #include "mediaplayerservice/AVMediaServiceExtensions.h"
 
 namespace android {
 
+bool AVMediaServiceUtils::pokeAHole(sp<MyHandler> handler, int rtpSocket, int rtcpSocket,
+        const AString &transport, const AString &/*sessionHost*/) {
+    if (handler == NULL) {
+        ALOGW("MyHandler is NULL");
+        return false;
+    }
+    return handler->pokeAHole(rtpSocket, rtcpSocket, transport);
+}
+
+void AVMediaServiceUtils::makePortPair(int *rtpSocket, int *rtcpSocket, unsigned *rtpPort,
+        bool /*isIPV6*/) {
+    return ARTPConnection::MakePortPair(rtpSocket, rtcpSocket, rtpPort);
+}
+
+const char* AVMediaServiceUtils::parseURL(AString *host) {
+    return strchr(host->c_str(), ':');
+}
+
+bool AVMediaServiceUtils::parseTrackURL(AString /*url*/, AString /*val*/) {
+    return false;
+}
+
+void AVMediaServiceUtils::appendRange(AString * /*request*/) {
+    return;
+}
+
+void AVMediaServiceUtils::setServerTimeoutUs(int64_t /*timeout*/) {
+    return;
+}
+
+void AVMediaServiceUtils::addH263AdvancedPacket(const sp<ABuffer> &/*buffer*/,
+        List<sp<ABuffer>> * /*packets*/, uint32_t /*rtpTime*/) {
+    return;
+}
+
+void AVMediaServiceUtils::appendMeta(media::Metadata * /*meta*/) {
+    return;
+}
+
+bool AVMediaServiceUtils::checkNPTMapping(uint32_t * /*rtpInfoTime*/, int64_t * /*playTimeUs*/,
+        bool * /*nptValid*/, uint32_t /*rtpTime*/) {
+    return false;
+}
+
+bool AVMediaServiceUtils::parseNTPRange(const char *s, float *npt1, float *npt2) {
+    return ASessionDescription::parseNTPRange(s, npt1, npt2);
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVMediaServiceUtils::AVMediaServiceUtils() {
 }
diff --git a/media/libavextensions/mediaplayerservice/AVNuExtensions.h b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
index 5312082..55eb4d6 100644
--- a/media/libavextensions/mediaplayerservice/AVNuExtensions.h
+++ b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
@@ -58,6 +58,7 @@ struct AVNuUtils {
 
     virtual void printFileName(int fd);
     virtual bool dropCorruptFrame();
+    virtual void addFlagsInMeta(const sp<ABuffer> &buffer, int32_t flags, bool isAudio);
 
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVNuUtils);
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index 744199d..c1874b7 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -52,6 +52,10 @@ void AVNuUtils::printFileName(int) {}
 
 bool AVNuUtils::dropCorruptFrame() { return false; }
 
+void AVNuUtils::addFlagsInMeta(const sp<ABuffer> & /*buffer*/,
+        int32_t /*flags*/, bool /*isAudio*/) {
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVNuUtils::AVNuUtils() {}
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index fbecef4..714063a 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -2374,6 +2374,13 @@ void NuPlayer::onSourceNotify(const sp<AMessage> &msg) {
             break;
         }
 
+        case Source::kWhatRTCPByeReceived:
+        {
+            ALOGV("notify the client that Bye message is received");
+            notifyListener(MEDIA_INFO, 2000, 0);
+            break;
+        }
+
         default:
             TRESPASS();
     }
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index 44cc152..4a7f96e 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -285,7 +285,7 @@ protected:
 
     void processDeferredActions();
 
-    void performSeek(int64_t seekTimeUs);
+    virtual void performSeek(int64_t seekTimeUs);
     void performDecoderFlush(FlushCommand audio, FlushCommand video);
     void performReset();
     void performScanSources();
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index c1e7592..cf9438e 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -672,6 +672,7 @@ bool NuPlayer::Decoder::handleAnOutputBuffer(
     buffer->setRange(offset, size);
     buffer->meta()->clear();
     buffer->meta()->setInt64("timeUs", timeUs);
+    AVNuUtils::get()->addFlagsInMeta(buffer, flags, mIsAudio);
 
     bool eos = flags & MediaCodec::BUFFER_FLAG_EOS;
     // we do not expect CODECCONFIG or SYNCFRAME for decoder
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
index e1d5ee8..f39a4ff 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDriver.cpp
@@ -32,6 +32,7 @@
 #include <media/stagefright/Utils.h>
 
 #include "mediaplayerservice/AVNuExtensions.h"
+#include "mediaplayerservice/AVMediaServiceExtensions.h"
 
 namespace android {
 
@@ -600,6 +601,8 @@ status_t NuPlayerDriver::getMetadata(
             Metadata::kSeekAvailable,
             mPlayerFlags & NuPlayer::Source::FLAG_CAN_SEEK);
 
+    AVMediaServiceUtils::get()->appendMeta(&meta);
+
     return OK;
 }
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerSource.h b/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
index 0176eaf..47f5f19 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerSource.h
@@ -55,6 +55,7 @@ struct NuPlayer::Source : public AHandler {
         kWhatQueueDecoderShutdown,
         kWhatDrmNoLicense,
         kWhatInstantiateSecureDecoders,
+        kWhatRTCPByeReceived,
     };
 
     // The provides message is used to notify the player about various
diff --git a/media/libmediaplayerservice/nuplayer/RTSPSource.cpp b/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
index c4e5df7..6a43daf 100644
--- a/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
+++ b/media/libmediaplayerservice/nuplayer/RTSPSource.cpp
@@ -24,13 +24,16 @@
 #include "MyHandler.h"
 #include "SDPLoader.h"
 
+#include <cutils/properties.h>
 #include <media/IMediaHTTPService.h>
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MetaData.h>
+#include <mediaplayerservice/AVMediaServiceExtensions.h>
 
 namespace android {
 
 const int64_t kNearEOSTimeoutUs = 2000000ll; // 2 secs
+const uint32_t kMaxNumKeepDamagedAccessUnits = 30;
 
 // Buffer Underflow/Prepare/StartServer/Overflow Marks
 const int64_t NuPlayer::RTSPSource::kUnderflowMarkUs   =  1000000ll;
@@ -61,7 +64,10 @@ NuPlayer::RTSPSource::RTSPSource(
       mEOSPending(false),
       mSeekGeneration(0),
       mEOSTimeoutAudio(0),
-      mEOSTimeoutVideo(0) {
+      mEOSTimeoutVideo(0),
+      mVideoTrackIndex(-1),
+      mKeepDamagedAccessUnits(false),
+      mNumKeepDamagedAccessUnits(0) {
     if (headers) {
         mExtraHeaders = *headers;
 
@@ -559,11 +565,22 @@ void NuPlayer::RTSPSource::onMessageReceived(const sp<AMessage> &msg) {
             sp<ABuffer> accessUnit;
             CHECK(msg->findBuffer("accessUnit", &accessUnit));
 
+            bool isVideo = trackIndex == (size_t)mVideoTrackIndex;
             int32_t damaged;
             if (accessUnit->meta()->findInt32("damaged", &damaged)
                     && damaged) {
-                ALOGI("dropping damaged access unit.");
-                break;
+                if (isVideo && mKeepDamagedAccessUnits
+                        && mNumKeepDamagedAccessUnits < kMaxNumKeepDamagedAccessUnits) {
+                    ALOGI("keep a damaged access unit.");
+                    ++mNumKeepDamagedAccessUnits;
+                } else {
+                    ALOGI("dropping damaged access unit.");
+                    break;
+                }
+            } else {
+                if (isVideo) {
+                    mNumKeepDamagedAccessUnits = 0;
+                }
             }
 
             if (mTSParser != NULL) {
@@ -601,8 +618,11 @@ void NuPlayer::RTSPSource::onMessageReceived(const sp<AMessage> &msg) {
                 if (!info->mNPTMappingValid) {
                     // This is a live stream, we didn't receive any normal
                     // playtime mapping. We won't map to npt time.
-                    source->queueAccessUnit(accessUnit);
-                    break;
+                    if (!AVMediaServiceUtils::get()->checkNPTMapping(&info->mRTPTime,
+                            &info->mNormalPlaytimeUs, &info->mNPTMappingValid, rtpTime)) {
+                        source->queueAccessUnit(accessUnit);
+                        break;
+                    }
                 }
 
                 int64_t nptUs =
@@ -679,6 +699,14 @@ void NuPlayer::RTSPSource::onMessageReceived(const sp<AMessage> &msg) {
             break;
         }
 
+        case MyHandler::kWhatByeReceived:
+        {
+            sp<AMessage> msg = dupNotify();
+            msg->setInt32("what", kWhatRTCPByeReceived);
+            msg->post();
+            break;
+        }
+
         case SDPLoader::kWhatSDPLoaded:
         {
             onSDPLoaded(msg);
@@ -713,6 +741,16 @@ void NuPlayer::RTSPSource::onConnected() {
         bool isAudio = !strncasecmp(mime, "audio/", 6);
         bool isVideo = !strncasecmp(mime, "video/", 6);
 
+        if (isVideo) {
+            mVideoTrackIndex = i;
+            char value[PROPERTY_VALUE_MAX];
+            if (property_get("rtsp.video.keep-damaged-au", value, NULL)
+                    && !strcasecmp(mime, value)) {
+                ALOGV("enable to keep damaged au for %s", mime);
+                mKeepDamagedAccessUnits = true;
+            }
+        }
+
         TrackInfo info;
         info.mTimeScale = timeScale;
         info.mRTPTime = 0;
diff --git a/media/libmediaplayerservice/nuplayer/RTSPSource.h b/media/libmediaplayerservice/nuplayer/RTSPSource.h
index c7834ef..77ab1ce 100644
--- a/media/libmediaplayerservice/nuplayer/RTSPSource.h
+++ b/media/libmediaplayerservice/nuplayer/RTSPSource.h
@@ -126,6 +126,10 @@ private:
 
     sp<AReplyToken> mSeekReplyID;
 
+    int32_t mVideoTrackIndex;
+    bool mKeepDamagedAccessUnits;
+    uint32_t mNumKeepDamagedAccessUnits;
+
     sp<AnotherPacketSource> getSource(bool audio);
 
     void onConnected();
diff --git a/media/libstagefright/rtsp/AH263Assembler.cpp b/media/libstagefright/rtsp/AH263Assembler.cpp
index 75cd911..28594e2 100644
--- a/media/libstagefright/rtsp/AH263Assembler.cpp
+++ b/media/libstagefright/rtsp/AH263Assembler.cpp
@@ -27,6 +27,8 @@
 #include <media/stagefright/foundation/hexdump.h>
 #include <media/stagefright/Utils.h>
 
+#include <mediaplayerservice/AVMediaServiceExtensions.h>
+
 namespace android {
 
 AH263Assembler::AH263Assembler(const sp<AMessage> &notify)
@@ -63,7 +65,8 @@ ARTPAssembler::AssemblyStatus AH263Assembler::addPacket(
             if ((uint32_t)(*it)->int32Data() >= mNextExpectedSeqNo) {
                 break;
             }
-
+            AVMediaServiceUtils::get()->addH263AdvancedPacket(
+                    *it, &mPackets, mAccessUnitRTPTime);
             it = queue->erase(it);
         }
 
diff --git a/media/libstagefright/rtsp/ARTPConnection.cpp b/media/libstagefright/rtsp/ARTPConnection.cpp
index a86ab74..e021b29 100644
--- a/media/libstagefright/rtsp/ARTPConnection.cpp
+++ b/media/libstagefright/rtsp/ARTPConnection.cpp
@@ -81,7 +81,8 @@ void ARTPConnection::addStream(
         const sp<ASessionDescription> &sessionDesc,
         size_t index,
         const sp<AMessage> &notify,
-        bool injected) {
+        bool injected,
+        bool isIPV6) {
     sp<AMessage> msg = new AMessage(kWhatAddStream, this);
     msg->setInt32("rtp-socket", rtpSocket);
     msg->setInt32("rtcp-socket", rtcpSocket);
@@ -89,6 +90,7 @@ void ARTPConnection::addStream(
     msg->setSize("index", index);
     msg->setMessage("notify", notify);
     msg->setInt32("injected", injected);
+    msg->setInt32("isIPV6", isIPV6);
     msg->post();
 }
 
@@ -145,6 +147,10 @@ void ARTPConnection::MakePortPair(
     TRESPASS();
 }
 
+size_t ARTPConnection::sockAddrSize() {
+    return sizeof(struct sockaddr_in);
+}
+
 void ARTPConnection::onMessageReceived(const sp<AMessage> &msg) {
     switch (msg->what()) {
         case kWhatAddStream:
@@ -345,7 +351,7 @@ void ARTPConnection::onPollStreams() {
                     n = sendto(
                         s->mRTCPSocket, buffer->data(), buffer->size(), 0,
                         (const struct sockaddr *)&s->mRemoteRTCPAddr,
-                        sizeof(s->mRemoteRTCPAddr));
+                        sockAddrSize());
                 } while (n < 0 && errno == EINTR);
 
                 if (n <= 0) {
diff --git a/media/libstagefright/rtsp/ARTPConnection.h b/media/libstagefright/rtsp/ARTPConnection.h
index edbcc35..057007b 100644
--- a/media/libstagefright/rtsp/ARTPConnection.h
+++ b/media/libstagefright/rtsp/ARTPConnection.h
@@ -38,7 +38,8 @@ struct ARTPConnection : public AHandler {
             int rtpSocket, int rtcpSocket,
             const sp<ASessionDescription> &sessionDesc, size_t index,
             const sp<AMessage> &notify,
-            bool injected);
+            bool injected,
+            bool isIPV6 = false);
 
     void removeStream(int rtpSocket, int rtcpSocket);
 
@@ -53,8 +54,8 @@ struct ARTPConnection : public AHandler {
 protected:
     virtual ~ARTPConnection();
     virtual void onMessageReceived(const sp<AMessage> &msg);
+    virtual size_t sockAddrSize();
 
-private:
     enum {
         kWhatAddStream,
         kWhatRemoveStream,
@@ -72,7 +73,7 @@ private:
     bool mPollEventPending;
     int64_t mLastReceiverReportTimeUs;
 
-    void onAddStream(const sp<AMessage> &msg);
+    virtual void onAddStream(const sp<AMessage> &msg);
     void onRemoveStream(const sp<AMessage> &msg);
     void onPollStreams();
     void onInjectPacket(const sp<AMessage> &msg);
diff --git a/media/libstagefright/rtsp/ARTSPConnection.cpp b/media/libstagefright/rtsp/ARTSPConnection.cpp
index 5620cf8..0de9455 100644
--- a/media/libstagefright/rtsp/ARTSPConnection.cpp
+++ b/media/libstagefright/rtsp/ARTSPConnection.cpp
@@ -26,6 +26,7 @@
 #include <media/stagefright/foundation/base64.h>
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/Utils.h>
+#include <mediaplayerservice/AVMediaServiceExtensions.h>
 
 #include <arpa/inet.h>
 #include <fcntl.h>
@@ -170,7 +171,7 @@ bool ARTSPConnection::ParseURL(
         }
     }
 
-    const char *colonPos = strchr(host->c_str(), ':');
+    const char *colonPos = AVMediaServiceUtils::get()->parseURL(host);
 
     if (colonPos != NULL) {
         unsigned long x;
@@ -252,6 +253,11 @@ void ARTSPConnection::onConnect(const sp<AMessage> &msg) {
         ALOGV("user = '%s', pass = '%s'", mUser.c_str(), mPass.c_str());
     }
 
+    performConnect(reply, host, port);
+}
+
+void ARTSPConnection::performConnect(const sp<AMessage> &reply,
+        AString host, unsigned port) {
     struct hostent *ent = gethostbyname(host.c_str());
     if (ent == NULL) {
         ALOGE("Unknown host %s", host.c_str());
@@ -381,7 +387,12 @@ void ARTSPConnection::onCompleteConnection(const sp<AMessage> &msg) {
     socklen_t optionLen = sizeof(err);
     CHECK_EQ(getsockopt(mSocket, SOL_SOCKET, SO_ERROR, &err, &optionLen), 0);
     CHECK_EQ(optionLen, (socklen_t)sizeof(err));
+    performCompleteConnection(msg, err);
+}
 
+void ARTSPConnection::performCompleteConnection(const sp<AMessage> &msg, int err) {
+    sp<AMessage> reply;
+    CHECK(msg->findMessage("reply", &reply));
     if (err != 0) {
         ALOGE("err = %d (%s)", err, strerror(err));
 
diff --git a/media/libstagefright/rtsp/ARTSPConnection.h b/media/libstagefright/rtsp/ARTSPConnection.h
index 1fe9c99..c4ebe1d 100644
--- a/media/libstagefright/rtsp/ARTSPConnection.h
+++ b/media/libstagefright/rtsp/ARTSPConnection.h
@@ -42,6 +42,8 @@ struct ARTSPConnection : public AHandler {
 
     void observeBinaryData(const sp<AMessage> &reply);
 
+    virtual bool isIPV6() { return false; }
+
     static bool ParseURL(
             const char *url, AString *host, unsigned *port, AString *path,
             AString *user, AString *pass);
@@ -49,8 +51,11 @@ struct ARTSPConnection : public AHandler {
 protected:
     virtual ~ARTSPConnection();
     virtual void onMessageReceived(const sp<AMessage> &msg);
+    virtual void performConnect(const sp<AMessage> &reply,
+            AString host, unsigned port);
+    virtual void performCompleteConnection(const sp<AMessage> &msg,
+            int err);
 
-private:
     enum State {
         DISCONNECTED,
         CONNECTING,
diff --git a/media/libstagefright/rtsp/ASessionDescription.cpp b/media/libstagefright/rtsp/ASessionDescription.cpp
index 8b0331a..d101c0f 100644
--- a/media/libstagefright/rtsp/ASessionDescription.cpp
+++ b/media/libstagefright/rtsp/ASessionDescription.cpp
@@ -23,6 +23,7 @@
 
 #include <media/stagefright/foundation/ADebug.h>
 #include <media/stagefright/foundation/AString.h>
+#include <mediaplayerservice/AVMediaServiceExtensions.h>
 
 #include <stdlib.h>
 
@@ -270,7 +271,8 @@ bool ASessionDescription::getDurationUs(int64_t *durationUs) const {
     }
 
     float from, to;
-    if (!parseNTPRange(value.c_str() + 4, &from, &to)) {
+    if (!AVMediaServiceUtils::get()->parseNTPRange(
+            value.c_str() + 4, &from, &to)) {
         return false;
     }
 
diff --git a/media/libstagefright/rtsp/Android.mk b/media/libstagefright/rtsp/Android.mk
index bdda19c..5e50ad6 100644
--- a/media/libstagefright/rtsp/Android.mk
+++ b/media/libstagefright/rtsp/Android.mk
@@ -22,8 +22,10 @@ LOCAL_SRC_FILES:=       \
 LOCAL_SHARED_LIBRARIES += libcrypto
 
 LOCAL_C_INCLUDES:= \
-	$(TOP)/frameworks/av/media/libstagefright \
-	$(TOP)/frameworks/native/include/media/openmax
+        $(TOP)/frameworks/av/media/libstagefright \
+        $(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/frameworks/av/media/libmediaplayerservice \
 
 LOCAL_MODULE:= libstagefright_rtsp
 
diff --git a/media/libstagefright/rtsp/MyHandler.h b/media/libstagefright/rtsp/MyHandler.h
index 76e2e6e..d02d2a3 100644
--- a/media/libstagefright/rtsp/MyHandler.h
+++ b/media/libstagefright/rtsp/MyHandler.h
@@ -32,6 +32,7 @@
 #include "ASessionDescription.h"
 
 #include <ctype.h>
+#include <cutils/properties.h>
 
 #include <media/stagefright/foundation/ABuffer.h>
 #include <media/stagefright/foundation/ADebug.h>
@@ -39,6 +40,7 @@
 #include <media/stagefright/foundation/AMessage.h>
 #include <media/stagefright/MediaErrors.h>
 #include <media/stagefright/Utils.h>
+#include <mediaplayerservice/AVMediaServiceExtensions.h>
 
 #include <arpa/inet.h>
 #include <sys/socket.h>
@@ -67,6 +69,7 @@ static int64_t kPauseDelayUs = 3000000ll;
 // The allowed maximum number of stale access units at the beginning of
 // a new sequence.
 static int32_t kMaxAllowedStaleAccessUnits = 20;
+static int64_t kTearDownTimeoutUs = 3000000ll;
 
 namespace android {
 
@@ -109,6 +112,7 @@ struct MyHandler : public AHandler {
         kWhatEOS                        = 'eos!',
         kWhatSeekDiscontinuity          = 'seeD',
         kWhatNormalPlayTimeMapping      = 'nptM',
+        kWhatByeReceived                = 'byeR',
     };
 
     MyHandler(
@@ -119,8 +123,6 @@ struct MyHandler : public AHandler {
           mUIDValid(uidValid),
           mUID(uid),
           mNetLooper(new ALooper),
-          mConn(new ARTSPConnection(mUIDValid, mUID)),
-          mRTPConn(new ARTPConnection),
           mOriginalSessionURL(url),
           mSessionURL(url),
           mSetupTracksSuccessful(false),
@@ -144,6 +146,9 @@ struct MyHandler : public AHandler {
           mPausing(false),
           mPauseGeneration(0),
           mPlayResponseParsed(false) {
+        mConn = AVMediaServiceFactory::get()->createARTSPConnection(
+                mUIDValid, uid);
+        mRTPConn = AVMediaServiceFactory::get()->createARTPConnection();
         mNetLooper->setName("rtsp net");
         mNetLooper->start(false /* runOnCallingThread */,
                           false /* canCallJava */,
@@ -707,6 +712,7 @@ struct MyHandler : public AHandler {
                                      timeoutSecs);
                             }
                         }
+                        AVMediaServiceUtils::get()->setServerTimeoutUs(mKeepAliveTimeoutUs);
 
                         i = mSessionID.find(";");
                         if (i >= 0) {
@@ -726,16 +732,19 @@ struct MyHandler : public AHandler {
 
                                 // We are going to continue even if we were
                                 // unable to poke a hole into the firewall...
-                                pokeAHole(
+                                AVMediaServiceUtils::get()->pokeAHole(
+                                        this,
                                         track->mRTPSocket,
                                         track->mRTCPSocket,
-                                        transport);
+                                        transport,
+                                        mSessionHost);
                             }
 
                             mRTPConn->addStream(
                                     track->mRTPSocket, track->mRTCPSocket,
                                     mSessionDesc, index,
-                                    notify, track->mUsingInterleavedTCP);
+                                    notify, track->mUsingInterleavedTCP,
+                                    mConn->isIPV6());
 
                             mSetupTracksSuccessful = true;
                         } else {
@@ -778,6 +787,7 @@ struct MyHandler : public AHandler {
                     request.append(mSessionID);
                     request.append("\r\n");
 
+                    AVMediaServiceUtils::get()->appendRange(&request);
                     request.append("\r\n");
 
                     sp<AMessage> reply = new AMessage('play', this);
@@ -926,6 +936,15 @@ struct MyHandler : public AHandler {
                 request.append("\r\n");
 
                 mConn->sendRequest(request.c_str(), reply);
+
+                // If the response of teardown hasn't been received in 3 seconds,
+                // post 'tear' message to avoid ANR.
+                if (!msg->findInt32("reconnect", &reconnect) || !reconnect) {
+                    sp<AMessage> teardown = new AMessage('tear', this);
+                    teardown->setInt32("result", -ECONNABORTED);
+                    teardown->post(kTearDownTimeoutUs);
+                }
+
                 break;
             }
 
@@ -1029,6 +1048,13 @@ struct MyHandler : public AHandler {
                 int32_t eos;
                 if (msg->findInt32("eos", &eos)) {
                     ALOGI("received BYE on track index %zu", trackIndex);
+                    char value[PROPERTY_VALUE_MAX] = {0};
+                    if (property_get("rtcp.bye.notify", value, "false")
+                            && !strcasecmp(value, "true")) {
+                        sp<AMessage> msg = mNotify->dup();
+                        msg->setInt32("what", kWhatByeReceived);
+                        msg->post();
+                    }
                     if (!mAllTracksHaveTime && dataReceivedOnAllChannels()) {
                         ALOGI("No time established => fake existing data");
 
@@ -1486,7 +1512,9 @@ struct MyHandler : public AHandler {
 
             size_t trackIndex = 0;
             while (trackIndex < mTracks.size()
-                    && !(val == mTracks.editItemAt(trackIndex).mURL)) {
+                    && !(AVMediaServiceUtils::get()->parseTrackURL(
+                    mTracks.editItemAt(trackIndex).mURL, val)
+                    || val == mTracks.editItemAt(trackIndex).mURL)) {
                 ++trackIndex;
             }
             CHECK_LT(trackIndex, mTracks.size());
@@ -1666,8 +1694,9 @@ private:
             request.append(interleaveIndex + 1);
         } else {
             unsigned rtpPort;
-            ARTPConnection::MakePortPair(
-                    &info->mRTPSocket, &info->mRTCPSocket, &rtpPort);
+            AVMediaServiceUtils::get()->makePortPair(
+                    &info->mRTPSocket, &info->mRTCPSocket, &rtpPort,
+                    mConn->isIPV6());
 
             if (mUIDValid) {
                 HTTPBase::RegisterSocketUserTag(info->mRTPSocket, mUID,
@@ -1917,7 +1946,7 @@ private:
             mLastMediaTimeUs = mediaTimeUs;
         }
 
-        if (mediaTimeUs < 0) {
+        if (mediaTimeUs < 0 && !mSeekable) {
             ALOGV("dropping early accessUnit.");
             return false;
         }
-- 
2.7.4


From 510bf041ead24b3778cfcee28bc75cff70c02eaa Mon Sep 17 00:00:00 2001
From: Santhosh Behara <santhoshbehara@codeaurora.org>
Date: Fri, 28 Aug 2015 14:40:58 +0800
Subject: [PATCH 20/39] httplive: refactor for HLS customization

List of changes that are squashed:-

Extend NuPlayer setDataSource for streaming.
Change-Id: Ic87c3744bf905eb8742863951b809e38d0a60339

httplive: Add default implementation in HLS for custom changes
Change-Id: I5e2bc7a42e0d4a16d5b5ea5f2ec3d78a7d019ad3

Stagefright: Extensions for HEVC in ATSParser
Change-Id: I05d623fbf5a4e2b260f68c5e591ac0f123ef2f37

Change access modifiers and add overridable methods in HLS stack.

Change-Id: Iae8e77246cc6643735af18617717fba713d0038c
---
 media/libavextensions/Android.mk                   |  4 +++-
 .../mediaplayerservice/AVNuExtensions.h            |  1 +
 .../mediaplayerservice/AVNuUtils.cpp               |  4 ++++
 media/libavextensions/stagefright/AVExtensions.h   |  8 +++++--
 media/libavextensions/stagefright/AVFactory.cpp    |  5 +++++
 media/libavextensions/stagefright/AVUtils.cpp      |  4 ++++
 media/libmediaplayerservice/Android.mk             |  1 +
 .../nuplayer/HTTPLiveSource.h                      |  3 +--
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp  |  2 +-
 media/libmediaplayerservice/nuplayer/NuPlayer.h    |  5 +++--
 .../nuplayer/NuPlayerDecoder.cpp                   |  1 +
 media/libstagefright/Android.mk                    |  1 +
 media/libstagefright/Utils.cpp                     |  2 +-
 media/libstagefright/httplive/Android.mk           |  2 ++
 media/libstagefright/httplive/LiveSession.cpp      |  2 +-
 media/libstagefright/httplive/LiveSession.h        | 25 ++++++++++++++--------
 media/libstagefright/httplive/PlaylistFetcher.cpp  | 14 +++++++++---
 media/libstagefright/httplive/PlaylistFetcher.h    |  3 ++-
 media/libstagefright/mpeg2ts/ATSParser.cpp         | 16 +++++++++++---
 media/libstagefright/mpeg2ts/ATSParser.h           |  1 +
 media/libstagefright/mpeg2ts/Android.mk            |  3 ++-
 media/libstagefright/mpeg2ts/ESQueue.cpp           |  3 +++
 media/libstagefright/mpeg2ts/ESQueue.h             | 11 +++++++++-
 23 files changed, 93 insertions(+), 28 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index 18ee639..ce471da 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -12,7 +12,9 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/external/flac/include \
-        $(TOP)/hardware/qcom/media/mm-core/inc
+        $(TOP)/hardware/qcom/media/mm-core/inc \
+        $(TOP)/frameworks/av/media/libstagefright \
+        $(TOP)/frameworks/av/media/libstagefright/mpeg2ts \
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
 
diff --git a/media/libavextensions/mediaplayerservice/AVNuExtensions.h b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
index 55eb4d6..a4e5e94 100644
--- a/media/libavextensions/mediaplayerservice/AVNuExtensions.h
+++ b/media/libavextensions/mediaplayerservice/AVNuExtensions.h
@@ -59,6 +59,7 @@ struct AVNuUtils {
     virtual void printFileName(int fd);
     virtual bool dropCorruptFrame();
     virtual void addFlagsInMeta(const sp<ABuffer> &buffer, int32_t flags, bool isAudio);
+    virtual void checkFormatChange(bool *formatChange, const sp<ABuffer> &accessUnit);
 
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVNuUtils);
diff --git a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
index c1874b7..600c2cd 100644
--- a/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
+++ b/media/libavextensions/mediaplayerservice/AVNuUtils.cpp
@@ -56,6 +56,10 @@ void AVNuUtils::addFlagsInMeta(const sp<ABuffer> & /*buffer*/,
         int32_t /*flags*/, bool /*isAudio*/) {
 }
 
+void AVNuUtils::checkFormatChange(bool * /*formatChange*/,
+        const sp<ABuffer> & /*accessUnit*/) {
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVNuUtils::AVNuUtils() {}
 
diff --git a/media/libavextensions/stagefright/AVExtensions.h b/media/libavextensions/stagefright/AVExtensions.h
index 77c8984..bf91160 100644
--- a/media/libavextensions/stagefright/AVExtensions.h
+++ b/media/libavextensions/stagefright/AVExtensions.h
@@ -35,7 +35,7 @@
 #include <media/IOMX.h>
 #include <camera/android/hardware/ICamera.h>
 #include <media/mediarecorder.h>
-
+#include "ESQueue.h"
 
 namespace android {
 
@@ -64,7 +64,8 @@ struct AVFactory {
     virtual MediaExtractor* updateExtractor(
             MediaExtractor* ext, const sp<DataSource> &source,
             const char *mime, const sp<AMessage> &meta);
-
+    virtual ElementaryStreamQueue* createESQueue(
+            ElementaryStreamQueue::Mode mode, uint32_t flags = 0);
     virtual CameraSource *CreateCameraSourceFromCamera(
             const sp<hardware::ICamera> &camera,
             const sp<ICameraRecordingProxy> &proxy,
@@ -160,6 +161,9 @@ struct AVUtils {
                 int nPFrames, int nBFrames, const sp<IOMX> OMXhandle,
                 IOMX::node_id nodeID);
 
+    // Used by ATSParser
+    virtual bool IsHevcIDR(const sp<ABuffer> &accessUnit);
+
     // ----- NO TRESSPASSING BEYOND THIS LINE ------
     DECLARE_LOADABLE_SINGLETON(AVUtils);
 };
diff --git a/media/libavextensions/stagefright/AVFactory.cpp b/media/libavextensions/stagefright/AVFactory.cpp
index 32dcc57..b1924ec 100644
--- a/media/libavextensions/stagefright/AVFactory.cpp
+++ b/media/libavextensions/stagefright/AVFactory.cpp
@@ -101,6 +101,10 @@ MPEG4Writer* AVFactory::CreateMPEG4Writer(int fd) {
     return new MPEG4Writer(fd);
 }
 
+ElementaryStreamQueue* AVFactory::createESQueue(
+         ElementaryStreamQueue::Mode , uint32_t ) {
+    return NULL;
+}
 AudioSource* AVFactory::createAudioSource(
             audio_source_t inputSource,
             const String16 &opPackageName,
@@ -112,6 +116,7 @@ AudioSource* AVFactory::createAudioSource(
     return new AudioSource(inputSource, opPackageName, sampleRate,
                             channels, outSampleRate, clientUid, clientPid);
 }
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVFactory::AVFactory() {
 }
diff --git a/media/libavextensions/stagefright/AVUtils.cpp b/media/libavextensions/stagefright/AVUtils.cpp
index 8fe6aef..e026578 100644
--- a/media/libavextensions/stagefright/AVUtils.cpp
+++ b/media/libavextensions/stagefright/AVUtils.cpp
@@ -149,6 +149,10 @@ const char *AVUtils::getCustomCodecsPerformanceLocation() {
     return "/etc/media_codecs_performance.xml";
 }
 
+bool AVUtils::IsHevcIDR(const sp<ABuffer> &) {
+   return false;
+}
+
 // ----- NO TRESSPASSING BEYOND THIS LINE ------
 AVUtils::AVUtils() {}
 
diff --git a/media/libmediaplayerservice/Android.mk b/media/libmediaplayerservice/Android.mk
index b261536..d556ec9 100644
--- a/media/libmediaplayerservice/Android.mk
+++ b/media/libmediaplayerservice/Android.mk
@@ -71,6 +71,7 @@ LOCAL_C_INCLUDES :=                                                 \
     $(TOP)/external/tremolo/Tremolo                                 \
     libcore/include                                                 \
     $(TOP)/frameworks/av/media/libavextensions                      \
+    $(TOP)/frameworks/av/media/libstagefright/mpeg2ts               \
 
 LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
 # DOLBY_START
diff --git a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
index 574937d..0208fdc 100644
--- a/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
+++ b/media/libmediaplayerservice/nuplayer/HTTPLiveSource.h
@@ -54,7 +54,6 @@ protected:
 
     virtual void onMessageReceived(const sp<AMessage> &msg);
 
-private:
     enum Flags {
         // Don't log any URLs.
         kFlagIncognito = 1,
@@ -79,7 +78,7 @@ private:
     bool mHasMetadata;
     bool mMetadataSelected;
 
-    void onSessionNotify(const sp<AMessage> &msg);
+    virtual void onSessionNotify(const sp<AMessage> &msg);
     void pollForRawData(
             const sp<AMessage> &msg, int32_t currentGeneration,
             LiveSession::StreamType fetchType, int32_t pushWhat);
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 714063a..916dec8 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -241,7 +241,7 @@ void NuPlayer::setDataSourceAsync(const sp<IStreamSource> &source) {
     msg->post();
 }
 
-static bool IsHTTPLiveURL(const char *url) {
+bool NuPlayer::IsHTTPLiveURL(const char *url) {
     if (!strncasecmp("http://", url, 7)
             || !strncasecmp("https://", url, 8)
             || !strncasecmp("file://", url, 7)) {
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.h b/media/libmediaplayerservice/nuplayer/NuPlayer.h
index 4a7f96e..73d7c1c 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.h
@@ -60,7 +60,7 @@ struct NuPlayer : public AHandler {
 
     void setDataSourceAsync(const sp<IStreamSource> &source);
 
-    void setDataSourceAsync(
+    virtual void setDataSourceAsync(
             const sp<IMediaHTTPService> &httpService,
             const char *url,
             const KeyedVector<String8, String8> *headers);
@@ -109,6 +109,7 @@ protected:
     virtual void setDecodedPcmOffload(bool /*decodePcmOffload*/) {}
     virtual bool canOffloadDecodedPCMStream(const sp<MetaData> /*meta*/,
             bool /*hasVideo*/, bool /*isStreaming*/, audio_stream_type_t /*streamType*/) {return false;}
+    static bool IsHTTPLiveURL(const char *url);
 public:
     struct NuPlayerStreamListener;
     struct Source;
@@ -292,7 +293,7 @@ protected:
     void performSetSurface(const sp<Surface> &wrapper);
     void performResumeDecoders(bool needNotify);
 
-    void onSourceNotify(const sp<AMessage> &msg);
+    virtual void onSourceNotify(const sp<AMessage> &msg);
     void onClosedCaptionNotify(const sp<AMessage> &msg);
 
     void queueDecoderShutdown(
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index cf9438e..214f8e2 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -821,6 +821,7 @@ status_t NuPlayer::Decoder::fetchInputData(sp<AMessage> &reply) {
                     // treat seamless format change separately
                     formatChange = !seamlessFormatChange;
                 }
+                AVNuUtils::get()->checkFormatChange(&formatChange, accessUnit);
 
                 // For format or time change, return EOS to queue EOS input,
                 // then wait for EOS on output.
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 7187922..c4e273b 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -80,6 +80,7 @@ LOCAL_SRC_FILES:=                         \
 LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/include/media/ \
         $(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/av/media/libstagefright/mpeg2ts \
         $(TOP)/frameworks/av/include/media/stagefright/timedtext \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
diff --git a/media/libstagefright/Utils.cpp b/media/libstagefright/Utils.cpp
index b92b1c4..dd420ab 100644
--- a/media/libstagefright/Utils.cpp
+++ b/media/libstagefright/Utils.cpp
@@ -873,7 +873,7 @@ status_t convertMetaDataToMessage(
     } else if (meta->findData(kKeyHVCC, &type, &data, &size)) {
         const uint8_t *ptr = (const uint8_t *)data;
 
-        if (size < 23 || ptr[0] != 1) {  // configurationVersion == 1
+        if (size < 23 || ptr[0] > 1) {  // configurationVersion == 1
             ALOGE("b/23680780");
             return BAD_VALUE;
         }
diff --git a/media/libstagefright/httplive/Android.mk b/media/libstagefright/httplive/Android.mk
index f904212..107f9fa 100644
--- a/media/libstagefright/httplive/Android.mk
+++ b/media/libstagefright/httplive/Android.mk
@@ -11,6 +11,8 @@ LOCAL_SRC_FILES:=               \
 
 LOCAL_C_INCLUDES:= \
 	$(TOP)/frameworks/av/media/libstagefright \
+	$(TOP)/frameworks/av/media/libavextensions \
+        $(TOP)/frameworks/av/media/libstagefright/mpeg2ts \
 	$(TOP)/frameworks/native/include/media/openmax
 
 LOCAL_CFLAGS += -Werror -Wall
diff --git a/media/libstagefright/httplive/LiveSession.cpp b/media/libstagefright/httplive/LiveSession.cpp
index 7abc019..051a2fa 100644
--- a/media/libstagefright/httplive/LiveSession.cpp
+++ b/media/libstagefright/httplive/LiveSession.cpp
@@ -54,7 +54,7 @@ const int64_t LiveSession::kReadyMarkUs = 5000000ll;
 const int64_t LiveSession::kPrepareMarkUs = 1500000ll;
 const int64_t LiveSession::kUnderflowMarkUs = 1000000ll;
 
-struct LiveSession::BandwidthEstimator : public RefBase {
+struct LiveSession::BandwidthEstimator : public LiveSession::BandwidthBaseEstimator {
     BandwidthEstimator();
 
     void addBandwidthMeasurement(size_t numBytes, int64_t delayUs);
diff --git a/media/libstagefright/httplive/LiveSession.h b/media/libstagefright/httplive/LiveSession.h
index b600eba..cfe2283 100644
--- a/media/libstagefright/httplive/LiveSession.h
+++ b/media/libstagefright/httplive/LiveSession.h
@@ -73,7 +73,7 @@ struct LiveSession : public AHandler {
             const sp<IMediaHTTPService> &httpService);
 
     int64_t calculateMediaTimeUs(int64_t firstTimeUs, int64_t timeUs, int32_t discontinuitySeq);
-    status_t dequeueAccessUnit(StreamType stream, sp<ABuffer> *accessUnit);
+    virtual status_t dequeueAccessUnit(StreamType stream, sp<ABuffer> *accessUnit);
 
     status_t getStreamFormatMeta(StreamType stream, sp<MetaData> *meta);
 
@@ -117,7 +117,6 @@ protected:
 
     virtual void onMessageReceived(const sp<AMessage> &msg);
 
-private:
     friend struct PlaylistFetcher;
 
     enum {
@@ -142,6 +141,14 @@ private:
     static const int64_t kPrepareMarkUs;
     static const int64_t kUnderflowMarkUs;
 
+    struct BandwidthBaseEstimator : public RefBase {
+        virtual void addBandwidthMeasurement(size_t numBytes, int64_t delayUs) = 0;
+        virtual bool estimateBandwidth(
+                int32_t *bandwidth,
+                bool *isStable = NULL,
+                int32_t *shortTermBps = NULL) = 0;
+    };
+
     struct BandwidthEstimator;
     struct BandwidthItem {
         size_t mPlaylistIndex;
@@ -201,7 +208,7 @@ private:
     ssize_t mOrigBandwidthIndex;
     int32_t mLastBandwidthBps;
     bool mLastBandwidthStable;
-    sp<BandwidthEstimator> mBandwidthEstimator;
+    sp<BandwidthBaseEstimator> mBandwidthEstimator;
 
     sp<M3UParser> mPlaylist;
     int32_t mMaxWidth;
@@ -251,10 +258,10 @@ private:
     KeyedVector<size_t, int64_t> mDiscontinuityAbsStartTimesUs;
     KeyedVector<size_t, int64_t> mDiscontinuityOffsetTimesUs;
 
-    sp<PlaylistFetcher> addFetcher(const char *uri);
+    virtual sp<PlaylistFetcher> addFetcher(const char *uri);
 
     void onConnect(const sp<AMessage> &msg);
-    void onMasterPlaylistFetched(const sp<AMessage> &msg);
+    virtual void onMasterPlaylistFetched(const sp<AMessage> &msg);
     void onSeek(const sp<AMessage> &msg);
 
     bool UriIsSameAsIndex( const AString &uri, int32_t index, bool newUri);
@@ -269,7 +276,7 @@ private:
     float getAbortThreshold(
             ssize_t currentBWIndex, ssize_t targetBWIndex) const;
     void addBandwidthMeasurement(size_t numBytes, int64_t delayUs);
-    size_t getBandwidthIndex(int32_t bandwidthBps);
+    virtual size_t getBandwidthIndex(int32_t bandwidthBps);
     ssize_t getLowestValidBandwidthIndex() const;
     HLSTime latestMediaSegmentStartTime() const;
 
@@ -284,7 +291,7 @@ private:
     void onChangeConfiguration2(const sp<AMessage> &msg);
     void onChangeConfiguration3(const sp<AMessage> &msg);
 
-    void swapPacketSource(StreamType stream);
+    virtual void swapPacketSource(StreamType stream);
     void tryToFinishBandwidthSwitch(const AString &oldUri);
     void cancelBandwidthSwitch(bool resume = false);
     bool checkSwitchProgress(
@@ -296,7 +303,7 @@ private:
     void schedulePollBuffering();
     void cancelPollBuffering();
     void restartPollBuffering();
-    void onPollBuffering();
+    virtual void onPollBuffering();
     bool checkBuffering(bool &underflow, bool &ready, bool &down, bool &up);
     void startBufferingIfNecessary();
     void stopBufferingIfNecessary();
@@ -304,7 +311,7 @@ private:
 
     void finishDisconnect();
 
-    void postPrepared(status_t err);
+    virtual void postPrepared(status_t err);
     void postError(status_t err);
 
     DISALLOW_EVIL_CONSTRUCTORS(LiveSession);
diff --git a/media/libstagefright/httplive/PlaylistFetcher.cpp b/media/libstagefright/httplive/PlaylistFetcher.cpp
index 7ad7fee..d6bd191 100644
--- a/media/libstagefright/httplive/PlaylistFetcher.cpp
+++ b/media/libstagefright/httplive/PlaylistFetcher.cpp
@@ -33,6 +33,7 @@
 #include <media/stagefright/MediaDefs.h>
 #include <media/stagefright/MetaData.h>
 #include <media/stagefright/Utils.h>
+#include <stagefright/AVExtensions.h>
 
 #include <ctype.h>
 #include <inttypes.h>
@@ -983,7 +984,9 @@ bool PlaylistFetcher::initDownloadState(
         if (mSegmentStartTimeUs < 0) {
             if (!mPlaylist->isComplete() && !mPlaylist->isEvent()) {
                 // If this is a live session, start 3 segments from the end on connect
-                mSeqNumber = lastSeqNumberInPlaylist - 3;
+                if (!getSeqNumberInLiveStreaming()) {
+                    mSeqNumber = lastSeqNumberInPlaylist - 3;
+                }
                 if (mSeqNumber < firstSeqNumberInPlaylist) {
                     mSeqNumber = firstSeqNumberInPlaylist;
                 }
@@ -1432,6 +1435,10 @@ void PlaylistFetcher::onDownloadNext() {
         }
     }
 
+    if (checkSwitchBandwidth()) {
+        return;
+    }
+
     ++mSeqNumber;
 
     // if adapting, pause after found the next starting point
@@ -1722,7 +1729,8 @@ status_t PlaylistFetcher::extractAndQueueAccessUnitsFromTs(const sp<ABuffer> &bu
         const char *mime;
         sp<MetaData> format  = source->getFormat();
         bool isAvc = format != NULL && format->findCString(kKeyMIMEType, &mime)
-                && !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC);
+                && (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC) ||
+                    !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC));
 
         sp<ABuffer> accessUnit;
         status_t finalResult;
@@ -1744,7 +1752,7 @@ status_t PlaylistFetcher::extractAndQueueAccessUnitsFromTs(const sp<ABuffer> &bu
                             (long long)timeUs - mStartTimeUs,
                             mIDRFound);
                     if (isAvc) {
-                        if (IsIDR(accessUnit)) {
+                        if (IsIDR(accessUnit) || AVUtils::get()->IsHevcIDR(accessUnit)) {
                             mVideoBuffer->clear();
                             FSLOGV(stream, "found IDR, clear mVideoBuffer");
                             mIDRFound = true;
diff --git a/media/libstagefright/httplive/PlaylistFetcher.h b/media/libstagefright/httplive/PlaylistFetcher.h
index c8ca457..6b60b65 100644
--- a/media/libstagefright/httplive/PlaylistFetcher.h
+++ b/media/libstagefright/httplive/PlaylistFetcher.h
@@ -89,7 +89,6 @@ protected:
     virtual ~PlaylistFetcher();
     virtual void onMessageReceived(const sp<AMessage> &msg);
 
-private:
     enum {
         kMaxNumRetries         = 5,
     };
@@ -249,6 +248,8 @@ private:
 
     void updateDuration();
     void updateTargetDuration();
+    virtual bool checkSwitchBandwidth() { return false; }
+    virtual bool getSeqNumberInLiveStreaming() { return false; }
 
     DISALLOW_EVIL_CONSTRUCTORS(PlaylistFetcher);
 };
diff --git a/media/libstagefright/mpeg2ts/ATSParser.cpp b/media/libstagefright/mpeg2ts/ATSParser.cpp
index 541a377..70ae220 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.cpp
+++ b/media/libstagefright/mpeg2ts/ATSParser.cpp
@@ -57,6 +57,7 @@
 #include <utils/Vector.h>
 
 #include <inttypes.h>
+#include <stagefright/AVExtensions.h>
 
 namespace android {
 
@@ -622,6 +623,12 @@ ATSParser::Stream::Stream(
                     (mProgram->parserFlags() & ALIGNED_VIDEO_DATA)
                         ? ElementaryStreamQueue::kFlag_AlignedData : 0);
             break;
+        case STREAMTYPE_H265:
+            mQueue = AVFactory::get()->createESQueue(
+                    ElementaryStreamQueue::H265,
+                    (mProgram->parserFlags() & ALIGNED_VIDEO_DATA)
+                        ? ElementaryStreamQueue::kFlag_AlignedData : 0);
+            break;
         case STREAMTYPE_MPEG2_AUDIO_ADTS:
             mQueue = new ElementaryStreamQueue(ElementaryStreamQueue::AAC);
             break;
@@ -765,6 +772,7 @@ status_t ATSParser::Stream::parse(
 bool ATSParser::Stream::isVideo() const {
     switch (mStreamType) {
         case STREAMTYPE_H264:
+        case STREAMTYPE_H265:
         case STREAMTYPE_MPEG1_VIDEO:
         case STREAMTYPE_MPEG2_VIDEO:
         case STREAMTYPE_MPEG4_VIDEO:
@@ -1117,9 +1125,11 @@ void ATSParser::Stream::onPayloadData(
                      mElementaryPID, mStreamType);
 
                 const char *mime;
-                if (meta->findCString(kKeyMIMEType, &mime)
-                        && !strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)
-                        && !IsIDR(accessUnit)) {
+                if (meta->findCString(kKeyMIMEType, &mime) &&
+                        ((!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_AVC)
+                           && !IsIDR(accessUnit)) ||
+                         (!strcasecmp(mime, MEDIA_MIMETYPE_VIDEO_HEVC)
+                          && !AVUtils::get()->IsHevcIDR(accessUnit)))) {
                     continue;
                 }
                 mSource = new AnotherPacketSource(meta);
diff --git a/media/libstagefright/mpeg2ts/ATSParser.h b/media/libstagefright/mpeg2ts/ATSParser.h
index b0a6bff..bc2c70e 100644
--- a/media/libstagefright/mpeg2ts/ATSParser.h
+++ b/media/libstagefright/mpeg2ts/ATSParser.h
@@ -148,6 +148,7 @@ struct ATSParser : public RefBase {
         STREAMTYPE_MPEG4_VIDEO          = 0x10,
         STREAMTYPE_METADATA             = 0x15,
         STREAMTYPE_H264                 = 0x1b,
+        STREAMTYPE_H265                 = 0x24,
 
         // From ATSC A/53 Part 3:2009, 6.7.1
         STREAMTYPE_AC3                  = 0x81,
diff --git a/media/libstagefright/mpeg2ts/Android.mk b/media/libstagefright/mpeg2ts/Android.mk
index 099296b..de8dfd0 100644
--- a/media/libstagefright/mpeg2ts/Android.mk
+++ b/media/libstagefright/mpeg2ts/Android.mk
@@ -24,7 +24,8 @@ LOCAL_SRC_FILES:=                 \
 
 LOCAL_C_INCLUDES:= \
 	$(TOP)/frameworks/av/media/libstagefright \
-	$(TOP)/frameworks/native/include/media/openmax
+	$(TOP)/frameworks/native/include/media/openmax \
+        $(TOP)/frameworks/av/media/libavextensions \
 
 LOCAL_CFLAGS += -Werror -Wall
 # DOLBY_START
diff --git a/media/libstagefright/mpeg2ts/ESQueue.cpp b/media/libstagefright/mpeg2ts/ESQueue.cpp
index fad814d..467e189 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.cpp
+++ b/media/libstagefright/mpeg2ts/ESQueue.cpp
@@ -281,6 +281,7 @@ status_t ElementaryStreamQueue::appendData(
     if (mBuffer == NULL || mBuffer->size() == 0) {
         switch (mMode) {
             case H264:
+            case H265:
             case MPEG_VIDEO:
             {
 #if 0
@@ -546,6 +547,8 @@ sp<ABuffer> ElementaryStreamQueue::dequeueAccessUnit() {
     switch (mMode) {
         case H264:
             return dequeueAccessUnitH264();
+        case H265:
+            return dequeueAccessUnitH265();
         case AAC:
             return dequeueAccessUnitAAC();
         case AC3:
diff --git a/media/libstagefright/mpeg2ts/ESQueue.h b/media/libstagefright/mpeg2ts/ESQueue.h
index 1c7ee2d..bb28a85 100644
--- a/media/libstagefright/mpeg2ts/ESQueue.h
+++ b/media/libstagefright/mpeg2ts/ESQueue.h
@@ -38,6 +38,8 @@
 #define ES_QUEUE_H_
 
 #include <media/stagefright/foundation/ABase.h>
+#include <media/stagefright/foundation/ABuffer.h>
+#include <media/stagefright/MetaData.h>
 #include <utils/Errors.h>
 #include <utils/List.h>
 #include <utils/RefBase.h>
@@ -46,10 +48,12 @@ namespace android {
 
 struct ABuffer;
 class MetaData;
+struct AVUtils;
 
 struct ElementaryStreamQueue {
     enum Mode {
         H264,
+        H265,
         AAC,
         AC3,
 #ifdef DOLBY_ENABLE
@@ -67,6 +71,7 @@ struct ElementaryStreamQueue {
         kFlag_AlignedData = 1,
     };
     ElementaryStreamQueue(Mode mode, uint32_t flags = 0);
+    virtual ~ElementaryStreamQueue() {};
 
     status_t appendData(const void *data, size_t size, int64_t timeUs);
     void signalEOS();
@@ -76,7 +81,7 @@ struct ElementaryStreamQueue {
 
     sp<MetaData> getFormat();
 
-private:
+protected:
     struct RangeInfo {
         int64_t mTimestampUs;
         size_t mLength;
@@ -99,6 +104,9 @@ private:
     sp<ABuffer> dequeueAccessUnitMPEG4Video();
     sp<ABuffer> dequeueAccessUnitPCMAudio();
     sp<ABuffer> dequeueAccessUnitMetadata();
+    virtual sp<ABuffer> dequeueAccessUnitH265() {
+        return NULL;
+    };
 #ifdef DOLBY_ENABLE
     sp<ABuffer> dequeueAccessUnitEAC3();
     unsigned independent_streams_processed;
@@ -109,6 +117,7 @@ private:
     // returns its timestamp in us (or -1 if no time information).
     int64_t fetchTimestamp(size_t size);
 
+private:
     DISALLOW_EVIL_CONSTRUCTORS(ElementaryStreamQueue);
 };
 
-- 
2.7.4


From 6c32eb13e1889df9e415757edfe76cc8a3af0470 Mon Sep 17 00:00:00 2001
From: Sharad Sangle <assangle@codeaurora.org>
Date: Thu, 16 Jul 2015 02:55:47 +0530
Subject: [PATCH 21/39] audio: add support for FLAC and AMRWB+ decoding

Add support for QTI FLAC decoding by setting up
the component only if it is enabled and is not an
encoder.

Add audio group in mediacodec.rc so that AMRWB+
and other audio nodes can be accessed by it.

Change-Id: Ia35b0b9218fdf2584348a2a95bf0401c5065dedc
---
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp | 1 +
 media/libstagefright/ACodec.cpp                           | 5 +++++
 media/libstagefright/Android.mk                           | 6 ++++++
 media/libstagefright/omx/Android.mk                       | 6 ++++++
 media/libstagefright/omx/SoftOMXPlugin.cpp                | 3 +++
 services/mediacodec/mediacodec.rc                         | 2 +-
 6 files changed, 22 insertions(+), 1 deletion(-)
 mode change 100755 => 100644 media/libstagefright/omx/SoftOMXPlugin.cpp

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 9336418..1545e6e 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1863,6 +1863,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
             offloadInfo.bit_rate = avgBitRate;
             offloadInfo.has_video = hasVideo;
             offloadInfo.is_streaming = true;
+            offloadInfo.bit_width = bitWidth;
             offloadInfo.offload_buffer_size = offloadBufferSize;
 
             if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index 52de6ad..ee25ef0 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -2221,7 +2221,12 @@ status_t ACodec::configureCodec(
             }
             err = setupG711Codec(encoder, sampleRate, numChannels);
         }
+#ifdef QTI_FLAC_DECODER
+//setup qti flac component only if it is enabled and it is not encoder
+    } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC) && encoder) {
+#else
     } else if (!strcasecmp(mime, MEDIA_MIMETYPE_AUDIO_FLAC)) {
+#endif
         int32_t numChannels = 0, sampleRate = 0, compressionLevel = -1;
         if (encoder &&
                 (!msg->findInt32("channel-count", &numChannels)
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index c4e273b..03c77ac 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -153,6 +153,12 @@ ifeq ($(strip $(DOLBY_ENABLE)),true)
 endif
 # DOLBY_END
 
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FLAC_DECODER)),true)
+LOCAL_CFLAGS += -DQTI_FLAC_DECODER
+endif
+endif
+
 LOCAL_CLANG := true
 LOCAL_SANITIZE := unsigned-integer-overflow signed-integer-overflow
 
diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index 19370e7..caea7b6 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -44,6 +44,12 @@ LOCAL_SHARED_LIBRARIES :=               \
         libstagefright_foundation       \
         libdl
 
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FLAC_DECODER)),true)
+LOCAL_CFLAGS += -DQTI_FLAC_DECODER
+endif
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 LOCAL_CFLAGS += -Werror -Wall
 # DOLBY_START
diff --git a/media/libstagefright/omx/SoftOMXPlugin.cpp b/media/libstagefright/omx/SoftOMXPlugin.cpp
old mode 100755
new mode 100644
index e9044f7..c49acf1
--- a/media/libstagefright/omx/SoftOMXPlugin.cpp
+++ b/media/libstagefright/omx/SoftOMXPlugin.cpp
@@ -78,6 +78,9 @@ static const struct {
     { "OMX.google.raw.decoder", "rawdec", "audio_decoder.raw" },
     { "OMX.google.flac.encoder", "flacenc", "audio_encoder.flac" },
     { "OMX.google.gsm.decoder", "gsmdec", "audio_decoder.gsm" },
+#ifdef QTI_FLAC_DECODER
+    { "OMX.qti.audio.decoder.flac", "flacdec", "audio_decoder.flac" },
+#endif
 #ifdef DOLBY_ENABLE
     { "OMX.dolby.ac3.decoder", "ddpdec", "audio_decoder.ac3" },
     { "OMX.dolby.eac3.decoder", "ddpdec", "audio_decoder.eac3" },
diff --git a/services/mediacodec/mediacodec.rc b/services/mediacodec/mediacodec.rc
index d78e0a4..0debdd5 100644
--- a/services/mediacodec/mediacodec.rc
+++ b/services/mediacodec/mediacodec.rc
@@ -1,6 +1,6 @@
 service mediacodec /system/bin/mediacodec
     class main
     user mediacodec
-    group camera drmrpc mediadrm
+    group camera drmrpc mediadrm audio
     ioprio rt 4
     writepid /dev/cpuset/foreground/tasks
-- 
2.7.4


From 327dd29805288266ca2e685ec81958ace47822a3 Mon Sep 17 00:00:00 2001
From: Aalique Grahame <agrahame@codeaurora.org>
Date: Wed, 9 Nov 2016 15:57:21 -0800
Subject: [PATCH 22/39] AudioFlinger: increase size of client heap

To successfuly set the playback rate for most tracks, we want to
use a value of 500 for the audio sink buffer size in msec. This is
necessary to meet frame count lower bounds when increasing speed.
However, this buffer size of 500 doesn't allow for successful repeat
mode playback of 192KHz, 8 channels files as one track occupies
3MB out of 4MB of the heap. Hence, increase the heap size.

CRs-Fixed: 1073831
Change-Id: Icfbfcefd0df4e88671e3f10f0031610ef502aa42
---
 services/audioflinger/AudioFlinger.cpp | 3 +++
 services/audioflinger/AudioFlinger.h   | 2 +-
 2 files changed, 4 insertions(+), 1 deletion(-)

diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index 42e478a..f2adb5b 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -1469,6 +1469,9 @@ AudioFlinger::Client::Client(const sp<AudioFlinger>& audioFlinger, pid_t pid)
     size_t heapSize = kClientSharedHeapSizeBytes;
     // Increase heap size on non low ram devices to limit risk of reconnection failure for
     // invalidated tracks
+    kClientSharedHeapSizeMultiplier =
+        property_get_int32("audio.heap.size.multiplier",
+            kClientSharedHeapSizeMultiplier);
     if (!audioFlinger->isLowRamDevice()) {
         heapSize *= kClientSharedHeapSizeMultiplier;
     }
diff --git a/services/audioflinger/AudioFlinger.h b/services/audioflinger/AudioFlinger.h
index 50c1116..11522a6 100644
--- a/services/audioflinger/AudioFlinger.h
+++ b/services/audioflinger/AudioFlinger.h
@@ -105,7 +105,7 @@ static const nsecs_t kDefaultStandbyTimeInNsecs = seconds(3);
 // Max shared memory size for audio tracks and audio records per client process
 static const size_t kClientSharedHeapSizeBytes = 1024*1024;
 // Shared memory size multiplier for non low ram devices
-static const size_t kClientSharedHeapSizeMultiplier = 4;
+static size_t kClientSharedHeapSizeMultiplier = 4;
 
 #define INCLUDING_FROM_AUDIOFLINGER_H
 
-- 
2.7.4


From 7aaf3b6a94ee53b3bc5f77627662fd53aa7bc513 Mon Sep 17 00:00:00 2001
From: Preetam Singh Ranawat <apranawat@codeaurora.org>
Date: Thu, 6 Aug 2015 10:43:16 +0530
Subject: [PATCH 23/39] NuPlayer : send the correct streaming info while
 opening audio sink

 -For any offload playback NuPlayerRenderer always open the audio sink
  with isStreaming info as true.
 -Pass the streaming info to the NuPlayerRenderer while opening audio
  sink

Conflicts:
	media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp

Change-Id: Ic9d5e7ae0b82a316ec4b4a72037519448f1a011c
---
 media/libmediaplayerservice/nuplayer/NuPlayer.cpp          |  2 +-
 media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp   |  2 +-
 .../nuplayer/NuPlayerDecoderPassThrough.cpp                |  2 +-
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp  | 14 ++++++++++----
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h    |  6 ++++--
 5 files changed, 17 insertions(+), 9 deletions(-)

diff --git a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
index 916dec8..9277291 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayer.cpp
@@ -1533,7 +1533,7 @@ void NuPlayer::tryOpenAudioSinkForOffload(
     // is possible; otherwise the decoders call the renderer openAudioSink directly.
 
     status_t err = mRenderer->openAudioSink(
-            format, true /* offloadOnly */, hasVideo, AUDIO_OUTPUT_FLAG_NONE, &mOffloadAudio);
+            format, true /* offloadOnly */, hasVideo, AUDIO_OUTPUT_FLAG_NONE, &mOffloadAudio, mSource->isStreaming());
     if (err != OK) {
         // Any failure we turn off mOffloadAudio.
         mOffloadAudio = false;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
index 214f8e2..6973de6 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoder.cpp
@@ -746,7 +746,7 @@ void NuPlayer::Decoder::handleOutputFormatChange(const sp<AMessage> &format) {
         }
 
         status_t err = mRenderer->openAudioSink(
-                format, false /* offloadOnly */, hasVideo, flags, NULL /* isOffloaed */);
+                format, false /* offloadOnly */, hasVideo, flags, NULL /* isOffloaed */, mSource->isStreaming());
         if (err != OK) {
             handleError(err);
         }
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
index 50f914f..efcbb30 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerDecoderPassThrough.cpp
@@ -74,7 +74,7 @@ void NuPlayer::DecoderPassThrough::onConfigure(const sp<AMessage> &format) {
     // format is different.
     status_t err = mRenderer->openAudioSink(
             format, true /* offloadOnly */, hasVideo,
-            AUDIO_OUTPUT_FLAG_NONE /* flags */, NULL /* isOffloaded */);
+            AUDIO_OUTPUT_FLAG_NONE /* flags */, NULL /* isOffloaded */, mSource->isStreaming());
     if (err != OK) {
         handleError(err);
     }
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 1545e6e..648b7ce 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -396,12 +396,14 @@ status_t NuPlayer::Renderer::openAudioSink(
         bool offloadOnly,
         bool hasVideo,
         uint32_t flags,
-        bool *isOffloaded) {
+        bool *isOffloaded,
+        bool isStreaming) {
     sp<AMessage> msg = new AMessage(kWhatOpenAudioSink, this);
     msg->setMessage("format", format);
     msg->setInt32("offload-only", offloadOnly);
     msg->setInt32("has-video", hasVideo);
     msg->setInt32("flags", flags);
+    msg->setInt32("isStreaming", isStreaming);
 
     sp<AMessage> response;
     msg->postAndAwaitResponse(&response);
@@ -440,7 +442,10 @@ void NuPlayer::Renderer::onMessageReceived(const sp<AMessage> &msg) {
             uint32_t flags;
             CHECK(msg->findInt32("flags", (int32_t *)&flags));
 
-            status_t err = onOpenAudioSink(format, offloadOnly, hasVideo, flags);
+            uint32_t isStreaming;
+            CHECK(msg->findInt32("isStreaming", (int32_t *)&isStreaming));
+
+            status_t err = onOpenAudioSink(format, offloadOnly, hasVideo, flags, isStreaming);
 
             sp<AMessage> response = new AMessage;
             response->setInt32("err", err);
@@ -1789,7 +1794,8 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
         const sp<AMessage> &format,
         bool offloadOnly,
         bool hasVideo,
-        uint32_t flags) {
+        uint32_t flags,
+        bool isStreaming) {
     ALOGV("openAudioSink: offloadOnly(%d) offloadingAudio(%d)",
             offloadOnly, offloadingAudio());
 
@@ -1862,7 +1868,7 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
             offloadInfo.stream_type = AUDIO_STREAM_MUSIC;
             offloadInfo.bit_rate = avgBitRate;
             offloadInfo.has_video = hasVideo;
-            offloadInfo.is_streaming = true;
+            offloadInfo.is_streaming = isStreaming;
             offloadInfo.bit_width = bitWidth;
             offloadInfo.offload_buffer_size = offloadBufferSize;
 
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
index 16fa914..fad44e1 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.h
@@ -78,7 +78,8 @@ struct NuPlayer::Renderer : public AHandler {
             bool offloadOnly,
             bool hasVideo,
             uint32_t flags,
-            bool *isOffloaded);
+            bool *isOffloaded,
+            bool isStreaming);
     void closeAudioSink();
     void signalAudioTearDownComplete();
 
@@ -257,7 +258,8 @@ protected:
             const sp<AMessage> &format,
             bool offloadOnly,
             bool hasVideo,
-            uint32_t flags);
+            uint32_t flags,
+            bool isStreaming);
     void onCloseAudioSink();
     void onAudioTearDownComplete();
 
-- 
2.7.4


From 0d1eaa66bb75b93d1c041c1c79a69465b181ea06 Mon Sep 17 00:00:00 2001
From: Preetam Singh Ranawat <apranawat@codeaurora.org>
Date: Fri, 1 Jul 2016 18:00:09 +0530
Subject: [PATCH 24/39] frameworks/av: Add support for DSD offload playback.

 -Add support for DSD offload playback
 -Keep all QCOM specific formats under one feature flag.

Change-Id: I562c699b5eb7e03693d0f53ec3a63e83fee827bb
---
 .../audiopolicy/common/managerdefinitions/Android.mk     | 16 ++--------------
 .../common/managerdefinitions/src/TypeConverter.cpp      | 11 ++---------
 2 files changed, 4 insertions(+), 23 deletions(-)

diff --git a/services/audiopolicy/common/managerdefinitions/Android.mk b/services/audiopolicy/common/managerdefinitions/Android.mk
index 84c7f1c..1f2b14f 100644
--- a/services/audiopolicy/common/managerdefinitions/Android.mk
+++ b/services/audiopolicy/common/managerdefinitions/Android.mk
@@ -35,20 +35,8 @@ LOCAL_C_INCLUDES := \
     $(TOPDIR)frameworks/av/services/audiopolicy/utilities \
 
 ifeq ($(call is-vendor-board-platform,QCOM),true)
-ifeq ($(strip $(AUDIO_FEATURE_ENABLED_FLAC_OFFLOAD)),true)
-LOCAL_CFLAGS     += -DFLAC_OFFLOAD_ENABLED
-endif
-ifeq ($(strip $(AUDIO_FEATURE_ENABLED_WMA_OFFLOAD)),true)
-LOCAL_CFLAGS     += -DWMA_OFFLOAD_ENABLED
-endif
-ifeq ($(strip $(AUDIO_FEATURE_ENABLED_ALAC_OFFLOAD)),true)
-LOCAL_CFLAGS     += -DALAC_OFFLOAD_ENABLED
-endif
-ifeq ($(strip $(AUDIO_FEATURE_ENABLED_APE_OFFLOAD)),true)
-LOCAL_CFLAGS     += -DAPE_OFFLOAD_ENABLED
-endif
-ifeq ($(strip $(AUDIO_FEATURE_ENABLED_AAC_ADTS_OFFLOAD)),true)
-LOCAL_CFLAGS     += -DAAC_ADTS_OFFLOAD_ENABLED
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_EXTN_FORMATS)),true)
+LOCAL_CFLAGS     += -DAUDIO_EXTN_FORMATS_ENABLED
 endif
 endif
 ifeq ($(USE_XML_AUDIO_POLICY_CONF), 1)
diff --git a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
index d51f186..2e29f18 100644
--- a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
@@ -144,20 +144,12 @@ const FormatConverter::Table FormatConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_DTS_HD),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_IEC61937),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_DOLBY_TRUEHD),
-#ifdef FLAC_OFFLOAD_ENABLED
+#ifdef AUDIO_EXTN_FORMATS_ENABLED
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_FLAC),
-#endif
-#ifdef WMA_OFFLOAD_ENABLED
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_WMA),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_WMA_PRO),
-#endif
-#ifdef ALAC_OFFLOAD_ENABLED
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_ALAC),
-#endif
-#ifdef APE_OFFLOAD_ENABLED
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_APE),
-#endif
-#ifdef AAC_ADTS_OFFLOAD_ENABLED
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_MAIN),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_LC),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_SSR),
@@ -168,6 +160,7 @@ const FormatConverter::Table FormatConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_LD),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_HE_V2),
     MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_AAC_ADTS_ELD),
+    MAKE_STRING_FROM_ENUM(AUDIO_FORMAT_DSD),
 #endif
 };
 template<>
-- 
2.7.4


From 33d1d91b7ad1194f71bb9bc592de94d3b88ca91f Mon Sep 17 00:00:00 2001
From: Manish Dewangan <manish@codeaurora.org>
Date: Thu, 7 Apr 2016 18:48:39 +0530
Subject: [PATCH 25/39] frameworks/av: Changes to match exact format for input
 profile

-Currently a input profile for which device is matched is selected and
 for other parameters such as format, sample rate and channel mask
 it uses best match instead of exact match.
-Change done to check for exact format match and if fails then fall back to
 old approach(best match)

Change-Id: Ic1f839600906b2fb84867b4bcb3ab1d159aa0a67
---
 .../common/managerdefinitions/include/AudioPort.h    |  6 ++++--
 .../common/managerdefinitions/include/AudioProfile.h |  3 ++-
 .../common/managerdefinitions/include/IOProfile.h    |  3 ++-
 .../common/managerdefinitions/src/AudioProfile.cpp   |  6 +++++-
 .../common/managerdefinitions/src/IOProfile.cpp      |  5 +++--
 .../managerdefault/AudioPolicyManager.cpp            | 20 +++++++++++++++++++-
 6 files changed, 35 insertions(+), 8 deletions(-)

diff --git a/services/audiopolicy/common/managerdefinitions/include/AudioPort.h b/services/audiopolicy/common/managerdefinitions/include/AudioPort.h
index 211ec98..50428d6 100644
--- a/services/audiopolicy/common/managerdefinitions/include/AudioPort.h
+++ b/services/audiopolicy/common/managerdefinitions/include/AudioPort.h
@@ -94,9 +94,11 @@ public:
     // parameters are input|output, returned value is the best match.
     status_t checkCompatibleAudioProfile(uint32_t &samplingRate,
                                          audio_channel_mask_t &channelMask,
-                                         audio_format_t &format) const
+                                         audio_format_t &format,
+                                         bool checkExactFormat) const
     {
-        return mProfiles.checkCompatibleProfile(samplingRate, channelMask, format, mType, mRole);
+        return mProfiles.checkCompatibleProfile(samplingRate, channelMask, format, mType,
+                                                  mRole, checkExactFormat);
     }
 
     void clearAudioProfiles() { return mProfiles.clearProfiles(); }
diff --git a/services/audiopolicy/common/managerdefinitions/include/AudioProfile.h b/services/audiopolicy/common/managerdefinitions/include/AudioProfile.h
index 404e27d..ef3a4de 100644
--- a/services/audiopolicy/common/managerdefinitions/include/AudioProfile.h
+++ b/services/audiopolicy/common/managerdefinitions/include/AudioProfile.h
@@ -200,7 +200,8 @@ public:
     status_t checkCompatibleProfile(uint32_t &samplingRate, audio_channel_mask_t &channelMask,
                                     audio_format_t &format,
                                     audio_port_type_t portType,
-                                    audio_port_role_t portRole) const;
+                                    audio_port_role_t portRole,
+                                    bool checkExactFormat = false) const;
 
     FormatVector getSupportedFormats() const
     {
diff --git a/services/audiopolicy/common/managerdefinitions/include/IOProfile.h b/services/audiopolicy/common/managerdefinitions/include/IOProfile.h
index dd20e93..e7f0f32 100644
--- a/services/audiopolicy/common/managerdefinitions/include/IOProfile.h
+++ b/services/audiopolicy/common/managerdefinitions/include/IOProfile.h
@@ -51,7 +51,8 @@ public:
                              audio_format_t *updatedFormat,
                              audio_channel_mask_t channelMask,
                              audio_channel_mask_t *updatedChannelMask,
-                             uint32_t flags) const;
+                             uint32_t flags,
+                             bool checkExactFormatMatch = false) const;
 
     void dump(int fd);
     void log();
diff --git a/services/audiopolicy/common/managerdefinitions/src/AudioProfile.cpp b/services/audiopolicy/common/managerdefinitions/src/AudioProfile.cpp
index 98f7a94..43671a3 100644
--- a/services/audiopolicy/common/managerdefinitions/src/AudioProfile.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/AudioProfile.cpp
@@ -246,7 +246,8 @@ status_t AudioProfileVector::checkCompatibleProfile(uint32_t &samplingRate,
                                                     audio_channel_mask_t &channelMask,
                                                     audio_format_t &format,
                                                     audio_port_type_t portType,
-                                                    audio_port_role_t portRole) const
+                                                    audio_port_role_t portRole,
+                                                    bool checkExactFormat) const
 {
     if (isEmpty()) {
         return NO_ERROR;
@@ -268,6 +269,9 @@ status_t AudioProfileVector::checkCompatibleProfile(uint32_t &samplingRate,
             // rate and channels as well
             audio_channel_mask_t updatedChannels;
             uint32_t updatedRate;
+
+            if ((checkExactFormat) && (formatToCompare != format))
+                continue;
             if (profile->checkCompatibleChannelMask(channelMask, updatedChannels,
                                                     portType, portRole) == NO_ERROR &&
                     profile->checkCompatibleSamplingRate(samplingRate, updatedRate) == NO_ERROR) {
diff --git a/services/audiopolicy/common/managerdefinitions/src/IOProfile.cpp b/services/audiopolicy/common/managerdefinitions/src/IOProfile.cpp
index abf2dd4..3a023d9 100644
--- a/services/audiopolicy/common/managerdefinitions/src/IOProfile.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/IOProfile.cpp
@@ -35,7 +35,8 @@ bool IOProfile::isCompatibleProfile(audio_devices_t device,
                                     audio_format_t *updatedFormat,
                                     audio_channel_mask_t channelMask,
                                     audio_channel_mask_t *updatedChannelMask,
-                                    uint32_t flags) const
+                                    uint32_t flags,
+                                    bool checkExactFormat) const
 {
     const bool isPlaybackThread =
             getType() == AUDIO_PORT_TYPE_MIX && getRole() == AUDIO_PORT_ROLE_SOURCE;
@@ -67,7 +68,7 @@ bool IOProfile::isCompatibleProfile(audio_devices_t device,
     if (isRecordThread)
     {
         if (checkCompatibleAudioProfile(
-                myUpdatedSamplingRate, myUpdatedChannelMask, myUpdatedFormat) != NO_ERROR) {
+                myUpdatedSamplingRate, myUpdatedChannelMask, myUpdatedFormat, checkExactFormat) != NO_ERROR) {
             return false;
         }
     } else {
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index f9ee44e..1e5cbbe 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -5011,7 +5011,25 @@ sp<IOProfile> AudioPolicyManager::getInputProfile(audio_devices_t device,
                                              &format /*updatedFormat*/,
                                              channelMask,
                                              &channelMask /*updatedChannelMask*/,
-                                             (audio_output_flags_t) flags)) {
+                                             (audio_output_flags_t) flags,
+                                             true)) {
+
+                return profile;
+            }
+        }
+
+        for (size_t j = 0; j < mHwModules[i]->mInputProfiles.size(); j++)
+        {
+            sp<IOProfile> profile = mHwModules[i]->mInputProfiles[j];
+            // profile->log();
+            if (profile->isCompatibleProfile(device, address, samplingRate,
+                                             &samplingRate /*updatedSamplingRate*/,
+                                             format,
+                                             &format /*updatedFormat*/,
+                                             channelMask,
+                                             &channelMask /*updatedChannelMask*/,
+                                             (audio_output_flags_t) flags,
+                                              false)) {
 
                 return profile;
             }
-- 
2.7.4


From ef57a1d5f8691bcc9c3adf78b87f14c8ec1e731d Mon Sep 17 00:00:00 2001
From: Satya Krishna Pindiproli <satyak@codeaurora.org>
Date: Thu, 20 Aug 2015 18:24:16 +0530
Subject: [PATCH 26/39] audiopolicy: port existing fixes to AudioPolicyManager

This is a squashed commit of the following fixes in
AudioPolicyManager. Only some parts of the fixes have been
ported as the custom audio policy has the other required
changes.

audiopolicy: support extended feature in audiopolicymanager
Change-Id: I1925339b591cd29f11a71c287a2e53c0627e9e62

audiopolicy: additional change for extended feature
Change-Id: I9bad6a294ddd7aee72f6f6a314666b892b730c8e

audiopolicy: Add voip flag to output flag list
Change-Id: Ifccb78a7b8579da0a65eb3ea7347756c664246a8

audiopolicy: fix to play 6.1 channel ALAC clips
Change-Id: I6b820776c0dc6e68a402886f0931439edab24a8b

audiopolicy: Add audio proxy device in audio policy
Change-Id: Idf3856a373eb7a05362f19d6cb117e9d4fb757ef

Conflicts:
        services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp

Change-Id: I7738d4b0ac11ee6d93bfd67e2553eae8518ff719
---
 .../audiopolicy/common/managerdefinitions/Android.mk |  6 ++++++
 .../common/managerdefinitions/src/TypeConverter.cpp  |  4 ++++
 services/audiopolicy/enginedefault/Android.mk        |  6 ++++++
 services/audiopolicy/enginedefault/src/Engine.cpp    | 20 ++++++++++++++++++--
 .../managerdefault/AudioPolicyManager.cpp            |  5 +++--
 5 files changed, 37 insertions(+), 4 deletions(-)

diff --git a/services/audiopolicy/common/managerdefinitions/Android.mk b/services/audiopolicy/common/managerdefinitions/Android.mk
index 1f2b14f..3506e50 100644
--- a/services/audiopolicy/common/managerdefinitions/Android.mk
+++ b/services/audiopolicy/common/managerdefinitions/Android.mk
@@ -60,6 +60,12 @@ LOCAL_SRC_FILES += \
 
 endif #ifeq ($(USE_XML_AUDIO_POLICY_CONF), 1)
 
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_PROXY_DEVICE)),true)
+LOCAL_CFLAGS += -DAUDIO_EXTN_AFE_PROXY_ENABLED
+endif
+endif
+
 LOCAL_EXPORT_C_INCLUDE_DIRS := \
     $(LOCAL_PATH)/include
 
diff --git a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
index 2e29f18..d68449a 100644
--- a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
@@ -52,6 +52,9 @@ const DeviceConverter::Table DeviceConverter::mTable[] = {
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_IP),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_BUS),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_STUB),
+#ifdef AUDIO_EXTN_AFE_PROXY_ENABLED
+        MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_OUT_PROXY),
+#endif
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_IN_AMBIENT),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_IN_BUILTIN_MIC),
         MAKE_STRING_FROM_ENUM(AUDIO_DEVICE_IN_BLUETOOTH_SCO_HEADSET),
@@ -96,6 +99,7 @@ const OutputFlagConverter::Table OutputFlagConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_TTS),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_RAW),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_SYNC),
+    MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_VOIP_RX),
 };
 template<>
 const size_t OutputFlagConverter::mSize = sizeof(OutputFlagConverter::mTable) /
diff --git a/services/audiopolicy/enginedefault/Android.mk b/services/audiopolicy/enginedefault/Android.mk
index 85d1822..45788b4 100755
--- a/services/audiopolicy/enginedefault/Android.mk
+++ b/services/audiopolicy/enginedefault/Android.mk
@@ -31,6 +31,12 @@ LOCAL_C_INCLUDES := \
 
 LOCAL_MULTILIB := $(AUDIOSERVER_MULTILIB)
 
+ifeq ($(call is-vendor-board-platform,QCOM),true)
+ifeq ($(strip $(AUDIO_FEATURE_ENABLED_PROXY_DEVICE)),true)
+LOCAL_CFLAGS += -DAUDIO_EXTN_AFE_PROXY_ENABLED
+endif
+endif
+
 LOCAL_MODULE := libaudiopolicyenginedefault
 LOCAL_MODULE_TAGS := optional
 
diff --git a/services/audiopolicy/enginedefault/src/Engine.cpp b/services/audiopolicy/enginedefault/src/Engine.cpp
index d31429c..33c01d7 100755
--- a/services/audiopolicy/enginedefault/src/Engine.cpp
+++ b/services/audiopolicy/enginedefault/src/Engine.cpp
@@ -453,6 +453,13 @@ audio_devices_t Engine::getDeviceForStrategyInt(routing_strategy strategy,
     case STRATEGY_REROUTING:
     case STRATEGY_MEDIA: {
         uint32_t device2 = AUDIO_DEVICE_NONE;
+
+        if (isInCall() && (device == AUDIO_DEVICE_NONE)) {
+            // when in call, get the device for Phone strategy
+            device = getDeviceForStrategy(STRATEGY_PHONE);
+            break;
+        }
+
         if (strategy != STRATEGY_SONIFICATION) {
             // no sonification on remote submix (e.g. WFD)
             if (availableOutputDevices.getDevice(AUDIO_DEVICE_OUT_REMOTE_SUBMIX,
@@ -498,14 +505,23 @@ audio_devices_t Engine::getDeviceForStrategyInt(routing_strategy strategy,
         if (device2 == AUDIO_DEVICE_NONE) {
             device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_DGTL_DOCK_HEADSET;
         }
-        if ((device2 == AUDIO_DEVICE_NONE) && (strategy != STRATEGY_SONIFICATION)) {
+        if ((strategy != STRATEGY_SONIFICATION) && (device == AUDIO_DEVICE_NONE)
+            && (device2 == AUDIO_DEVICE_NONE)) {
             // no sonification on aux digital (e.g. HDMI)
             device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_AUX_DIGITAL;
         }
         if ((device2 == AUDIO_DEVICE_NONE) &&
-                (mForceUse[AUDIO_POLICY_FORCE_FOR_DOCK] == AUDIO_POLICY_FORCE_ANALOG_DOCK)) {
+                (mForceUse[AUDIO_POLICY_FORCE_FOR_DOCK] == AUDIO_POLICY_FORCE_ANALOG_DOCK)
+                && (strategy != STRATEGY_SONIFICATION)) {
             device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_ANLG_DOCK_HEADSET;
         }
+#ifdef AUDIO_EXTN_AFE_PROXY_ENABLED
+        if ((strategy != STRATEGY_SONIFICATION) && (device == AUDIO_DEVICE_NONE)
+            && (device2 == AUDIO_DEVICE_NONE)) {
+            // no sonification on WFD sink
+            device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_PROXY;
+        }
+#endif
         if (device2 == AUDIO_DEVICE_NONE) {
             device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_SPEAKER;
         }
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index 1e5cbbe..be76e9d 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -672,7 +672,8 @@ sp<IOProfile> AudioPolicyManager::getProfileForDirectOutput(
     // only retain flags that will drive the direct output profile selection
     // if explicitly requested
     static const uint32_t kRelevantFlags =
-            (AUDIO_OUTPUT_FLAG_HW_AV_SYNC | AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD);
+            (AUDIO_OUTPUT_FLAG_HW_AV_SYNC | AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD |
+               AUDIO_OUTPUT_FLAG_VOIP_RX);
     flags =
         (audio_output_flags_t)((flags & kRelevantFlags) | AUDIO_OUTPUT_FLAG_DIRECT);
 
@@ -4277,7 +4278,7 @@ void AudioPolicyManager::checkOutputForStrategy(routing_strategy strategy)
 {
     audio_devices_t oldDevice = getDeviceForStrategy(strategy, true /*fromCache*/);
     audio_devices_t newDevice = getDeviceForStrategy(strategy, false /*fromCache*/);
-    SortedVector<audio_io_handle_t> srcOutputs = getOutputsForDevice(oldDevice, mPreviousOutputs);
+    SortedVector<audio_io_handle_t> srcOutputs = getOutputsForDevice(oldDevice, mOutputs);
     SortedVector<audio_io_handle_t> dstOutputs = getOutputsForDevice(newDevice, mOutputs);
 
     // also take into account external policy-related changes: add all outputs which are
-- 
2.7.4


From 243b1779b9e4c102e6e48cd0f8a8a504fd17fe8d Mon Sep 17 00:00:00 2001
From: Naresh Tanniru <ntanniru@codeaurora.org>
Date: Tue, 1 Dec 2015 15:37:52 +0530
Subject: [PATCH 27/39] audiopolicy: Check if A2DP playback happens via primary
 output

Audio policy implementation assumes A2DP playback to happen
via HW module other than the primary HAL.This need not be true
always, since primary audio HAL can support A2DP playback too.

Add an api to check if A2DP playback is supported via primary HAL,
and if it is supported avoid suspendOutput.

Change-Id: I13bf8137ab64e257d84791dd77ee746dec39dec4
---
 .../managerdefinitions/include/AudioOutputDescriptor.h  |  5 +++++
 .../managerdefinitions/src/AudioOutputDescriptor.cpp    | 17 +++++++++++++++++
 services/audiopolicy/enginedefault/src/Engine.cpp       |  6 +++---
 .../audiopolicy/managerdefault/AudioPolicyManager.cpp   |  2 +-
 4 files changed, 26 insertions(+), 4 deletions(-)

diff --git a/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h b/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h
index 3af6693..bff28c0 100644
--- a/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h
+++ b/services/audiopolicy/common/managerdefinitions/include/AudioOutputDescriptor.h
@@ -176,6 +176,11 @@ public:
      */
     audio_io_handle_t getA2dpOutput() const;
 
+    /**
+     * return true if primary HAL supports A2DP Playback
+     */
+    bool isA2dpOnPrimary() const;
+
     sp<SwAudioOutputDescriptor> getOutputFromId(audio_port_handle_t id) const;
 
     sp<SwAudioOutputDescriptor> getPrimaryOutput() const;
diff --git a/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp b/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
index 6b2bbab..de889e5 100644
--- a/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/AudioOutputDescriptor.cpp
@@ -485,6 +485,23 @@ audio_io_handle_t SwAudioOutputCollection::getA2dpOutput() const
     return 0;
 }
 
+bool SwAudioOutputCollection::isA2dpOnPrimary() const
+{
+    sp<SwAudioOutputDescriptor> primaryOutput = getPrimaryOutput();
+
+    if ((primaryOutput != NULL) && (primaryOutput->mProfile != NULL)
+        && (primaryOutput->mProfile->mModule != NULL)) {
+        Vector <sp<IOProfile>> primaryOutputProfiles =
+                               primaryOutput->mProfile->mModule->mOutputProfiles;
+        for (size_t j = 0; j < primaryOutputProfiles.size(); j++) {
+            if (primaryOutputProfiles[j]->supportDevice(AUDIO_DEVICE_OUT_ALL_A2DP)) {
+                return true;
+            }
+        }
+    }
+    return false;
+}
+
 sp<SwAudioOutputDescriptor> SwAudioOutputCollection::getPrimaryOutput() const
 {
     for (size_t i = 0; i < size(); i++) {
diff --git a/services/audiopolicy/enginedefault/src/Engine.cpp b/services/audiopolicy/enginedefault/src/Engine.cpp
index 33c01d7..12b1824 100755
--- a/services/audiopolicy/enginedefault/src/Engine.cpp
+++ b/services/audiopolicy/enginedefault/src/Engine.cpp
@@ -344,7 +344,7 @@ audio_devices_t Engine::getDeviceForStrategyInt(routing_strategy strategy,
             // when not in a phone call, phone strategy should route STREAM_VOICE_CALL to A2DP
             if (!isInCall() &&
                     (mForceUse[AUDIO_POLICY_FORCE_FOR_MEDIA] != AUDIO_POLICY_FORCE_NO_BT_A2DP) &&
-                    (outputs.getA2dpOutput() != 0)) {
+                    (outputs.isA2dpOnPrimary() || (outputs.getA2dpOutput() != 0))) {
                 device = availableOutputDevicesType & AUDIO_DEVICE_OUT_BLUETOOTH_A2DP;
                 if (device) break;
                 device = availableOutputDevicesType & AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
@@ -376,7 +376,7 @@ audio_devices_t Engine::getDeviceForStrategyInt(routing_strategy strategy,
             // A2DP speaker when forcing to speaker output
             if (!isInCall() &&
                     (mForceUse[AUDIO_POLICY_FORCE_FOR_MEDIA] != AUDIO_POLICY_FORCE_NO_BT_A2DP) &&
-                    (outputs.getA2dpOutput() != 0)) {
+                    (outputs.isA2dpOnPrimary() || (outputs.getA2dpOutput() != 0))) {
                 device = availableOutputDevicesType & AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_SPEAKER;
                 if (device) break;
             }
@@ -474,7 +474,7 @@ audio_devices_t Engine::getDeviceForStrategyInt(routing_strategy strategy,
         }
         if ((device2 == AUDIO_DEVICE_NONE) &&
                 (mForceUse[AUDIO_POLICY_FORCE_FOR_MEDIA] != AUDIO_POLICY_FORCE_NO_BT_A2DP) &&
-                (outputs.getA2dpOutput() != 0)) {
+                (outputs.isA2dpOnPrimary() || (outputs.getA2dpOutput() != 0))) {
             device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_BLUETOOTH_A2DP;
             if (device2 == AUDIO_DEVICE_NONE) {
                 device2 = availableOutputDevicesType & AUDIO_DEVICE_OUT_BLUETOOTH_A2DP_HEADPHONES;
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index be76e9d..f2eb931 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -4371,7 +4371,7 @@ void AudioPolicyManager::checkOutputForAllStrategies()
 void AudioPolicyManager::checkA2dpSuspend()
 {
     audio_io_handle_t a2dpOutput = mOutputs.getA2dpOutput();
-    if (a2dpOutput == 0) {
+    if (a2dpOutput == 0 || mOutputs.isA2dpOnPrimary()) {
         mA2dpSuspended = false;
         return;
     }
-- 
2.7.4


From d01c5f09a2f9e745bcb0f7df973a40c0a1ba7f38 Mon Sep 17 00:00:00 2001
From: Shuzhen Wang <shuzhenw@codeaurora.org>
Date: Wed, 8 Jul 2015 15:47:46 -0700
Subject: [PATCH 28/39] Camera: Add extensions to CameraClient

This change includes the following gerrits:

  # This is a combination of 4 commits.
  # The first commit's message is:
  Camera: Enable Histogram feature.
  Link the histogram enable/disable commands from
  application to the HAL layer.
  Change-Id: I510c4e1798285ed1315bfb0d234fa76090659ba2

  # This is the 2nd commit message:
  Camera: Add support for ZSL burst mode.
  Added ability to set number of snapshots in burst mode.
  Change-Id: Ie0e7c8c0117b7adc985cfc92df79747ee6a5ea51

  # This is the 3rd commit message:
  CameraService: Adds support for longshot mode
  - This change introduces additional functionality inside
    CameraClient for supporting continuous compressed data
    callbacks. This is needed for 'Burst/Long shot' mode
    where we could have indefinite number of callbacks after
    capture is triggered.
  (cherrypicked from commit e4f502aa7cbe8875e8a1589024cdcf227c228a2b)
  Change-Id: Ia18ca9bdda7736c679db557e510870115089537a

  # This is the 4th commit message:
  CameraClient: Enables meta data notifications.
  Adds the needed functionality for enabling/disabling
  metadata messages depending on the camera client
  commands.
  Change-Id: I39d632b4742e83df5db5f86b12742aefc2480dfc
  Cherrypicked from 25bd97f5ec30e7942c3b1fdc96115da6028736f0

Change-Id: Ie930d20c962593e40a0767f9cf7d4385df8e2561
---
 .../camera/libcameraservice/api1/CameraClient.cpp  | 33 ++++++++++++++++++++--
 .../camera/libcameraservice/api1/CameraClient.h    |  3 ++
 2 files changed, 34 insertions(+), 2 deletions(-)

diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 266fb03..308c516 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -57,6 +57,9 @@ CameraClient::CameraClient(const sp<CameraService>& cameraService,
     mOrientation = getOrientation(0, mCameraFacing == CAMERA_FACING_FRONT);
     mLegacyMode = legacyMode;
     mPlayShutterSound = true;
+
+    mLongshotEnabled = false;
+    mBurstCnt = 0;
     LOG1("CameraClient::CameraClient X (pid %d, id %d)", callingPid, cameraId);
 }
 
@@ -603,6 +606,10 @@ status_t CameraClient::takePicture(int msgType) {
                            CAMERA_MSG_COMPRESSED_IMAGE);
 
     enableMsgType(picMsgType);
+    mBurstCnt = mHardware->getParameters().getInt("num-snaps-per-shutter");
+    if(mBurstCnt <= 0)
+        mBurstCnt = 1;
+    LOG1("mBurstCnt = %d", mBurstCnt);
 
     return mHardware->takePicture();
 }
@@ -704,6 +711,20 @@ status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
     } else if (cmd == CAMERA_CMD_PING) {
         // If mHardware is 0, checkPidAndHardware will return error.
         return OK;
+    } else if (cmd == CAMERA_CMD_HISTOGRAM_ON) {
+        enableMsgType(CAMERA_MSG_STATS_DATA);
+    } else if (cmd == CAMERA_CMD_HISTOGRAM_OFF) {
+        disableMsgType(CAMERA_MSG_STATS_DATA);
+    } else if (cmd == CAMERA_CMD_METADATA_ON) {
+        enableMsgType(CAMERA_MSG_META_DATA);
+    } else if (cmd == CAMERA_CMD_METADATA_OFF) {
+        disableMsgType(CAMERA_MSG_META_DATA);
+    } else if ( cmd == CAMERA_CMD_LONGSHOT_ON ) {
+        mLongshotEnabled = true;
+    } else if ( cmd == CAMERA_CMD_LONGSHOT_OFF ) {
+        mLongshotEnabled = false;
+        disableMsgType(CAMERA_MSG_SHUTTER);
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
     }
 
     return mHardware->sendCommand(cmd, arg1, arg2);
@@ -846,7 +867,9 @@ void CameraClient::handleShutter(void) {
         c->notifyCallback(CAMERA_MSG_SHUTTER, 0, 0);
         if (!lockIfMessageWanted(CAMERA_MSG_SHUTTER)) return;
     }
-    disableMsgType(CAMERA_MSG_SHUTTER);
+    if ( !mLongshotEnabled ) {
+        disableMsgType(CAMERA_MSG_SHUTTER);
+    }
 
     // Shutters only happen in response to takePicture, so mark device as
     // idle now, until preview is restarted
@@ -931,7 +954,13 @@ void CameraClient::handleRawPicture(const sp<IMemory>& mem) {
 
 // picture callback - compressed picture ready
 void CameraClient::handleCompressedPicture(const sp<IMemory>& mem) {
-    disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+    if (mBurstCnt)
+        mBurstCnt--;
+
+    if (!mBurstCnt && !mLongshotEnabled) {
+        LOG1("handleCompressedPicture mBurstCnt = %d", mBurstCnt);
+        disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+    }
 
     sp<hardware::ICameraClient> c = mRemoteCallback;
     mLock.unlock();
diff --git a/services/camera/libcameraservice/api1/CameraClient.h b/services/camera/libcameraservice/api1/CameraClient.h
index 4f46fc4..55f64aa 100644
--- a/services/camera/libcameraservice/api1/CameraClient.h
+++ b/services/camera/libcameraservice/api1/CameraClient.h
@@ -172,6 +172,9 @@ private:
     // This function keeps trying to grab mLock, or give up if the message
     // is found to be disabled. It returns true if mLock is grabbed.
     bool                    lockIfMessageWanted(int32_t msgType);
+
+    bool                 mLongshotEnabled;
+    int                  mBurstCnt;
 };
 
 }
-- 
2.7.4


From 9e853edf67caa56371b877d5b3806618a0f9897a Mon Sep 17 00:00:00 2001
From: Sai Kumar Sanagavarapu <ssanagav@codeaurora.org>
Date: Thu, 21 Jul 2016 13:42:52 +0530
Subject: [PATCH 29/39] camera: Fix memory leak in stop recording usecase.

Issue:
1. In CameraSource, if both recording proxy and local camera
   instances are null, the frames which are supposed to be
   returned back to Camera, will never be returned, causing
   memory leak.
2. If a frame is returned from CameraSource after stop recording
   is issued, Camera HAL cannot handle it because by that time
   it will be previewing state.

Fix:
1. Since camera handles are not available, close the native handle
   in CameraSource itself.
2. Close the duped native handles in cameraservice instead of
   delegating the responsibility to Camera HAL.

Bug: 30299751
CRs-Fixed: 1040448
Change-Id: I45a351d0813dff15034fa25b79987ceab07232bb
---
 services/camera/libcameraservice/api1/CameraClient.cpp | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 308c516..c79d531 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -523,6 +523,9 @@ void CameraClient::releaseRecordingFrameHandle(native_handle_t *handle) {
     metadata->pHandle = handle;
 
     mHardware->releaseRecordingFrame(dataPtr);
+
+    native_handle_close(handle);
+    native_handle_delete(handle);
 }
 
 status_t CameraClient::setVideoBufferMode(int32_t videoBufferMode) {
-- 
2.7.4


From 0bb306f88cb3a1795199de471d35fce7a3136aeb Mon Sep 17 00:00:00 2001
From: Guruprasad Gaonkar <ggaonk@codeaurora.org>
Date: Wed, 12 Oct 2016 16:20:20 -0700
Subject: [PATCH 30/39] CameraService: Allow HAL to handle video buffer duped
 FD's.

Issue:
Android camera framework expects camera HAL to release
duped FD's in case of video buffer.

Change:
Reverting our previous proposal to handle video FD's in
android framework.

@Buganizer: 30299751

Change-Id: I2b7fb7ddaff59c986a3287391725e1ca1a6f5de0
---
 services/camera/libcameraservice/api1/CameraClient.cpp | 3 ---
 1 file changed, 3 deletions(-)

diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index c79d531..308c516 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -523,9 +523,6 @@ void CameraClient::releaseRecordingFrameHandle(native_handle_t *handle) {
     metadata->pHandle = handle;
 
     mHardware->releaseRecordingFrame(dataPtr);
-
-    native_handle_close(handle);
-    native_handle_delete(handle);
 }
 
 status_t CameraClient::setVideoBufferMode(int32_t videoBufferMode) {
-- 
2.7.4


From c41e56a73ac534ad52b30df81f46ab6e69fcf723 Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Sun, 9 Oct 2016 20:12:29 +0200
Subject: [PATCH 31/39] av: add needed QCOM_HARDWARE

---
 camera/ICameraClient.cpp                                       |  8 ++++++++
 media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp      |  4 ++++
 services/audioflinger/AudioFlinger.cpp                         |  2 ++
 .../common/managerdefinitions/src/TypeConverter.cpp            |  9 +++++++++
 services/audiopolicy/managerdefault/AudioPolicyManager.cpp     | 10 ++++++++--
 services/camera/libcameraservice/api1/CameraClient.cpp         |  2 ++
 6 files changed, 33 insertions(+), 2 deletions(-)

diff --git a/camera/ICameraClient.cpp b/camera/ICameraClient.cpp
index 8a7430f..b57458a 100644
--- a/camera/ICameraClient.cpp
+++ b/camera/ICameraClient.cpp
@@ -50,12 +50,16 @@ public:
         data.writeInterfaceToken(ICameraClient::getInterfaceDescriptor());
         data.writeInt32(msgType);
         data.writeInt32(ext1);
+#ifdef QCOM_HARDWARE
         if ((msgType == CAMERA_MSG_PREVIEW_FRAME) && (ext1 == CAMERA_FRAME_DATA_FD)) {
             ALOGD("notifyCallback: CAMERA_MSG_PREVIEW_FRAME fd = %d", ext2);
             data.writeFileDescriptor(ext2);
         } else {
             data.writeInt32(ext2);
         }
+#else
+        data.writeInt32(ext2);
+#endif
         remote()->transact(NOTIFY_CALLBACK, data, &reply, IBinder::FLAG_ONEWAY);
     }
 
@@ -111,6 +115,7 @@ status_t BnCameraClient::onTransact(
             CHECK_INTERFACE(ICameraClient, data, reply);
             int32_t msgType = data.readInt32();
             int32_t ext1    = data.readInt32();
+#ifdef QCOM_HARDWARE
             int32_t ext2    = 0;
             if ((msgType == CAMERA_MSG_PREVIEW_FRAME) && (ext1 == CAMERA_FRAME_DATA_FD)) {
                 ext2 = data.readFileDescriptor();
@@ -118,6 +123,9 @@ status_t BnCameraClient::onTransact(
             } else {
                 ext2 = data.readInt32();
             }
+#else
+            int32_t ext2 = data.readInt32();
+#endif
             notifyCallback(msgType, ext1, ext2);
             return NO_ERROR;
         } break;
diff --git a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
index 648b7ce..36a7da4 100644
--- a/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
+++ b/media/libmediaplayerservice/nuplayer/NuPlayerRenderer.cpp
@@ -1853,10 +1853,12 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
                 }
             }
 
+#ifdef QCOM_HARDWARE
             int32_t offloadBufferSize =
                                     AVUtils::get()->getAudioMaxInputBufferSize(
                                                    audioFormat,
                                                    format);
+#endif
             audio_offload_info_t offloadInfo = AUDIO_INFO_INITIALIZER;
 
             offloadInfo.duration_us = -1;
@@ -1869,8 +1871,10 @@ status_t NuPlayer::Renderer::onOpenAudioSink(
             offloadInfo.bit_rate = avgBitRate;
             offloadInfo.has_video = hasVideo;
             offloadInfo.is_streaming = isStreaming;
+#ifdef QCOM_HARDWARE
             offloadInfo.bit_width = bitWidth;
             offloadInfo.offload_buffer_size = offloadBufferSize;
+#endif
 
             if (memcmp(&mCurrentOffloadInfo, &offloadInfo, sizeof(offloadInfo)) == 0) {
                 ALOGV("openAudioSink: no change in offload mode");
diff --git a/services/audioflinger/AudioFlinger.cpp b/services/audioflinger/AudioFlinger.cpp
index f2adb5b..5d0ac3f 100644
--- a/services/audioflinger/AudioFlinger.cpp
+++ b/services/audioflinger/AudioFlinger.cpp
@@ -1932,10 +1932,12 @@ sp<AudioFlinger::PlaybackThread> AudioFlinger::openOutput_l(audio_module_handle_
                 || !isValidPcmSinkChannelMask(config->channel_mask)) {
             thread = new DirectOutputThread(this, outputStream, *output, devices, mSystemReady);
             ALOGV("openOutput_l() created direct output: ID %d thread %p ", *output, thread);
+#ifdef QCOM_HARDWARE
             //Check if this is DirectPCM, if so
             if (flags & AUDIO_OUTPUT_FLAG_DIRECT_PCM) {
                 thread->mIsDirectPcm = true;
             }
+#endif
         } else {
             thread = new MixerThread(this, outputStream, *output, devices, mSystemReady);
             ALOGV("openOutput_l() created mixer output: ID %d thread %p", *output, thread);
diff --git a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
index d68449a..6c391bd 100644
--- a/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
+++ b/services/audiopolicy/common/managerdefinitions/src/TypeConverter.cpp
@@ -89,7 +89,9 @@ const size_t DeviceConverter::mSize = sizeof(DeviceConverter::mTable) /
 template <>
 const OutputFlagConverter::Table OutputFlagConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_DIRECT),
+#ifdef QCOM_HARDWARE
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_DIRECT_PCM),
+#endif
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_PRIMARY),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_FAST),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_DEEP_BUFFER),
@@ -99,7 +101,9 @@ const OutputFlagConverter::Table OutputFlagConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_TTS),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_RAW),
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_SYNC),
+#ifdef QCOM_HARDWARE
     MAKE_STRING_FROM_ENUM(AUDIO_OUTPUT_FLAG_VOIP_RX),
+#endif
 };
 template<>
 const size_t OutputFlagConverter::mSize = sizeof(OutputFlagConverter::mTable) /
@@ -179,10 +183,12 @@ const OutputChannelConverter::Table OutputChannelConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_QUAD),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_5POINT1),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_7POINT1),
+#ifdef QCOM_HARDWARE
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_2POINT1),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_SURROUND),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_PENTA),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_OUT_6POINT1),
+#endif
 };
 template<>
 const size_t OutputChannelConverter::mSize = sizeof(OutputChannelConverter::mTable) /
@@ -194,6 +200,9 @@ const InputChannelConverter::Table InputChannelConverter::mTable[] = {
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_IN_MONO),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_IN_STEREO),
     MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_IN_FRONT_BACK),
+#ifdef QCOM_HARDWARE
+    MAKE_STRING_FROM_ENUM(AUDIO_CHANNEL_IN_5POINT1),
+#endif
 };
 template<>
 const size_t InputChannelConverter::mSize = sizeof(InputChannelConverter::mTable) /
diff --git a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
index f2eb931..760621c 100644
--- a/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
+++ b/services/audiopolicy/managerdefault/AudioPolicyManager.cpp
@@ -672,8 +672,12 @@ sp<IOProfile> AudioPolicyManager::getProfileForDirectOutput(
     // only retain flags that will drive the direct output profile selection
     // if explicitly requested
     static const uint32_t kRelevantFlags =
-            (AUDIO_OUTPUT_FLAG_HW_AV_SYNC | AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD |
-               AUDIO_OUTPUT_FLAG_VOIP_RX);
+            (AUDIO_OUTPUT_FLAG_HW_AV_SYNC | AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD
+#ifdef QCOM_HARDWARE
+                | AUDIO_OUTPUT_FLAG_VOIP_RX);
+#else
+                );
+#endif
     flags =
         (audio_output_flags_t)((flags & kRelevantFlags) | AUDIO_OUTPUT_FLAG_DIRECT);
 
@@ -2071,9 +2075,11 @@ audio_io_handle_t AudioPolicyManager::selectOutputForEffects(
         if ((desc->mFlags & AUDIO_OUTPUT_FLAG_COMPRESS_OFFLOAD) != 0) {
             outputOffloaded = outputs[i];
         }
+#ifdef QCOM_HARDWARE
         if ((desc->mFlags & AUDIO_OUTPUT_FLAG_DIRECT_PCM) != 0) {
             outputDirectPcm = outputs[i];
         }
+#endif
         if ((desc->mFlags & AUDIO_OUTPUT_FLAG_DEEP_BUFFER) != 0) {
             outputDeepBuffer = outputs[i];
         }
diff --git a/services/camera/libcameraservice/api1/CameraClient.cpp b/services/camera/libcameraservice/api1/CameraClient.cpp
index 308c516..84e73b5 100644
--- a/services/camera/libcameraservice/api1/CameraClient.cpp
+++ b/services/camera/libcameraservice/api1/CameraClient.cpp
@@ -711,6 +711,7 @@ status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
     } else if (cmd == CAMERA_CMD_PING) {
         // If mHardware is 0, checkPidAndHardware will return error.
         return OK;
+#ifdef QCOM_HARDWARE
     } else if (cmd == CAMERA_CMD_HISTOGRAM_ON) {
         enableMsgType(CAMERA_MSG_STATS_DATA);
     } else if (cmd == CAMERA_CMD_HISTOGRAM_OFF) {
@@ -725,6 +726,7 @@ status_t CameraClient::sendCommand(int32_t cmd, int32_t arg1, int32_t arg2) {
         mLongshotEnabled = false;
         disableMsgType(CAMERA_MSG_SHUTTER);
         disableMsgType(CAMERA_MSG_COMPRESSED_IMAGE);
+#endif
     }
 
     return mHardware->sendCommand(cmd, arg1, arg2);
-- 
2.7.4


From 5d5095cb955db8b1efeeb777c6e699dcc862d945 Mon Sep 17 00:00:00 2001
From: Simon Shields <keepcalm444@gmail.com>
Date: Thu, 6 Oct 2016 20:25:32 +1100
Subject: [PATCH 32/39] camera/media: Support for legacy camera HALv1

Pre 7.0 camera HALv1 can not share its video buffers
across different processes, which requires us to
disable this security feature.

This change allows devices to re-integrate cameraserver
and mediaserver which is the first step to support older
prebuilt camera HALs. A follow-up change will add back
support for legacy buffer handling.

To enable:
TARGET_HAS_LEGACY_CAMERA_HAL1 := true
media.stagefright.legacyencoder=true
media.stagefright.less-secure=true

Change-Id: I4fcc8907ea235b7e83af26122b4da97ca5117816
---
 camera/cameraserver/Android.mk                     | 4 ++++
 media/mediaserver/Android.mk                       | 4 ++++
 media/mediaserver/main_mediaserver.cpp             | 6 ++++++
 services/camera/libcameraservice/Android.mk        | 4 ++++
 services/camera/libcameraservice/CameraService.cpp | 8 +++++++-
 5 files changed, 25 insertions(+), 1 deletion(-)

diff --git a/camera/cameraserver/Android.mk b/camera/cameraserver/Android.mk
index 7e36c5e..aca7a19 100644
--- a/camera/cameraserver/Android.mk
+++ b/camera/cameraserver/Android.mk
@@ -14,6 +14,9 @@
 
 LOCAL_PATH:= $(call my-dir)
 
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+$(warning Target has integrated cameraserver into mediaserver. This is weakening security measures introduced in 7.0)
+else
 include $(CLEAR_VARS)
 
 LOCAL_SRC_FILES:= \
@@ -34,3 +37,4 @@ LOCAL_CFLAGS += -Wall -Wextra -Werror -Wno-unused-parameter
 LOCAL_INIT_RC := cameraserver.rc
 
 include $(BUILD_EXECUTABLE)
+endif
diff --git a/media/mediaserver/Android.mk b/media/mediaserver/Android.mk
index 1738df8..c2b9c1f 100644
--- a/media/mediaserver/Android.mk
+++ b/media/mediaserver/Android.mk
@@ -42,4 +42,8 @@ LOCAL_INIT_RC := mediaserver.rc
 
 LOCAL_CFLAGS := -Werror -Wall
 
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+    LOCAL_CFLAGS += -DNO_CAMERA_SERVER
+endif
+
 include $(BUILD_EXECUTABLE)
diff --git a/media/mediaserver/main_mediaserver.cpp b/media/mediaserver/main_mediaserver.cpp
index ecddc48..0abe6ac 100644
--- a/media/mediaserver/main_mediaserver.cpp
+++ b/media/mediaserver/main_mediaserver.cpp
@@ -25,6 +25,9 @@
 #include "RegisterExtensions.h"
 
 // from LOCAL_C_INCLUDES
+#ifdef NO_CAMERA_SERVER
+#include "CameraService.h"
+#endif
 #include "IcuUtils.h"
 #include "MediaPlayerService.h"
 #include "ResourceManagerService.h"
@@ -41,6 +44,9 @@ int main(int argc __unused, char **argv __unused)
     InitializeIcuOrDie();
     MediaPlayerService::instantiate();
     ResourceManagerService::instantiate();
+#ifdef NO_CAMERA_SERVER
+    CameraService::instantiate();
+#endif
     registerExtensions();
     ProcessState::self()->startThreadPool();
     IPCThreadState::self()->joinThreadPool();
diff --git a/services/camera/libcameraservice/Android.mk b/services/camera/libcameraservice/Android.mk
index 8d7f71c..d98ad47 100644
--- a/services/camera/libcameraservice/Android.mk
+++ b/services/camera/libcameraservice/Android.mk
@@ -80,6 +80,10 @@ LOCAL_EXPORT_C_INCLUDE_DIRS := \
 
 LOCAL_CFLAGS += -Wall -Wextra -Werror
 
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+    LOCAL_CFLAGS += -DNO_CAMERA_SERVER
+endif
+
 LOCAL_MODULE:= libcameraservice
 
 include $(BUILD_SHARED_LIBRARY)
diff --git a/services/camera/libcameraservice/CameraService.cpp b/services/camera/libcameraservice/CameraService.cpp
index d0df6d1..f15d201 100644
--- a/services/camera/libcameraservice/CameraService.cpp
+++ b/services/camera/libcameraservice/CameraService.cpp
@@ -831,7 +831,11 @@ String8 CameraService::toString(std::set<userid_t> intSet) {
 Status CameraService::initializeShimMetadata(int cameraId) {
     int uid = getCallingUid();
 
+#ifdef NO_CAMERA_SERVER
+    String16 internalPackageName("media");
+#else
     String16 internalPackageName("cameraserver");
+#endif
     String8 id = String8::format("%d", cameraId);
     Status ret = Status::ok();
     sp<Client> tmp = nullptr;
@@ -912,8 +916,10 @@ Status CameraService::getLegacyParametersLazy(int cameraId,
 static bool isTrustedCallingUid(uid_t uid) {
     switch (uid) {
         case AID_MEDIA:        // mediaserver
-        case AID_CAMERASERVER: // cameraserver
         case AID_RADIO:        // telephony
+#ifndef NO_CAMERA_SERVER
+        case AID_CAMERASERVER: // cameraserver
+#endif
             return true;
         default:
             return false;
-- 
2.7.4


From 2ff6438b4f2fe2814b02839202da628bdb288243 Mon Sep 17 00:00:00 2001
From: LuK1337 <priv.luk@gmail.com>
Date: Fri, 11 Nov 2016 19:10:42 +0100
Subject: [PATCH 33/39] OMXNodeInstance: Fix legacy HAL1 after merge of
 android-7.0.0_r19

Change-Id: I53985a966b891b902437f71d4ebccbd68138329e
---
 media/libstagefright/omx/Android.mk          |  6 ++++++
 media/libstagefright/omx/OMXNodeInstance.cpp | 24 ++++++++++++++++++++++++
 2 files changed, 30 insertions(+)

diff --git a/media/libstagefright/omx/Android.mk b/media/libstagefright/omx/Android.mk
index caea7b6..1b0e996 100644
--- a/media/libstagefright/omx/Android.mk
+++ b/media/libstagefright/omx/Android.mk
@@ -50,6 +50,12 @@ LOCAL_CFLAGS += -DQTI_FLAC_DECODER
 endif
 endif
 
+ifneq ($(TARGET_USES_MEDIA_EXTENSIONS),true)
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+LOCAL_CFLAGS += -DCAMCORDER_GRALLOC_SOURCE
+endif
+endif
+
 LOCAL_MODULE:= libstagefright_omx
 LOCAL_CFLAGS += -Werror -Wall
 # DOLBY_START
diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 5f903a9..735c532 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -1286,7 +1286,11 @@ status_t OMXNodeInstance::allocateBufferWithBackup(
     }
 
     // metadata buffers are not connected cross process; only copy if not meta
+#ifdef CAMCORDER_GRALLOC_SOURCE
+    bool copy = true;
+#else
     bool copy = mMetadataType[portIndex] == kMetadataBufferTypeInvalid;
+#endif
 
     BufferMeta *buffer_meta = new BufferMeta(
             params, portIndex,
@@ -1404,10 +1408,30 @@ status_t OMXNodeInstance::emptyBuffer(
     BufferMeta *buffer_meta =
         static_cast<BufferMeta *>(header->pAppPrivate);
 
+#ifndef CAMCORDER_GRALLOC_SOURCE
     // set up proper filled length if component is configured for gralloc metadata mode
     // ignore rangeOffset in this case (as client may be assuming ANW meta buffers).
     if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource) {
         header->nFilledLen = rangeLength ? sizeof(VideoGrallocMetadata) : 0;
+#else
+    sp<ABuffer> backup = buffer_meta->getBuffer(header, true /* backup */, false /* limit */);
+    sp<ABuffer> codec = buffer_meta->getBuffer(header, false /* backup */, false /* limit */);
+
+    // convert incoming ANW meta buffers if component is configured for gralloc metadata mode
+    // ignore rangeOffset in this case
+    if (mMetadataType[kPortIndexInput] == kMetadataBufferTypeGrallocSource
+            && backup->capacity() >= sizeof(VideoNativeMetadata)
+            && codec->capacity() >= sizeof(VideoGrallocMetadata)
+            && ((VideoNativeMetadata *)backup->base())->eType
+                    == kMetadataBufferTypeANWBuffer) {
+        VideoNativeMetadata &backupMeta = *(VideoNativeMetadata *)backup->base();
+        VideoGrallocMetadata &codecMeta = *(VideoGrallocMetadata *)codec->base();
+        CLOG_BUFFER(emptyBuffer, "converting ANWB %p to handle %p",
+                backupMeta.pBuffer, backupMeta.pBuffer->handle);
+        codecMeta.pHandle = backupMeta.pBuffer != NULL ? backupMeta.pBuffer->handle : NULL;
+        codecMeta.eType = kMetadataBufferTypeGrallocSource;
+        header->nFilledLen = rangeLength ? sizeof(codecMeta) : 0;
+#endif
         header->nOffset = 0;
     } else {
         // rangeLength and rangeOffset must be a subset of the allocated data in the buffer.
-- 
2.7.4


From de591652f1407ff8c7fed607c4659ea3324e4d41 Mon Sep 17 00:00:00 2001
From: "Christopher N. Hesse" <raymanfx@gmail.com>
Date: Tue, 18 Oct 2016 20:56:33 +0200
Subject: [PATCH 34/39] libstagefright: Support for legacy camera/encoder
 buffers

Since Android 7.0, the default way of passing buffers
between camera HAL, encoder and framework is via
Android Native Window (ANW) buffers.

Pre 7.0 devices did this using buffer_handle_t buffers
allocated by gralloc HAL.
Since many devices do not have the source code for their
camera HALs or the encoder libraries available, introduce
this hack.

Change-Id: I202051ab5d7273a33be0aa32b0bfdbbb1f53693f
---
 media/libstagefright/ACodec.cpp             | 34 ++++++++++++++++++++++++++
 media/libstagefright/Android.mk             |  4 ++++
 media/libstagefright/CameraSource.cpp       |  4 ++++
 media/libstagefright/SurfaceMediaSource.cpp | 37 +++++++++++++++++++++++++++++
 4 files changed, 79 insertions(+)

diff --git a/media/libstagefright/ACodec.cpp b/media/libstagefright/ACodec.cpp
index ee25ef0..7bee8f2 100644
--- a/media/libstagefright/ACodec.cpp
+++ b/media/libstagefright/ACodec.cpp
@@ -832,13 +832,22 @@ status_t ACodec::allocateBuffersOnPort(OMX_U32 portIndex) {
             } else if (type == kMetadataBufferTypeNativeHandleSource) {
                 bufSize = sizeof(VideoNativeHandleMetadata);
             }
+#ifdef CAMCORDER_GRALLOC_SOURCE
+            else if (type == kMetadataBufferTypeGrallocSource) {
+                bufSize = sizeof(VideoGrallocMetadata);
+            }
+#endif
 
             // If using gralloc or native source input metadata buffers, allocate largest
             // metadata size as we prefer to generate native source metadata, but component
             // may require gralloc source. For camera source, allocate at least enough
             // size for native metadata buffers.
             size_t allottedSize = bufSize;
+#ifdef CAMCORDER_GRALLOC_SOURCE
+            if (portIndex == kPortIndexInput && type >= kMetadataBufferTypeGrallocSource) {
+#else
             if (portIndex == kPortIndexInput && type == kMetadataBufferTypeANWBuffer) {
+#endif
                 bufSize = max(sizeof(VideoGrallocMetadata), sizeof(VideoNativeMetadata));
             } else if (portIndex == kPortIndexInput && type == kMetadataBufferTypeCameraSource) {
                 bufSize = max(bufSize, sizeof(VideoNativeMetadata));
@@ -1798,6 +1807,14 @@ status_t ACodec::configureCodec(
             mInputMetadataType = (MetadataBufferType)storeMeta;
         }
 
+#ifdef CAMCORDER_GRALLOC_SOURCE
+        // For this specific case we could be using camera source even if storeMetaDataInBuffers
+        // returns Gralloc source. Pretend that we are; this will force us to use nBufferSize.
+        if (mInputMetadataType == kMetadataBufferTypeGrallocSource) {
+            mInputMetadataType = kMetadataBufferTypeCameraSource;
+        }
+#endif
+
         uint32_t usageBits;
         if (mOMX->getParameter(
                 mNode, (OMX_INDEXTYPE)OMX_IndexParamConsumerUsageBits,
@@ -6088,6 +6105,9 @@ void ACodec::BaseState::onInputBufferFilled(const sp<AMessage> &msg) {
                 status_t err2 = OK;
                 switch (metaType) {
                 case kMetadataBufferTypeInvalid:
+#ifdef CAMCORDER_GRALLOC_SOURCE
+                case kMetadataBufferTypeCameraSource:
+#endif
                     break;
 #ifndef OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
                 case kMetadataBufferTypeNativeHandleSource:
@@ -6319,6 +6339,10 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                 native_handle_t *handle = NULL;
                 VideoNativeHandleMetadata &nativeMeta =
                     *(VideoNativeHandleMetadata *)info->mData->data();
+#ifdef CAMCORDER_GRALLOC_SOURCE
+                VideoGrallocMetadata &grallocMeta =
+                    *(VideoGrallocMetadata *)info->mData->data();
+#endif
                 if (info->mData->size() >= sizeof(nativeMeta)
                         && nativeMeta.eType == kMetadataBufferTypeNativeHandleSource) {
 #ifdef OMX_ANDROID_COMPILE_AS_32BIT_ON_64BIT_PLATFORMS
@@ -6328,6 +6352,12 @@ bool ACodec::BaseState::onOMXFillBufferDone(
                     handle = (native_handle_t *)nativeMeta.pHandle;
 #endif
                 }
+#ifdef CAMCORDER_GRALLOC_SOURCE
+                else if (info->mData->size() >= sizeof(grallocMeta)
+                        && grallocMeta.eType == kMetadataBufferTypeGrallocSource) {
+                    handle = (native_handle_t *)(uintptr_t)grallocMeta.pHandle;
+                }
+#endif
                 info->mData->meta()->setPointer("handle", handle);
                 info->mData->meta()->setInt32("rangeOffset", rangeOffset);
                 info->mData->meta()->setInt32("rangeLength", rangeLength);
@@ -7035,10 +7065,12 @@ void ACodec::LoadedState::onCreateInputSurface(
         err = mCodec->mOMX->createInputSurface(
                 mCodec->mNode, kPortIndexInput, dataSpace, &bufferProducer,
                 &mCodec->mInputMetadataType);
+#ifndef CAMCORDER_GRALLOC_SOURCE
         // framework uses ANW buffers internally instead of gralloc handles
         if (mCodec->mInputMetadataType == kMetadataBufferTypeGrallocSource) {
             mCodec->mInputMetadataType = kMetadataBufferTypeANWBuffer;
         }
+#endif
     }
 
     if (err == OK) {
@@ -7081,10 +7113,12 @@ void ACodec::LoadedState::onSetInputSurface(
         err = mCodec->mOMX->setInputSurface(
                 mCodec->mNode, kPortIndexInput, surface->getBufferConsumer(),
                 &mCodec->mInputMetadataType);
+#ifndef CAMCORDER_GRALLOC_SOURCE
         // framework uses ANW buffers internally instead of gralloc handles
         if (mCodec->mInputMetadataType == kMetadataBufferTypeGrallocSource) {
             mCodec->mInputMetadataType = kMetadataBufferTypeANWBuffer;
         }
+#endif
     }
 
     if (err == OK) {
diff --git a/media/libstagefright/Android.mk b/media/libstagefright/Android.mk
index 03c77ac..c887c56 100644
--- a/media/libstagefright/Android.mk
+++ b/media/libstagefright/Android.mk
@@ -141,6 +141,10 @@ LOCAL_SHARED_LIBRARIES += \
         libdl \
         libRScpp \
 
+ifeq ($(TARGET_HAS_LEGACY_CAMERA_HAL1),true)
+LOCAL_CFLAGS += -DCAMCORDER_GRALLOC_SOURCE
+endif
+
 LOCAL_CFLAGS += -Wno-multichar -Werror -Wno-error=deprecated-declarations -Wall
 
 # enable experiments only in userdebug and eng builds
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index fa2a3a4..942aaca 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -1254,6 +1254,10 @@ void CameraSource::processBufferQueueFrame(BufferItem& buffer) {
 MetadataBufferType CameraSource::metaDataStoredInVideoBuffers() const {
     ALOGV("metaDataStoredInVideoBuffers");
 
+#ifdef CAMCORDER_GRALLOC_SOURCE
+    return kMetadataBufferTypeGrallocSource;
+#endif
+
     // Output buffers will contain metadata if camera sends us buffer in metadata mode or via
     // buffer queue.
     switch (mVideoBufferMode) {
diff --git a/media/libstagefright/SurfaceMediaSource.cpp b/media/libstagefright/SurfaceMediaSource.cpp
index 15ff569..0e9b4e6 100644
--- a/media/libstagefright/SurfaceMediaSource.cpp
+++ b/media/libstagefright/SurfaceMediaSource.cpp
@@ -129,7 +129,11 @@ status_t SurfaceMediaSource::setFrameRate(int32_t fps)
 
 MetadataBufferType SurfaceMediaSource::metaDataStoredInVideoBuffers() const {
     ALOGV("isMetaDataStoredInVideoBuffers");
+#ifdef CAMCORDER_GRALLOC_SOURCE
+    return kMetadataBufferTypeGrallocSource;
+#else
     return kMetadataBufferTypeANWBuffer;
+#endif
 }
 
 int32_t SurfaceMediaSource::getFrameRate( ) const {
@@ -250,6 +254,35 @@ sp<MetaData> SurfaceMediaSource::getFormat()
     return meta;
 }
 
+#ifdef CAMCORDER_GRALLOC_SOURCE
+// Pass the data to the MediaBuffer. Pass in only the metadata
+// The metadata passed consists of two parts:
+// 1. First, there is an integer indicating that it is a GRAlloc
+// source (kMetadataBufferTypeGrallocSource)
+// 2. This is followed by the buffer_handle_t that is a handle to the
+// GRalloc buffer. The encoder needs to interpret this GRalloc handle
+// and encode the frames.
+// --------------------------------------------------------------
+// |  kMetadataBufferTypeGrallocSource | sizeof(buffer_handle_t) |
+// --------------------------------------------------------------
+// Note: Call only when you have the lock
+static void passMetadataBuffer(MediaBuffer **buffer,
+        buffer_handle_t bufferHandle) {
+    *buffer = new MediaBuffer(4 + sizeof(buffer_handle_t));
+    char *data = (char *)(*buffer)->data();
+    if (data == NULL) {
+        ALOGE("Cannot allocate memory for metadata buffer!");
+        return;
+    }
+    OMX_U32 type = kMetadataBufferTypeGrallocSource;
+    memcpy(data, &type, 4);
+    memcpy(data + 4, &bufferHandle, sizeof(buffer_handle_t));
+
+    ALOGV("handle = %p, , offset = %zu, length = %zu",
+            bufferHandle, (*buffer)->range_length(), (*buffer)->range_offset());
+}
+#endif
+
 // Pass the data to the MediaBuffer. Pass in only the metadata
 // Note: Call only when you have the lock
 void SurfaceMediaSource::passMetadataBuffer_l(MediaBuffer **buffer,
@@ -352,7 +385,11 @@ status_t SurfaceMediaSource::read(
     mNumFramesEncoded++;
     // Pass the data to the MediaBuffer. Pass in only the metadata
 
+#ifdef CAMCORDER_GRALLOC_SOURCE
+    passMetadataBuffer(buffer, mSlots[mCurrentSlot].mGraphicBuffer->handle);
+#else
     passMetadataBuffer_l(buffer, mSlots[mCurrentSlot].mGraphicBuffer->getNativeBuffer());
+#endif
 
     (*buffer)->setObserver(this);
     (*buffer)->add_ref();
-- 
2.7.4


From 715b39770101ff6618a542b8716df8988573f7c7 Mon Sep 17 00:00:00 2001
From: Dominggoes Isakh <drjisakh@gmail.com>
Date: Sat, 12 Nov 2016 14:44:16 +0100
Subject: [PATCH 35/39] OMXNodeInstance: More legacy HAL1 fixes after merge of
 android-7.1.0_r7

Original commit: https://github.com/nitrogen-project/android_frameworks_av/commit/4ec00575cec1514c1272f99a0fd3b1041091446d

Change-Id: I807a23a7e92b70f0d9f3d807636ea4649a413924
---
 media/libstagefright/omx/OMXNodeInstance.cpp | 4 ++++
 1 file changed, 4 insertions(+)

diff --git a/media/libstagefright/omx/OMXNodeInstance.cpp b/media/libstagefright/omx/OMXNodeInstance.cpp
index 735c532..3cf9c3b 100644
--- a/media/libstagefright/omx/OMXNodeInstance.cpp
+++ b/media/libstagefright/omx/OMXNodeInstance.cpp
@@ -795,7 +795,11 @@ status_t OMXNodeInstance::useBuffer(
     // metadata buffers are not connected cross process
     // use a backup buffer instead of the actual buffer
     BufferMeta *buffer_meta;
+#ifdef CAMCORDER_GRALLOC_SOURCE
+    bool useBackup = false;
+#else
     bool useBackup = mMetadataType[portIndex] != kMetadataBufferTypeInvalid;
+#endif
     OMX_U8 *data = static_cast<OMX_U8 *>(params->pointer());
     // allocate backup buffer
     if (useBackup) {
-- 
2.7.4


From 967eed7f0da6f05af52e060715553016747316c4 Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Mon, 19 Sep 2016 23:11:20 +0200
Subject: [PATCH 36/39] camera: bring back CAMERA_PARAMETERS_EXTRA

Change-Id: Ibe01e15fed240d874607f2904d28a5193efd7202
(cherry picked from commit 98701c41e638d31a55255b8b8998763b0f02104a)
---
 camera/CameraParameters.cpp            |  4 ++++
 include/camera/CameraParameters.h      |  5 +++++
 include/camera/CameraParametersExtra.h | 41 ++++++++++++++++++++++++++++++++++
 3 files changed, 50 insertions(+)
 create mode 100644 include/camera/CameraParametersExtra.h

diff --git a/camera/CameraParameters.cpp b/camera/CameraParameters.cpp
index 68969cf..8b42ff9 100644
--- a/camera/CameraParameters.cpp
+++ b/camera/CameraParameters.cpp
@@ -173,6 +173,10 @@ const char CameraParameters::FOCUS_MODE_CONTINUOUS_PICTURE[] = "continuous-pictu
 const char CameraParameters::LIGHTFX_LOWLIGHT[] = "low-light";
 const char CameraParameters::LIGHTFX_HDR[] = "high-dynamic-range";
 
+#ifdef CAMERA_PARAMETERS_EXTRA_C
+CAMERA_PARAMETERS_EXTRA_C
+#endif
+
 CameraParameters::CameraParameters()
                 : mMap()
 {
diff --git a/include/camera/CameraParameters.h b/include/camera/CameraParameters.h
index ba33ffe..74517b4 100644
--- a/include/camera/CameraParameters.h
+++ b/include/camera/CameraParameters.h
@@ -19,6 +19,7 @@
 
 #include <utils/KeyedVector.h>
 #include <utils/String8.h>
+#include <camera/CameraParametersExtra.h>
 
 namespace android {
 
@@ -683,6 +684,10 @@ public:
     // High-dynamic range mode
     static const char LIGHTFX_HDR[];
 
+#ifdef CAMERA_PARAMETERS_EXTRA_H
+CAMERA_PARAMETERS_EXTRA_H
+#endif
+
     /**
      * Returns the the supported preview formats as an enum given in graphics.h
      * corrsponding to the format given in the input string or -1 if no such
diff --git a/include/camera/CameraParametersExtra.h b/include/camera/CameraParametersExtra.h
new file mode 100644
index 0000000..c0d1681
--- /dev/null
+++ b/include/camera/CameraParametersExtra.h
@@ -0,0 +1,41 @@
+// Overload this file in your device specific config if you need
+// to add extra camera parameters.
+// A typical file would look like this:
+/*
+ * Copyright (C) 2014 The CyanogenMod Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_HARDWARE_CAMERA_PARAMETERS_EXTRA_H
+#define ANDROID_HARDWARE_CAMERA_PARAMETERS_EXTRA_H
+
+/*
+#define CAMERA_PARAMETERS_EXTRA_C \
+const char CameraParameters::KEY_SUPPORTED_BURST_NUM[] = "supported-burst-num"; \
+const char CameraParameters::KEY_BURST_NUM[] = "burst-num"; \
+const char CameraParameters::KEY_SUPPORTED_HDR_MODES[] = "supported-hdr-modes"; \
+const char CameraParameters::KEY_HDR_MODE[] = "hdr-mode"; \
+const char CameraParameters::HDR_MODE_OFF[] = "hdr-mode-off"; \
+const char CameraParameters::HDR_MODE_HDR[] = "hdr-mode-hdr";
+
+#define CAMERA_PARAMETERS_EXTRA_H \
+    static const char KEY_SUPPORTED_BURST_NUM[]; \
+    static const char KEY_BURST_NUM[]; \
+    static const char KEY_SUPPORTED_HDR_MODES[]; \
+    static const char KEY_HDR_MODE[]; \
+    static const char HDR_MODE_OFF[]; \
+    static const char HDR_MODE_HDR[];
+*/
+
+#endif
-- 
2.7.4


From 58c3b0ea992fff435fb82b1badf780c82c210fb7 Mon Sep 17 00:00:00 2001
From: Steve Kondik <shade@chemlab.org>
Date: Mon, 9 Jan 2017 23:16:24 +0100
Subject: [PATCH 37/39] camera: Better fix for janky metadata issue

Change-Id: I9febb3f6f8bdfe38d66f27db80272fd4e62fd21d
---
 include/camera/CameraMetadata.h | 1 +
 1 file changed, 1 insertion(+)

diff --git a/include/camera/CameraMetadata.h b/include/camera/CameraMetadata.h
index d284477..fb5d14d 100644
--- a/include/camera/CameraMetadata.h
+++ b/include/camera/CameraMetadata.h
@@ -222,6 +222,7 @@ class CameraMetadata: public Parcelable {
 
   private:
     camera_metadata_t *mBuffer;
+    volatile char      mReserved[3];
     mutable bool       mLocked;
 
     /**
-- 
2.7.4


From 47bc6a515b32ea8d95cfc295087d05aef015269e Mon Sep 17 00:00:00 2001
From: maxwen <max.weninger@gmail.com>
Date: Tue, 4 Oct 2016 02:49:23 +0200
Subject: [PATCH 38/39] bring back TARGET_QCOM_MEDIA_VARIANT

Change-Id: If20e57e3abcc3f6b79fb7cba1651fa4d30c511a0
---
 media/libavextensions/Android.mk | 25 ++++++++++++++++++++-----
 1 file changed, 20 insertions(+), 5 deletions(-)

diff --git a/media/libavextensions/Android.mk b/media/libavextensions/Android.mk
index ce471da..cf52880 100644
--- a/media/libavextensions/Android.mk
+++ b/media/libavextensions/Android.mk
@@ -12,10 +12,15 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
         $(TOP)/external/flac/include \
-        $(TOP)/hardware/qcom/media/mm-core/inc \
         $(TOP)/frameworks/av/media/libstagefright \
         $(TOP)/frameworks/av/media/libstagefright/mpeg2ts \
 
+ifeq ($(TARGET_QCOM_MEDIA_VARIANT),)
+    LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media/mm-core/inc
+else
+    LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media-$(TARGET_QCOM_MEDIA_VARIANT)/mm-core/inc
+endif
+
 LOCAL_CFLAGS += -Wno-multichar -Werror
 
 ifeq ($(TARGET_ENABLE_QC_AV_ENHANCEMENTS),true)
@@ -40,8 +45,13 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/media/libavextensions \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
-        $(TOP)/external/flac/include \
-        $(TOP)/hardware/qcom/media/mm-core/inc
+        $(TOP)/external/flac/include
+
+ifeq ($(TARGET_QCOM_MEDIA_VARIANT),)
+    LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media/mm-core/inc
+else
+    LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media-$(TARGET_QCOM_MEDIA_VARIANT)/mm-core/inc
+endif
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
 
@@ -73,8 +83,13 @@ LOCAL_C_INCLUDES:= \
         $(TOP)/frameworks/av/media/libstagefright/rtsp \
         $(TOP)/frameworks/native/include/media/hardware \
         $(TOP)/frameworks/native/include/media/openmax \
-        $(TOP)/external/flac/include \
-        $(TOP)/hardware/qcom/media/mm-core/inc
+        $(TOP)/external/flac/include
+
+ifeq ($(TARGET_QCOM_MEDIA_VARIANT),)
+    LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media/mm-core/inc
+else
+    LOCAL_C_INCLUDES += $(TOP)/hardware/qcom/media-$(TARGET_QCOM_MEDIA_VARIANT)/mm-core/inc
+endif
 
 LOCAL_CFLAGS += -Wno-multichar -Werror
 
-- 
2.7.4


From 07a56a4536055e31d6d7a03a58595f0e4255a15e Mon Sep 17 00:00:00 2001
From: sooorajjj <sooraj.sizon@micromaxinfo.com>
Date: Mon, 6 Feb 2017 19:10:49 +0530
Subject: [PATCH 39/39] Av: fix Merge Derp!

---
 media/libmediaplayerservice/MediaPlayerService.cpp | 2 +-
 media/libmediaplayerservice/MediaPlayerService.h   | 5 +----
 2 files changed, 2 insertions(+), 5 deletions(-)

diff --git a/media/libmediaplayerservice/MediaPlayerService.cpp b/media/libmediaplayerservice/MediaPlayerService.cpp
index effe14d..54979b4 100644
--- a/media/libmediaplayerservice/MediaPlayerService.cpp
+++ b/media/libmediaplayerservice/MediaPlayerService.cpp
@@ -1890,7 +1890,7 @@ status_t MediaPlayerService::AudioOutput::open(
 #ifdef DOLBY_ENABLE
             updateTrackOnAudioProcessed(mTrack, reuse);
 #endif // DOLBY_END
-            return OK;
+            return updateTrack();
         }
     }
 
diff --git a/media/libmediaplayerservice/MediaPlayerService.h b/media/libmediaplayerservice/MediaPlayerService.h
index 4c1af3e..ccae822 100644
--- a/media/libmediaplayerservice/MediaPlayerService.h
+++ b/media/libmediaplayerservice/MediaPlayerService.h
@@ -154,15 +154,12 @@ class MediaPlayerService : public BnMediaPlayerService
                 int event, void *me, void *info);
                void             deleteRecycledTrack_l();
                void             close_l();
-<<<<<<< HEAD
-           status_t             updateTrack();
-=======
 #ifdef DOLBY_ENABLE
                void             setDolbyParameters(const String8& keyValuePairs);
                void             updateTrackOnAudioProcessed(sp<AudioTrack> t, bool trackReused);
                bool             mProcessedAudio;
 #endif // DOLBY_END
->>>>>>> 397691f... Merge DAX changes
+           status_t             updateTrack();
 
         sp<AudioTrack>          mTrack;
         sp<AudioTrack>          mRecycledTrack;
-- 
2.7.4

